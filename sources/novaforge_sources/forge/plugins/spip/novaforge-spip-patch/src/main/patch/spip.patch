diff -rNU5 spip-ori/config/chmod.php spip/config/chmod.php
--- spip-ori/config/chmod.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/config/chmod.php	2013-04-05 11:06:41.133923139 +0200
@@ -0,0 +1,4 @@
+<?php
+if (!defined("_ECRIRE_INC_VERSION")) return;
+if (!defined('_SPIP_CHMOD')) define('_SPIP_CHMOD', 0777);
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/config/_config_cas.php spip/config/_config_cas.php
--- spip-ori/config/_config_cas.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/config/_config_cas.php	2013-04-05 11:06:41.133923139 +0200
@@ -0,0 +1,21 @@
+<?php
+/**
+*** CICAS PLUGIN CONFIGURATION
+**/
+// CAS ONLY : oui
+// CAS AND SPIP : hybride
+// ONLY SPIP OTHERWISE
+$GLOBALS['ciconfig']['cicas'] = 'oui';
+
+// Define which user field is the id
+$GLOBALS['ciconfig']['cicasuid'] = 'login';
+
+// CAS server URL
+$GLOBALS['ciconfig']['cicasurldefaut'] = 'localhost';
+
+// CAS server DIRECTORY
+$GLOBALS['ciconfig']['cicasrepertoire'] = '/cas';
+
+// CAS server PORT
+$GLOBALS['ciconfig']['cicasport'] = '8443';
+?>
diff -rNU5 spip-ori/config/.htaccess spip/config/.htaccess
--- spip-ori/config/.htaccess	1970-01-01 01:00:00.000000000 +0100
+++ spip/config/.htaccess	2013-04-05 11:06:41.141923139 +0200
@@ -0,0 +1 @@
+deny from all
diff -rNU5 spip-ori/config/mes_options.php spip/config/mes_options.php
--- spip-ori/config/mes_options.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/config/mes_options.php	2013-04-05 11:06:41.141923139 +0200
@@ -0,0 +1,36 @@
+<?php
+if ( preg_match(',/spip/([a-zA-Z0-9_-]+)/?,',$_SERVER['REQUEST_URI'],$r)) {
+	$site_id = $r[1];
+
+	$path = _DIR_RACINE . 'sites/' . $site_id. '/';
+
+	$cookie_prefix = $site_id;
+	//	$table_prefix = $site_id;
+	$table_prefix = "spip";
+
+	define('_SPIP_PATH',
+	$path . ':' .
+	_DIR_RACINE .':' .
+	_DIR_RACINE . 'squelettes-dist/:' .
+	_DIR_RACINE.'prive/:' .
+	_DIR_RESTREINT);
+
+	// exemple de logs a la racine pour tous les sites
+	define('_FILE_LOG_SUFFIX', '_' . $site_id . '.log');
+	define('_DIR_LOG',  _DIR_RACINE . 'log/');
+
+	spip_initialisation(
+	($path . _NOM_PERMANENTS_INACCESSIBLES),
+	($path . _NOM_PERMANENTS_ACCESSIBLES),
+	($path . _NOM_TEMPORAIRES_INACCESSIBLES),
+	($path . _NOM_TEMPORAIRES_ACCESSIBLES));
+
+	$GLOBALS['dossier_squelettes'] = $path.'squelettes';
+	if (is_readable($f = $path._NOM_PERMANENTS_INACCESSIBLES._NOM_CONFIG.'.php')) {
+		include($f);
+	}
+
+	//Need because of php version used by Novaforge
+	date_default_timezone_set('Europe/Paris');
+}
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/ecrire/base/abstract_sql.php spip/ecrire/base/abstract_sql.php
--- spip-ori/ecrire/base/abstract_sql.php	2011-04-06 22:30:54.000000000 +0200
+++ spip/ecrire/base/abstract_sql.php	2013-04-05 11:06:41.141923139 +0200
@@ -78,10 +78,14 @@
 
 // http://doc.spip.org/@sql_select
 function sql_select ($select = array(), $from = array(), $where = array(),
 	$groupby = array(), $orderby = array(), $limit = '', $having = array(),
 	$serveur='', $option=true) {
+	//patch novaforge
+	if (isset($GLOBALS['novaforge_force_serveur'])){
+		$serveur='mysql';
+	}
 	$f = sql_serveur('select', $serveur,  $option==='continue' OR $option===false);
 	if (!is_string($f) OR !$f) return false;
 
 	$debug = (isset($GLOBALS['var_mode']) AND $GLOBALS['var_mode'] == 'debug' );
 	if (($option !== false) AND !$debug) {
@@ -128,19 +132,27 @@
 	return $r;
 }
 
 // http://doc.spip.org/@sql_alter
 function sql_alter($q, $serveur='', $option=true) {
+	//patch novaforge
+	if (isset($GLOBALS['novaforge_force_serveur'])){
+		$serveur='mysql';
+	}
 	$f = sql_serveur('alter', $serveur,  $option==='continue' OR $option===false);
 	if (!is_string($f) OR !$f) return false;
 	$r = $f($q, $serveur, $option!==false);
 	if ($r===false) spip_sql_erreur($serveur);
 	return $r;
 }
 
 // http://doc.spip.org/@sql_fetch
 function sql_fetch($res, $serveur='', $option=true) {
+	//patch novaforge
+	if (isset($GLOBALS['novaforge_force_serveur'])){
+		$serveur='mysql';
+	}
 	$f = sql_serveur('fetch', $serveur,  $option==='continue' OR $option===false);
 	if (!is_string($f) OR !$f) return false;
 	return $f($res, NULL, $serveur, $option!==false);
 }
 
@@ -193,10 +205,14 @@
 }
 
 // http://doc.spip.org/@sql_free
 function sql_free($res, $serveur='', $option=true)
 {
+	//patch novaforge
+	if (isset($GLOBALS['novaforge_force_serveur'])){
+		$serveur='mysql';
+	}
 	$f = sql_serveur('free', $serveur,  $option==='continue' OR $option===false);
 	if (!is_string($f) OR !$f) return false;
 	return $f($res);
 }
 
@@ -215,10 +231,15 @@
 }
 
 // http://doc.spip.org/@sql_insertq
 function sql_insertq($table, $couples=array(), $desc=array(), $serveur='', $option=true)
 {
+	//patch novaforge
+	if (isset($GLOBALS['novaforge_force_serveur'])){
+		$serveur='mysql';
+	}
+
 	$f = sql_serveur('insertq', $serveur,  $option==='continue' OR $option===false);
 	if (!is_string($f) OR !$f) return false;
 	$r = $f($table, $couples, $desc, $serveur, $option!==false);
 	if ($r === false) spip_sql_erreur($serveur);
 	return $r;
@@ -248,10 +269,14 @@
 // Cette fonction est donc plus utile que la precedente,d'autant qu'elle
 // permet de gerer les differences de representation des constantes.
 // http://doc.spip.org/@sql_updateq
 function sql_updateq($table, $exp, $where='', $desc=array(), $serveur='', $option=true)
 {
+	//patch novaforge
+	if (isset($GLOBALS['novaforge_force_serveur'])){
+		$serveur='mysql';
+	}
 	$f = sql_serveur('updateq', $serveur,  $option==='continue' OR $option===false);
 	if (!is_string($f) OR !$f) return false;
 	$r = $f($table, $exp, $where, $desc, $serveur, $option!==false);
 	if ($r === false) spip_sql_erreur($serveur);
 	return $r;
@@ -467,10 +492,14 @@
 
 # Retourne l'unique champ demande dans une requete Select a resultat unique
 // http://doc.spip.org/@sql_getfetsel
 function sql_getfetsel($select, $from = array(), $where = array(), $groupby = array(), 
 	$orderby = array(), $limit = '', $having = array(), $serveur='', $option=true) {
+	//patch novaforge
+	if (isset($GLOBALS['novaforge_force_serveur'])){
+		$serveur='mysql';
+	}
 	if (preg_match('/\s+as\s+(\w+)$/i', $select, $c)) $id = $c[1];
 	elseif (!preg_match('/\W/', $select)) $id = $select;
 	else {$id = 'n'; $select .= ' AS n';}
 	$r = sql_fetsel($select, $from, $where,	$groupby, $orderby, $limit, $having, $serveur, $option);
 	if ($option===false) return $r;
diff -rNU5 spip-ori/ecrire/base/connect_sql.php spip/ecrire/base/connect_sql.php
--- spip-ori/ecrire/base/connect_sql.php	2011-04-06 22:30:54.000000000 +0200
+++ spip/ecrire/base/connect_sql.php	2013-04-05 11:06:41.141923139 +0200
@@ -33,10 +33,15 @@
 	if (isset($connexions[$index][$version])) return $connexions[$index];
 
 	include_spip('base/abstract_sql');
 	$install = (_request('exec') == 'install');
 
+	//patch novaforge
+	if (isset($GLOBALS['novaforge_site_install'])){
+		$install='true';
+	}
+
 	// Premiere connexion ?
 	if (!($old = isset($connexions[$index]))) {
 		$f = (!preg_match('/^[\w\.]*$/', $serveur))
 		? '' // nom de serveur mal ecrit
 		: ($serveur ?
diff -rNU5 spip-ori/ecrire/inc/bandeau.php spip/ecrire/inc/bandeau.php
--- spip-ori/ecrire/inc/bandeau.php	2011-04-06 22:30:54.000000000 +0200
+++ spip/ecrire/inc/bandeau.php	2013-04-05 11:06:41.141923139 +0200
@@ -42,12 +42,12 @@
 
 	if ($GLOBALS['meta']['forum_prive'] != 'non' OR sql_countsel('spip_forum'))
 		$boutons_admin['forum'] = new Bouton(
 			'messagerie-48.png', 'titre_forum');
 
-	$boutons_admin['auteurs'] = new Bouton(
-		'redacteurs-48.png', 'icone_auteurs');
+//	$boutons_admin['auteurs'] = new Bouton(
+//		'redacteurs-48.png', 'icone_auteurs');
 
 
 	if ($GLOBALS['meta']["activer_statistiques"] != 'non'
 	AND autoriser('voirstats')) {
 		$boutons_admin['statistiques_visites']=
@@ -150,14 +150,14 @@
 		include_spip('exec/auteurs');
 		$sousmenu['auteurs'] =
 			new Bouton("fiche-perso.png", 'icone_afficher_visiteurs', null, "statut=!".AUTEURS_MIN_REDAC);
 	}
 
-	$sousmenu['auteur_infos']=
-		new Bouton("auteur-24.gif", "icone_creer_nouvel_auteur", null, 'new=oui');
-
-	$boutons_admin['auteurs']->sousmenu= $sousmenu;
+//	$sousmenu['auteur_infos']=
+//		new Bouton("auteur-24.gif", "icone_creer_nouvel_auteur", null, 'new=oui');
+//
+//	$boutons_admin['auteurs']->sousmenu= $sousmenu;
 
 	// sous menu statistiques
 	if (isset($boutons_admin['statistiques_visites'])) {
 		$sousmenu=array(
 			//'espacement' => null,// les espacements debloquent si on a des icones sur 2 lignes
diff -rNU5 spip-ori/ecrire/inc/commencer_page.php spip/ecrire/inc/commencer_page.php
--- spip-ori/ecrire/inc/commencer_page.php	2011-04-06 22:30:54.000000000 +0200
+++ spip/ecrire/inc/commencer_page.php	2013-04-05 11:06:41.141923139 +0200
@@ -154,18 +154,18 @@
 			. "</div></li>";
 	}
 
 	$items .= "<li id='bandeau_couleur6' class='bandeau_couleur'><div class='menu-item'>";
 
-	if ($auth_can_disconnect) {
-			$alt=_T('icone_deconnecter');
-			$items .= "<a href='".
-			  generer_url_action("logout","logout=prive") .
-			  "' class='icone26' onmouseover=\"changestyle('bandeaudeconnecter');\" onfocus=\"changestyle('bandeaudeconnecter');\" onblur=\"changestyle('bandeaudeconnecter');\">" .
-			  http_img_pack("deconnecter-24.gif", "$alt", "width='26' height='20'") .
-			  "</a>";
-	}
+//	if ($auth_can_disconnect) {
+//			$alt=_T('icone_deconnecter');
+//			$items .= "<a href='".
+//			  generer_url_action("logout","logout=prive") .
+//			  "' class='icone26' onmouseover=\"changestyle('bandeaudeconnecter');\" onfocus=\"changestyle('bandeaudeconnecter');\" onblur=\"changestyle('bandeaudeconnecter');\">" .
+//			  http_img_pack("deconnecter-24.gif", "$alt", "width='26' height='20'") .
+//			  "</a>";
+//	}
 	$items .= "</div></li>"
 	  . "</ul></div>";
 
 	// <div> pour la barre des gadgets
 	// (elements invisibles qui s'ouvrent sous la barre precedente)
diff -rNU5 spip-ori/ecrire/inc/utils.php spip/ecrire/inc/utils.php
--- spip-ori/ecrire/inc/utils.php	2011-04-06 22:30:54.000000000 +0200
+++ spip/ecrire/inc/utils.php	2013-04-05 11:36:38.481980654 +0200
@@ -922,10 +922,12 @@
 	$http = (
 		(isset($_SERVER["SCRIPT_URI"]) AND
 			substr($_SERVER["SCRIPT_URI"],0,5) == 'https')
 		OR (isset($_SERVER['HTTPS']) AND
 		    test_valeur_serveur($_SERVER['HTTPS']))
+		OR (isset($_SERVER['HTTP_X_FORWARDED_SERVER']) AND
+		    strtolower($_SERVER['HTTP_X_FORWARDED_PROTO']) == 'https') 
 	) ? 'https' : 'http';
 	# note : HTTP_HOST contient le :port si necessaire
 	if (!$GLOBALS['REQUEST_URI']){
 		if (isset($_SERVER['REQUEST_URI'])) {
 			$GLOBALS['REQUEST_URI'] = $_SERVER['REQUEST_URI'];
@@ -935,12 +937,26 @@
 			AND !strpos($_SERVER['REQUEST_URI'], '?'))
 				$GLOBALS['REQUEST_URI'] .= '?'.$_SERVER['QUERY_STRING'];
 		}
 	}
 
-	$url[$profondeur] = url_de_($http,$_SERVER['HTTP_HOST'],$GLOBALS['REQUEST_URI'],$profondeur);
+	/**
+	* Quick patch to define the correct scheme and hostname 
+	* when this function is called by an process on the same server 
+	* (here located on 127.0.0.1) 
+		* It's dirty because that use an ENV variable.later, 
+	* we can use the forge service in order to define 
+	* the hostname
+	**/
+	$host=$_SERVER['HTTP_HOST']; 
+	if ($host == "127.0.0.1" AND getenv("HOSTNAMEFORGE")) 
+	{ 
+		$host = getenv("HOSTNAMEFORGE");
+		$http = 'https';
+	}	
 
+	$url[$profondeur] = url_de_($http,$host,$GLOBALS['REQUEST_URI'],$profondeur);
 	return $url[$profondeur];
 }
 /**
  * fonction testable de construction d'une url appelee par url_de_base()
  * @param string $http
diff -rNU5 spip-ori/ecrire/inc_version.php spip/ecrire/inc_version.php
--- spip-ori/ecrire/inc_version.php	2011-04-06 22:30:57.000000000 +0200
+++ spip/ecrire/inc_version.php	2013-04-05 11:06:41.145923139 +0200
@@ -491,24 +491,26 @@
 if (!(_FILE_CONNECT
 OR autoriser_sans_cookie(_request('exec'))
 OR _request('action') == 'cookie'
 OR _request('action') == 'converser'
 OR _request('action') == 'test_dirs')) {
-
-	// Si on peut installer, on lance illico
-	if (test_espace_prive()) {
-		include_spip('inc/headers');
-		redirige_url_ecrire("install");
-	} else {
-	// Si on est dans le site public, dire que qq s'en occupe
-		include_spip('inc/minipres');
-		utiliser_langue_visiteur();
-		echo minipres(_T('info_travaux_titre'), "<p style='text-align: center;'>"._T('info_travaux_texte')."</p>");
-		exit;
-	}
-	// autrement c'est une install ad hoc (spikini...), on sait pas faire
-}
+				// Si on peut installer, on lance illico
+				if (test_espace_prive()) {
+					include_spip('inc/headers');					
+					//patch novaforge					
+					if (!isset($GLOBALS['novaforge_site_install'])){
+						redirige_url_ecrire("install");
+					}
+				} else {
+					// Si on est dans le site public, dire que qq s'en occupe
+					include_spip('inc/minipres');
+					utiliser_langue_visiteur();
+					echo minipres(_T('info_travaux_titre'), "<p style='text-align: center;'>"._T('info_travaux_texte')."</p>");
+					exit;
+				}
+				// autrement c'est une install ad hoc (spikini...), on sait pas faire
+			}
 
 // Vanter notre art de la composition typographique
 // La globale $spip_header_silencieux permet de rendre le header minimal pour raisons de securite
 define('_HEADER_COMPOSED_BY', "Composed-By: SPIP");
 
diff -rNU5 spip-ori/ecrire/install/etape_fin.php spip/ecrire/install/etape_fin.php
--- spip-ori/ecrire/install/etape_fin.php	2011-04-06 22:30:49.000000000 +0200
+++ spip/ecrire/install/etape_fin.php	2013-04-05 11:06:41.145923139 +0200
@@ -48,15 +48,21 @@
 
 	// Verifier la securite des htaccess
 	// Si elle ne fonctionne pas, prevenir
 	$msg = install_verifier_htaccess();
 	if ($msg) {
-		$cible = _T('public:accueil_site');
-		$cible = generer_form_ecrire('accueil', '','', $cible);
-		echo minipres('AUTO', $msg . $cible);
-	// ok, deboucher dans l'espace prive
-	} else redirige_url_ecrire('accueil');
+		//patch novaforge: moving msg from web console to error log.
+		error_log("ERROR: problem when executing install_verifier_htaccess :" . $msg);
+		//		$cible = _T('public:accueil_site');
+		//		$cible = generer_form_ecrire('accueil', '','', $cible);
+		//		echo minipres('AUTO', $msg . $cible);
+		// ok, deboucher dans l'espace prive
+	} else {
+		//patch novaforge
+		//redirige_url_ecrire('accueil');
+		spip_log("New spip site has been successfully installed for connect file: " . $f);
+	}
 }
 
 function install_verifier_htaccess()
 {
 	if (verifier_htaccess(_DIR_TMP, true)
diff -rNU5 spip-ori/ecrire/nf_config_inc.php spip/ecrire/nf_config_inc.php
--- spip-ori/ecrire/nf_config_inc.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nf_config_inc.php	2013-04-05 11:06:41.145923139 +0200
@@ -0,0 +1,53 @@
+<?php
+//prefix for the BD scheme (_NF_SAFRAN.<siteId>)
+define('_NF_SAFRAN', "nfsafran_");
+
+define('_SCHEME', "http");
+define('_HOSTNAME', "@HOSTSPIP");
+
+define('_G_INSTANCE_WSDL', "http://127.0.0.1:9000/services/spipInstance?wsdl");
+define('_G_INSTANCE_METHOD', "getToolProjectId");
+
+// spip statuts
+define('_SPIP_1comite', "1comite");
+define('_SPIP_0minirezo', "0minirezo");
+define('_SPIP_5poubelle', "5poubelle");
+define('_SPIP_6forum', "6forum");
+
+// spip webmestre column
+define('_SPIP_WEBMESTRE_NON', "non");
+define('_SPIP_WEBMESTRE_OUI', "oui");
+
+//defined spip roles for mapping with forge roles
+define('_NF_ADMINISTRATOR', "administrator");
+define('_NF_AUTHOR', "author");
+define('_NF_WEBMASTER', "webmaster");
+define('_NF_VISITOR', "visitor");
+
+//DB. server type. Not validated for other type
+define('_NF_SERVER_DB', "mysql");
+
+//choice to have independent shema for each spip instance
+define('_NF_CHOIX_DB', "new_spip");
+
+//rights at spip configuration
+define('_NF_CHMOD_DB', "511");
+
+/*
+ *   To be configured by database admin
+ *   ----------------
+ */
+define('_NF_PORT_DB', "@PORTMYSQL");
+define('_NF_LOGIN_DB', "@SPIPMYSQLUSER");
+define('_NF_PASS_DB', "@SPIPMYSQLPASS");
+
+/*
+ * admin user added into each site DB. (at site creation)
+ *       To be configured
+ *       ----------------
+ */
+define('_NF_LOGIN_ADMIN_SPIP', "@SPIPADMINLOGIN");
+define('_NF_PASS_ADMIN_SPIP', "@SPIPADMINPASS");
+define('_NF_NOM_ADMIN_SPIP', "@SPIPADMINNAME");
+define('_NF_EMAIL_ADMIN_SPIP', "@SPIPADMINMAIL");
+?>
diff -rNU5 spip-ori/ecrire/nf_core.php spip/ecrire/nf_core.php
--- spip-ori/ecrire/nf_core.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nf_core.php	2013-04-05 11:06:41.145923139 +0200
@@ -0,0 +1,38 @@
+<?php
+/**
+  NovaForge(tm)
+  Copyright (c) 2010-2011 Bull S.A.S.
+  
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published by 
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+  
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU Lesser General Public License for more details.
+  
+  You should have received a copy of the GNU Lesser General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+//initialisation for spip environment
+$GLOBALS['novaforge_site_install']="novaforge_install";
+define('_ESPACE_PRIVE', true);
+require_once('inc_version.php');
+require_once('req/mysql.php');
+require_once('base/abstract_sql.php');
+
+//config for soap api
+require_once ('nf_config_inc.php');
+
+//soap api implementation
+require_once ('nf_spip_account_api.php');
+require_once ('nf_spip_site_api.php');
+
+//php common dependencies for soap api
+require_once('nf_spip_commons_api.php');
+require_once('inc/auth.php');
+require_once('action/editer_auteur.php');
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/ecrire/nf_forge_api.php spip/ecrire/nf_forge_api.php
--- spip-ori/ecrire/nf_forge_api.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nf_forge_api.php	2013-04-05 11:06:41.145923139 +0200
@@ -0,0 +1,50 @@
+<?php
+/**
+ NovaForge(tm)
+ Copyright (c) 2010-2011 Bull S.A.S.
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU Lesser General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+require_once( 'nusoap/nusoap.php' );
+
+/**
+ * Return project id for spip instance
+ * @param string $p_instance uuid send by forge
+ * @access public
+ */
+function get_spip_instance_project_id( $p_instance ) {
+
+	ini_set("soap.wsdl_cache_enabled", "0");
+
+	$clientSOAP = new nusoap_client(_G_INSTANCE_WSDL,true);
+	$clientSOAP->setUseCurl(false);
+	$result = $clientSOAP->call(_G_INSTANCE_METHOD, array('arg0' => $p_instance));
+	// Check for a fault
+	if ($clientSOAP->fault) {
+		error_log( "fault :'" . $result['faultstring'] ."'");
+		return false;
+	} else {
+		// Check for errors
+		$err = $clientSOAP->getError();
+		if ($err) {
+			// Display the error
+			error_log( "err :'" . $err ."'");
+			return false;
+		}
+	}
+
+	return $result['return'];
+}
+?>
diff -rNU5 spip-ori/ecrire/nf_forge_authentification.php spip/ecrire/nf_forge_authentification.php
--- spip-ori/ecrire/nf_forge_authentification.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nf_forge_authentification.php	2013-04-05 11:06:41.145923139 +0200
@@ -0,0 +1,46 @@
+<?php
+/**
+ NovaForge(tm)
+ Copyright (c) 2010-2011 Bull S.A.S.
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU Lesser General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+require_once( 'nf_core.php' );
+require_once( 'nf_forge_api.php' );
+require_once( 'inc/cookie.php' );
+require_once( 'inc/session.php' );
+require_once( 'base/connect_sql.php' );
+
+$f_username		= '';
+$f_password		= '';
+$f_perm_login = '';
+if (isset($_REQUEST['instance_id']) and $_REQUEST['instance_id'] !="")
+{
+	$instance_id = $_REQUEST['instance_id'];
+	$projectToolId = get_spip_instance_project_id($instance_id);
+	preg_match(',/spip/([a-zA-Z0-9_-]+)/?,',$_SERVER['REQUEST_URI'],$r);
+	$site_id = $r[1];
+	// case first call to the tool (without projectToolId into the url)
+	if($site_id == "ecrire") {
+		$uri_to_replace = $_SERVER['REQUEST_URI'];
+		$uri = str_replace("spip","spip/$projectToolId",$uri_to_replace);
+		$url = _SCHEME . '://' . _HOSTNAME . '/' . $uri;
+		header( "Location: $url" );
+	} else {
+		//redirect to the spip tool (admin and author page).
+		$url = _SCHEME . '://' . _HOSTNAME . '/' . "spip/" . $projectToolId . "/ecrire/index.php" ;
+		header( "Location: $url" );
+	}
+}
+?>
diff -rNU5 spip-ori/ecrire/nf_spip_account_api.php spip/ecrire/nf_spip_account_api.php
--- spip-ori/ecrire/nf_spip_account_api.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nf_spip_account_api.php	2013-04-05 11:06:41.145923139 +0200
@@ -0,0 +1,192 @@
+<?php
+/**
+  NovaForge(tm)
+  Copyright (c) 2010-2011 Bull S.A.S.
+  
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published by 
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+  
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU Lesser General Public License for more details.
+  
+  You should have received a copy of the GNU Lesser General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+function add_user($username, $password, $userData){
+
+	//	require_once('action/editer_auteur.php');
+	if (!$auteur = check_login_config_file($username, $password)){
+		return new soap_fault( 'Client', '', 'Access Denied', 'Username/password combination was incorrect');
+	}
+
+	if ( !has_administrator_access_config_file( $auteur.login ) ) {
+		return new soap_fault( 'Client', '', 'Access Denied', 'User does not have administrator access');
+	}
+
+	$err = '';
+	$nom = $userData['nom'];
+	$email=$userData['email'];
+	$nom_site='';
+	$url_site='';
+	$inst1_user = array('nom' => $nom, 'email' => $email, 'nom_site' => $nom_site, 'url_site' => $url_site);
+	$login=$userData['login'];
+	$pass=$userData['pass'];
+	//	$webmestre=$userData['webmestre'];
+	// Force to non at user creation. Give this property when adding the user the site
+	$webmestre=_SPIP_WEBMESTRE_NON;
+	// Force to 5poubelle at user creation. Give role when adding the user the site
+	//	$statut=$userData['statut'];
+	$statut=_SPIP_5poubelle;
+	$inst2_user = array('login' => $login, 'pass' => $pass, 'webmestre' => $webmestre, 'statut' => $statut);
+
+	//1st step : insert line for an auteur into spip_autheurs
+	$id_auteur = insert_auteur();
+
+	//2nd step : update the line with user inputs
+	if ($id_auteur > 0){
+		$err = nf_auteurs_set($id_auteur, $inst1_user, $inst2_user);
+	}
+	if ($err==''){
+		spip_log("userID = " . $id_auteur. " has been added with connect dir= " . _DIR_CONNECT);
+		return $id_auteur;
+	}
+	else {
+		return new soap_fault( 'Client', '', 'Add user Error', 'Error when adding user');
+	}
+}
+
+//return the list of statuts
+function get_roles(){
+	$roles = array(_NF_ADMINISTRATOR, _NF_WEBMASTER, _NF_AUTHOR, _NF_VISITOR);
+	return $roles;
+}
+
+function get_user_info($username, $password, $login)
+{
+	if (!$auteur = check_login_config_file($username, $password)){
+		return new soap_fault( 'Client', '', 'Access Denied', 'Username/password combination was incorrect');
+	}
+
+	if ( !has_administrator_access_config_file( $auteur.login ) ) {
+		return new soap_fault( 'Client', '', 'Access Denied', 'User does not have administrator access');
+	}
+
+	//Problem met to get right result with sql_allfetsel; use sql_getfetsel.
+	//	$result = sql_allfetsel("id_auteur,nom,login", "spip_auteurs", "login=" . sql_quote($login));
+	$id_auteur = sql_getfetsel("id_auteur", "spip_auteurs", "login=" . sql_quote($login));
+	$nom = sql_getfetsel("nom", "spip_auteurs", "login=" . sql_quote($login));
+	$login = sql_getfetsel("login", "spip_auteurs", "login=" . sql_quote($login));
+	$email = sql_getfetsel("email", "spip_auteurs", "login=" . sql_quote($login));
+	$webmestre = sql_getfetsel("webmestre", "spip_auteurs", "login=" . sql_quote($login));
+	$statut = sql_getfetsel("statut", "spip_auteurs", "login=" . sql_quote($login));
+	$nom_site = sql_getfetsel("nom_site", "spip_auteurs", "login=" . sql_quote($login));
+	$url_site = sql_getfetsel("url_site", "spip_auteurs", "login=" . sql_quote($login));
+
+	//	while ($row = sql_fetch($result)) {
+	//$nom = $row["nom"];
+	//		$id= $row["id_auteur"];
+	//	}
+	$user_info = array("nom" => $nom, "id" => $id_auteur, "login" => $login, "email" => $email, "webmestre" => $webmestre, "statut" => $statut, "nom_site" => $nom_site, "url_site" => $url_site);
+	return $user_info;
+}
+
+function get_user_id($username, $password, $login)
+{
+	if (!$auteur = check_login_config_file($username, $password)){
+		return new soap_fault( 'Client', '', 'Access Denied', 'Username/password combination was incorrect');
+	}
+
+	if ( !has_administrator_access_config_file( $auteur.login ) ) {
+		return new soap_fault( 'Client', '', 'Access Denied', 'User does not have administrator access');
+	}
+	$id_auteur = sql_getfetsel("id_auteur", "spip_auteurs", "login=" . sql_quote($login));
+	return $id_auteur;
+}
+
+function delete_user($username, $password, $login=''){
+	if (!$auteur = check_login_config_file($username, $password)){
+		return new soap_fault( 'Client', '', 'Access Denied', 'Username/password combination was incorrect');
+	}
+
+	if ( !has_administrator_access_config_file( $auteur.login ) ) {
+		return new soap_fault( 'Client', '', 'Access Denied', 'User does not have administrator access');
+	}
+
+	//Warning: only put statut = 5poubelle. The user is not deleted from database.
+	// Then a plugin exists to delete objects with 5poubelle status.
+	//	require_once 'action/editer_auteur.php';
+	$statut=_SPIP_5poubelle;
+	$user_delete = array(
+	'login' => $login, 
+	'statut' => $statut);
+	$id_auteur = sql_getfetsel("id_auteur", "spip_auteurs", "login=" . sql_quote($login));
+	$err = auteurs_set($id_auteur, $user_delete);
+	if ($err==''){
+		spip_log("userID = " . $id_auteur. " has been deleted with connect dir= " . _DIR_CONNECT);
+		return true;
+	}
+	else {
+		return new soap_fault( 'Client', '', 'Delete user Error', 'Error when deleting user');
+	}
+}
+
+//permet de modifier tous les parametres donnés ds le tableau $user (y compris le login)
+function update_user($username, $password, $login='', $user){
+	//	require_once 'action/editer_auteur.php';
+	if (!$auteur = check_login_config_file($username, $password)){
+		return new soap_fault( 'Client', '', 'Access Denied', 'Username/password combination was incorrect');
+	}
+
+	if ( !has_administrator_access_config_file( $auteur.login ) ) {
+		return new soap_fault( 'Client', '', 'Access Denied', 'User does not have administrator access');
+	}
+
+	$id_auteur = sql_getfetsel("id_auteur", "spip_auteurs", "login=" . sql_quote($login));
+	$err = auteurs_set($id_auteur, $user);
+	if ($err==''){
+		spip_log("userID = " . $id_auteur. " has been updated with connect dir= " . _DIR_CONNECT);
+		return true;
+	}
+	else {
+		return new soap_fault( 'Client', '', 'Update user Error', 'Error when updating user');
+	}
+}
+
+
+//***********************************************************************************************************
+//                                      utilities functions
+//***********************************************************************************************************
+//modified against auteurs_set() from editer_auteur()
+function nf_auteurs_set($id_auteur, $set1 = null, $set2 = null) {
+	require_once('inc/modifier.php');
+
+	$r = modifier_contenu('auteur', $id_auteur,
+	array(
+			'nonvide' => array('nom' => _T('ecrire:item_nouvel_auteur'))
+	),
+	$set1);
+
+	// .. mettre a jour les fichiers .htpasswd et .htpasswd-admin
+	if (isset($c['login'])
+	OR isset($c['pass'])
+	OR isset($c['statut'])
+	) {
+		include_spip('inc/acces');
+		ecrire_acces();
+	}
+
+	// .. mettre a jour les sessions de cet auteur
+	include_spip('inc/session');
+	$c['id_auteur'] = $id_auteur;
+	actualiser_sessions($c);
+
+	// Modification de statut, changement de rubrique ?
+	$err .= instituer_auteur($id_auteur, $set2);
+	return $err;
+}
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/ecrire/nf_spip_commons_api.php spip/ecrire/nf_spip_commons_api.php
--- spip-ori/ecrire/nf_spip_commons_api.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nf_spip_commons_api.php	2013-04-05 11:06:41.149923139 +0200
@@ -0,0 +1,67 @@
+<?php
+/**
+  NovaForge(tm)
+  Copyright (c) 2010-2011 Bull S.A.S.
+  
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published by 
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+  
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU Lesser General Public License for more details.
+  
+  You should have received a copy of the GNU Lesser General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+# return user_id if successful, otherwise "".
+function check_login( $p_username, $p_password ) {
+	//	$user_id = auth_identifier_login($p_username, $p_password,'');
+	if (!$auteur = auth_identifier_login($p_username, $p_password, '')){
+		return false;
+	}
+	return $auteur;
+}
+
+function has_administrator_access( $p_user_id ) {
+	$statut = sql_getfetsel("statut", "spip_auteurs", "login=" . sql_quote($p_user_id));
+	$webmestre = sql_getfetsel("webmestre", "spip_auteurs", "login=" . sql_quote($p_user_id));
+	if ( (_SPIP_0minirezo==$statut) && (_SPIP_WEBMESTRE_OUI==$webmestre)){
+		return true;
+	}
+	else {
+		return false;
+	}
+}
+
+function check_login_config_file( $p_username, $p_password ) {
+	//	$user_id = auth_identifier_login($p_username, $p_password,'');
+	if ( (_NF_LOGIN_ADMIN_SPIP == $p_username) && (_NF_PASS_ADMIN_SPIP == $p_password)){
+		return true;
+	}
+	return false;
+}
+
+function has_administrator_access_config_file( $p_user_id ) {
+	return true;
+}
+
+/**
+ * Return true if the parameter is an empty string or a string
+ * containing only whitespace, false otherwise
+ * @param string $p_var string to test
+ * @return bool
+ * @access public
+ */
+function is_blank( $p_var ) {
+	$p_var = trim( $p_var );
+	$str_len = strlen( $p_var );
+	if( 0 == $str_len ) {
+		return true;
+	}
+	return false;
+}
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/ecrire/nf_spipconnect.php spip/ecrire/nf_spipconnect.php
--- spip-ori/ecrire/nf_spipconnect.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nf_spipconnect.php	2013-04-05 11:06:41.149923139 +0200
@@ -0,0 +1,355 @@
+<?php
+/**
+  NovaForge(tm)
+  Copyright (c) 2010-2011 Bull S.A.S.
+  
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published by 
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+  
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU Lesser General Public License for more details.
+  
+  You should have received a copy of the GNU Lesser General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+// NuSOAP already performs compression,
+// so we prevent a double-compression.
+// See issue #11868 for details
+define( 'COMPRESSION_DISABLED', true);
+ini_set( 'zlib.output_compression', false );
+
+require_once( 'nusoap/nusoap.php' );
+
+# create server
+$l_oServer = new soap_server();
+
+# namespace
+$t_namespace = 'http://novaforge.bull.net';
+
+# wsdl generation
+$l_oServer->debug_flag = false;
+$l_oServer->configureWSDL( 'SpipConnect', $t_namespace );
+$l_oServer->wsdl->schemaTargetNamespace = $t_namespace;
+$l_oServer->xml_encoding = "UTF-8";
+$l_oServer->soap_defencoding = "UTF-8";
+$l_oServer->decode_utf8 = false;
+$l_oServer->style = 'document';
+
+//---------- registration of structure/objects
+### StringArray
+$l_oServer->wsdl->addComplexType(
+	'StringArray',
+	'complexType',
+	'array',
+	'',
+	'SOAP-ENC:Array',
+	array(),
+	array(array(
+		'ref'				=> 'SOAP-ENC:arrayType',
+		'wsdl:arrayType'	=> 'xsd:string[]'
+	)),
+	'xsd:string'
+);
+
+### UserData
+$l_oServer->wsdl->addComplexType(
+    'UserData',
+    'complexType',
+    'struct',
+    'all',
+    '',
+array(
+        'nom' => array('name' => 'nom', 'type' => 'xsd:string'),
+		'email' => array('name' => 'email', 'type' => 'xsd:string'),
+		'login' => array('name' => 'login', 'type' => 'xsd:string'),
+		'pass' => array('name' => 'pass', 'type' => 'xsd:string')  
+)
+);
+
+
+$l_oServer->wsdl->addComplexType(
+    'UserSite',
+    'complexType',
+    'struct',
+    'all',
+    '',
+array(
+        'url_site' => array('name' => 'url_site', 'type' => 'xsd:string'),
+		'nom_site' => array('name' => 'nom_site', 'type' => 'xsd:string')
+)
+);
+
+$l_oServer->wsdl->addComplexType(
+    'UserInfo',
+    'complexType',
+    'struct',
+    'all',
+    '',
+array(
+        'nom' => array('name' => 'nom', 'type' => 'xsd:string'),	
+		'id' => array('name' => 'id', 'type' => 'xsd:string'),
+		'login' => array('name' => 'login', 'type' => 'xsd:string'),
+		'email' => array('name' => 'email', 'type' => 'xsd:string'),
+		'webmestre' => array('name' => 'webmestre', 'type' => 'xsd:string'),
+		'statut' => array('name' => 'statut', 'type' => 'xsd:string'),
+		'nom_site' => array('name' => 'nom_site', 'type' => 'xsd:string'),
+		'url_site' => array('name' => 'url_site', 'type' => 'xsd:string')
+)
+);
+
+$l_oServer->wsdl->addComplexType(
+    'SiteInfo',
+    'complexType',
+    'struct',
+    'all',
+    '',
+array(
+        'url_site' => array('name' => 'url_site', 'type' => 'xsd:string'),
+		'nom_site' => array('name' => 'nom_site', 'type' => 'xsd:string'),
+		'email_webmaster' => array('name' => 'email_webmaster', 'type' => 'xsd:string'),
+		'descriptif_site' => array('name' => 'descriptif_site', 'type' => 'xsd:string')
+)
+);
+
+
+$l_oServer->wsdl->addComplexType(
+    'SiteInput',
+    'complexType',
+    'struct',
+    'all',
+    '',
+array(
+        'site_id' => array('name' => 'site_id', 'type' => 'xsd:string'),
+		'nom_site' => array('name' => 'nom_site', 'type' => 'xsd:string'),
+		'descriptif_site' => array('name' => 'descriptif_site', 'type' => 'xsd:string')
+)
+);
+
+
+//----------- registration of the methods ------------------------------------------
+
+//----- connect ---
+$l_oServer->register( 'connect',
+array(
+		'login'	=>	'xsd:string',
+		'password'	=>	'xsd:string'
+		),
+		array(
+		'return'	=>	'xsd:string'
+		),
+		$t_namespace,
+		false, false, false,
+	'Return the connected user or error message !'
+	);
+
+	//------- get roles used to be mapped with novaforge roles. -----
+	$l_oServer->register( 'get_roles',
+	array(),
+	array(
+		'return'	=>	'tns:StringArray'
+	),
+	$t_namespace,
+	false, false, false,
+	'get available roles for spip (statut,webmestre properties of spip_auteurs).'
+);
+	
+	//----- add user account ---
+	$l_oServer->register( 'add_user',
+	array('username' => 'xsd:string',
+		'password' => 'xsd:string',
+		'userData' => 'tns:UserData'),        
+	array(
+		'return'	=>	'xsd:integer'
+		),
+		$t_namespace,
+		false, false, false,
+	'Return the user id'
+	);
+
+
+	//----- get user infos -------
+	$l_oServer->register( 'get_user_info',
+	array('username' => 'xsd:string',
+		'password' => 'xsd:string',
+		'login' => 'xsd:string'),
+	array(
+		'return'	=>	'tns:UserInfo'
+		),
+		$t_namespace,
+		false, false, false,
+	'Return result message'
+	);
+
+	//----- get user id -------
+	$l_oServer->register( 'get_user_id',
+	array('username' => 'xsd:string',
+		'password' => 'xsd:string',
+		'login' => 'xsd:string'),
+	array(
+		'return'	=>	'xsd:integer'
+		),
+		$t_namespace,
+		false, false, false,
+	'Return the user id'
+	);
+
+	//----- update user ---
+	$l_oServer->register( 'update_user',
+	array('username' => 'xsd:string',
+		'password' => 'xsd:string',
+		'login'	=>	'xsd:string',
+			'userData' => 'tns:UserData'),
+	array(
+		'return'	=>	'xsd:boolean'
+		),
+		$t_namespace,
+		false, false, false,
+	'Return true if has been updated'
+	);
+
+	//----------- delete user ----------
+	$l_oServer->register( 'delete_user',
+	array('username' => 'xsd:string',
+		'password' => 'xsd:string',
+		'login' => 'xsd:string'),
+	array(
+		'return'	=>	'xsd:boolean'
+		),
+		$t_namespace,
+		false, false, false,
+	'Return true if has been deleted'
+	);
+	
+	//------- get statuts into spip --------
+	
+
+	//----- create spip site ---
+	$l_oServer->register( 'create_site',
+
+	array('username' => 'xsd:string',
+		'password' => 'xsd:string',
+		'siteInput' => 'tns:SiteInput'),
+	array(
+		'return'	=>	'xsd:string'
+		),
+		$t_namespace,
+		false, false, false,
+	'Return the created site'
+	);
+
+	//----- delete spip site ---
+	$l_oServer->register( 'delete_site',
+
+	array('username' => 'xsd:string',
+		'password' => 'xsd:string',
+		'siteId' => 'xsd:string'),
+	array(
+		'return'	=>	'xsd:boolean'
+		),
+		$t_namespace,
+		false, false, false,
+	'Return true if site been deleted'
+	);
+
+	//----- update spip site ---
+	$l_oServer->register( 'update_site',
+
+	array('username' => 'xsd:string',
+		'password' => 'xsd:string',
+		'siteInput' => 'tns:SiteInput'),
+	array(
+		'return'	=>	'xsd:boolean'
+		),
+		$t_namespace,
+		false, false, false,
+	'Return true if has been updated'
+	);
+
+
+	//----- get site infos-------
+	//--- not done into mantis
+	$l_oServer->register( 'get_site',
+	array('username' => 'xsd:string',
+		'password' => 'xsd:string',),
+	array(
+		'return'	=>	'tns:SiteInfo'
+		),
+		$t_namespace,
+		false, false, false,
+	'Return result message'
+	);
+
+	//----- add site for a user ---
+	$l_oServer->register( 'add_user_site',
+	array('username' => 'xsd:string',
+		'password' => 'xsd:string',	
+		'login' => 'xsd:string', 
+		'siteId' => 'xsd:string',
+		'role' => 'xsd:string' ),
+	array(
+		'return'	=>	'xsd:integer'
+		),
+		$t_namespace,
+		false, false, false,
+	'Return result message'
+	);
+
+	//--------------------------------------- other utilities functions ------------------------------
+	/**
+	* Checks if the request for the webservice is a documentation request (eg:
+	* WSDL) or an actual webservice call.
+	*
+	* The implementation of this method is based on soap_server::service().
+	*
+	* @param $p_service    The webservice class instance.
+	* @param $p_data       The input that is based on the post data.
+	*/
+	function mci_is_webservice_call( $p_service, $p_data )
+	{
+		global $QUERY_STRING;
+		global $_SERVER;
+
+		if ( isset( $_SERVER['QUERY_STRING'] ) ) {
+			$t_qs = $_SERVER['QUERY_STRING'];
+		} else if( isset( $GLOBALS['QUERY_STRING'] ) ) {
+			$t_qs = $GLOBALS['QUERY_STRING'];
+		} else if( isset( $QUERY_STRING ) && $QUERY_STRING != '' ) {
+			$t_qs = $QUERY_STRING;
+		}
+
+		if ( isset( $t_qs ) && preg_match( '/wsdl/', $t_qs ) ){
+			return false;
+		} else if ( $p_data == '' && $p_service->wsdl ) {
+			return false;
+		} else {
+			return true;
+		}
+	}
+	# pass incoming (posted) data
+	if ( isset( $HTTP_RAW_POST_DATA ) ) {
+		$t_input = $HTTP_RAW_POST_DATA;
+	} else {
+		$t_input = implode( "\r\n", file( 'php://input' ) );
+	}
+
+	# only include related files, if the current
+	# request is a webservice call (rather than webservice documentation request,
+	# eg: WSDL).
+	if ( mci_is_webservice_call( $l_oServer, $t_input ) ) {
+		require_once( 'nf_core.php' );
+	} else {
+		# if we have a documentation request, do some tidy up to prevent lame bot loops e.g. /mantisconnect.php/mc_enum_etas/mc_project_get_versions/
+		$parts = explode ( 'nf_core.php/', strtolower($_SERVER['SCRIPT_NAME'] ), 2 );
+		if (isset( $parts[1] ) && (strlen ( $parts[1] ) > 0 ) ) {
+			echo 'This is not a SOAP webservice request, for documentation, see ' .  $parts[0] . 'nf_spipconnect.php';
+			exit();
+		}
+	}
+	# Execute whatever is requested from the webservice.
+	$l_oServer->service( $t_input );
+	?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/ecrire/nf_spip_site_api_for_php_debug.php spip/ecrire/nf_spip_site_api_for_php_debug.php
--- spip-ori/ecrire/nf_spip_site_api_for_php_debug.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nf_spip_site_api_for_php_debug.php	2013-04-05 11:06:41.149923139 +0200
@@ -0,0 +1,681 @@
+<?php
+/**
+  NovaForge(tm)
+  Copyright (c) 2010-2011 Bull S.A.S.
+  
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published by 
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+  
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU Lesser General Public License for more details.
+  
+  You should have received a copy of the GNU Lesser General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/********
+ * 
+ *    this file is derived from nf_spip_site_api.php
+ *    modif:
+ *          - remove soap raising exception,
+ *          - adding the required php at begenning of the the file. with soap these requiring are not declared here ...
+ * 
+ * 
+ */
+$GLOBALS['novaforge_site_install']="novaforge_install";
+define('_ESPACE_PRIVE', true);
+require_once('inc_version.php');
+require_once('req/mysql.php');
+require_once('base/abstract_sql.php');
+
+require_once ('nf_config_inc.php');
+
+//php common dependencies for soap api
+require_once('nf_spip_commons_api.php');
+require_once('inc/auth.php');
+require_once('action/editer_auteur.php');
+
+
+//Not used function .....
+function get_site($username, $password){
+	require_once('inc/presentation.php');
+	require_once('inc/config.php');
+
+
+	$url_site = entites_html($GLOBALS['meta']["url_site"]);
+	$nom_site = entites_html($GLOBALS['meta']["nom_site"]);
+	$email_webmaster = entites_html($GLOBALS['meta']["email_webmaster"]);
+	$descriptif_site = entites_html($GLOBALS['meta']["descriptif_site"]);
+	error_log("url_site = " . $url_site . " nom_site = " . $nom_site . " email_webmaster = ". $email_webmaster . "descriptif_site = " . $descriptif_site);
+	$site_info=array("url_site" => $url_site, "nom_site" => $nom_site, "email_webmaster" => $email_webmaster, "descriptif_site" => $descriptif_site);
+	return $site_info;
+}
+
+//not used function ....
+function update_site($username, $password, $site_input){
+
+
+
+	//buid site name with tghe site_id (which is the sub domain)
+	$host_site = $site_input['site_id'] . "." ._SPIP_DOMAIN;
+
+	$site_nom=$site_input['nom_site'];
+	$site_description=$site_input['descriptif_site'];
+	$adresse_site="http://" . $host_site . "/spip";
+	ecrire_meta('nom_site', $site_nom);
+	ecrire_meta('descriptif_site', $site_description);
+	ecrire_meta('adresse_site', $adresse_site);
+	return true;
+}
+
+//in order to change the default statut set at user creation (5poubelle) to one of possible statut:"1comite" , "0minirezo".
+function add_user_site($username, $password, $login='', $siteId, $role ){
+	//	require_once 'action/editer_auteur.php';
+	//Note:
+	//  $siteId is not used when using initial spip function (here after).
+	//  Spip Mechanics is using  _DIR_CONNECT  (ex. ../sites/spip2.localhost/config/)
+	//  which is initialized into mes_options.php (depends on: $site = $_SERVER['HTTP_HOST'];)
+
+	$id_auteur = sql_getfetsel("id_auteur", "spip_auteurs", "login=" . sql_quote($login));
+
+	switch ($role){
+		case _NF_ADMINISTRATOR:
+			error_log("**************** case 1 ************************************");
+			$user_role = array(
+	'webmestre' => _SPIP_WEBMESTRE_NON,
+	'statut' => _SPIP_0minirezo);
+			break;
+		case _NF_WEBMASTER:
+			error_log("**************** case 2 ************************************");
+			$user_role = array(
+	'webmestre' => _SPIP_WEBMESTRE_OUI,
+	'statut' => _SPIP_0minirezo);
+			break;
+		case _NF_AUTHOR:
+			error_log("**************** case 3 ************************************");
+			$user_role = array(
+	'webmestre' => _SPIP_WEBMESTRE_NON,
+	'statut' => _SPIP_1comite);
+			break;
+		case _NF_VISITOR:
+			error_log("**************** case 4 ************************************");
+			$user_role = array(
+	'webmestre' => _SPIP_WEBMESTRE_NON,
+	'statut' => _SPIP_6forum);
+			break;
+	}
+
+	//pb. with this function to set webmestre to: oui (because of autorisation .....)
+	//$err = auteurs_set($id_auteur, $user_role);
+	sql_updateq('spip_auteurs', $user_role , 'id_auteur='.$id_auteur);
+	if ($err==''){
+		spip_log("userID = " . $id_auteur. " has been added to site with siteId = " . $siteId .  ", role = " .  $role . ", connect dir= " . _DIR_CONNECT);
+		return $id_auteur;
+	}
+	else {
+		error_log( 'Client', '', 'Add user to site error', 'Error when adding user= ' . $login . ' to site=' . $siteId );
+	}
+}
+
+function delete_site($username, $password, $siteId){
+	//TODO: refactor (?) the implementation. Currently, tables are dropped but database instance still exists. (Not a pb. to redo the creation).
+	// But the root dorectory for the config is not removed. Only config file. The root dir under sites needs to be removed manually.
+	
+
+	
+
+	$delete= array('spip_articles','spip_auteurs','spip_auteurs_articles','spip_auteurs_messages','spip_auteurs_rubriques','spip_breves','spip_documents','spip_documents_liens','spip_forum','spip_groupes_mots','spip_messages','spip_meta','spip_mots','spip_mots_articles','spip_mots_breves','spip_mots_documents','spip_mots_forum','spip_mots_rubriques','spip_mots_syndic','spip_petitions','spip_referers','spip_referers_articles','spip_resultats','spip_rubriques','spip_signatures','spip_syndic','spip_syndic_articles','spip_types_documents','spip_urls','spip_versions','spip_versions_fragments','spip_visites' ,'spip_visites_articles');
+
+	//call patched spip function that delete tables and configuration files.
+	//Note:
+	//  $siteId is not used when using initial spip function (here after).
+	//  Spip Mechanics is using  _DIR_CONNECT  (ex. ../sites/spip2.localhost/config/)
+	//  which is initialized into mes_options.php (depends on: $site = $_SERVER['HTTP_HOST'];)
+
+	nf_base_delete_all($delete, $siteId);
+	return true;
+}
+
+
+function create_site($username, $password, $site_input=array()){
+	//this variable setting forces variable: $serveur to 'mysql' into : abstract_sql.php
+	//Note: abstract_sql.php needs to be patched
+	$GLOBALS['novaforge_force_serveur']="novaforge_force_serveur";
+
+	require_once('inc/minipres.php');
+	require_once('inc/install.php');
+	require_once('inc/autoriser.php');
+
+	define('_ECRIRE_INSTALL', "1");
+	define('_FILE_TMP', '_install');
+
+	
+
+	$deja = (_FILE_CONNECT AND analyse_fichier_connection(_FILE_CONNECT));
+	if ($deja) {
+		// Rien a faire ici
+		error_log("ERROR lors de l'installation du site = " . $site_input[site_id] .". le fichier de connection: " . _FILE_CONNECT . "existe déjà");
+		error_log( "Client - Spip site creation error - The connextion file for the new site: already exists");
+	} else {
+		require_once('base/create.php');
+		utiliser_langue_visiteur();
+	}
+
+	//create repository structure for site installation (au lieu de etape_1)
+	require_once('install/etape_3.php');
+
+	//buid site name with the site_id (which is the sub domain)
+	$host_site = $site_input['site_id'] . "." ._SPIP_DOMAIN;
+
+	//call creation of configuration file function.
+	create_install_directories($host_site);
+
+	//create database  (etape_3)
+
+	//TODO
+	//utiliser _DIR_CONNECT= ../sites/spip2.localhost/config/
+	// pour récupérer le domaine (dans cet ex.: localhost).
+
+	// pour l'instant je suppose que le hostname = <sous domaine>.localhost
+	//A charge de configurer:
+	//  - dans apache:
+	//        ServerAlias *.localhost
+	//  - dans /etc/host:
+	//         spip2.localhost   avec sous domaine=spip2
+	//  Note:   C'est le sous domaine qui donne: siteId dans le plugin pour Spip.
+
+
+	$port_db=_NF_PORT_DB;
+	$login_db=_NF_LOGIN_DB;
+	$pass_db=_NF_PASS_DB;
+
+
+
+	//build the Db shema name
+	$sel_db=_NF_SAFRAN.$site_input['site_id'];
+
+	$adresse_db=$host_site.":".$port_db;
+	$server_db=_NF_SERVER_DB;
+	$choix_db=_NF_CHOIX_DB;
+	$chmod_db=_NF_CHMOD_DB;
+
+
+	//debug
+	//error_log("BEGIN create_base with: " . $adresse_db."- ". $login_db."- ". $pass_db. "- ". $server_db."- ". $choix_db. "- ".$sel_db."- ". $chmod_db);
+	create_base($adresse_db, $login_db, $pass_db,  $server_db, $choix_db, $sel_db, $chmod_db);
+	//webmaster infos (etape_3b)
+	//$login = $initialisation_data['login'];
+	$login = _NF_LOGIN_ADMIN_SPIP;
+	//$email = $initialisation_data['email'];
+	$email = _NF_EMAIL_ADMIN_SPIP;
+	//$nom = $initialisation_data['nom'];
+	$nom = _NF_NOM_ADMIN_SPIP;
+	//$pass = $initialisation_data['pass'];
+	$pass = _NF_PASS_ADMIN_SPIP;
+	//$pass_verif = $initialisation_data['pass_verif'];
+	$pass_verif = _NF_PASS_ADMIN_SPIP;
+
+	$site_nom=$site_input['nom_site'];
+	$site_description=$site_input['descriptif_site'];
+
+	base_initialisation($login,$email,$nom,$pass,$pass_verif,$server_db, $adresse_db, $login_db, $pass_db, $server_db, $sel_db, $choix_db, $sel_db, $site_nom, $site_description);
+
+	install_etape_4_dist();
+
+	include_spip('inc/headers');
+
+	//add this function to rename some files ....
+	//        and test it .....
+	require_once('install/etape_fin.php');
+	install_etape_fin_dist();
+
+	//patch novaforge: unset the used global variables.
+	unset($GLOBALS['novaforge_site_install']);
+	unset($GLOBALS['novaforge_force_serveur']);
+
+	//return the site_id which will map the project id of novaforge
+	return $host_site;
+}
+
+//***********************************************************************************************************
+//                                      utilities functions
+//***********************************************************************************************************
+
+function create_install_directories($site='') {
+	$chmod = 0755;
+	//to keep the initial path
+	$current_dir=getcwd();
+	@chdir("../sites");
+	$ok = @mkdir($site);
+	if (!$ok) {
+		error_log("ERROR creating the root directory " . $site . " under sites.");
+		exit;
+	}
+
+	@chmod($site, $chmod);
+	$ok= @chdir($site);
+	$dirs=array('IMG', 'tmp', 'local', 'config');
+	foreach ($dirs as &$my_dir) {
+		$ok= @mkdir($my_dir);
+		if ($ok) {
+			@chmod($my_dir, $chmod);
+		} else {
+			error_log("ERROR creating " .$my_dir . " directory under sites: " . $site );
+		
+			exit;
+		}
+
+	}
+	//to set back initial path
+	@chdir($current_dir);
+	return $ok;
+}
+
+
+//(etape3b)
+function base_initialisation($login='',$email='',$nom='',$pass='',$pass_verif='',$server_db='', $adresse_db='', $login_db='', $pass_db='', $server_db='', $sel_db='', $choix_db='', $sel_db='', $site_nom='', $site_description='')
+{
+	global $spip_version_base;
+	define('_ESPACE_PRIVE', true);
+
+	if($login) {
+		$echec = ($pass!=$pass_verif) ?
+		_T('info_passes_identiques')
+		: ((strlen($pass)<6) ?
+		_T('info_passe_trop_court')
+		: ((strlen($login)<3) ?
+		_T('info_login_trop_court')
+		: ''));
+		if ($echec) {
+			error_log('Incorrect login or password for the admin when initializing the database after instance creation.');
+			
+		}
+	}
+
+	if (@file_exists(_FILE_CHMOD_TMP)){
+		require_once (_FILE_CHMOD_TMP);
+	}
+	else{
+		error_log("_FILE_CHMOD_TMP = " . _FILE_CHMOD_TMP . "does not exist. Before launching again the site creation, remove created site directory and database instance." );
+		spip_log("_FILE_CHMOD_TMP = " . _FILE_CHMOD_TMP . "does not exist. " );
+		
+	}
+
+	if (!@file_exists(_FILE_CONNECT_TMP)){
+		spip_log("_FILE_CONNECT_TMP = " . _FILE_CONNECT_TMP . "does not exist. Before launching again the site creation, remove created site directory and database instance." );
+		error_log("_FILE_CONNECT_TMP = " . _FILE_CONNECT_TMP . "does not exist. Before launching again the site creation, remove created site directory and database instance." );
+	
+		//redirige_url_ecrire('install');
+	}
+
+	# maintenant on connait le vrai charset du site s'il est deja configure
+	# sinon par defaut lire_meta reglera _DEFAULT_CHARSET
+	# (les donnees arrivent de toute facon postees en _DEFAULT_CHARSET)
+
+	lire_metas();
+	if ($login) {
+		include_spip('inc/charsets');
+		//require_once('inc/charsets.php');
+
+		$nom = (importer_charset($nom, _DEFAULT_CHARSET));
+		$login = (importer_charset($login, _DEFAULT_CHARSET));
+		$email = (importer_charset($email, _DEFAULT_CHARSET));
+		# pour le passwd, bizarrement il faut le convertir comme s'il avait
+		# ete tape en iso-8859-1 ; car c'est en fait ce que voit md5.js
+		$pass = unicode2charset(utf_8_to_unicode($pass), 'iso-8859-1');
+		include_spip('auth/sha256.inc');
+		include_spip('inc/acces');
+		$htpass = generer_htpass($pass);
+		$alea_actuel = creer_uniqid();
+		$alea_futur = creer_uniqid();
+		$shapass = _nano_sha256($alea_actuel.$pass);
+		// prelablement, creer le champ webmestre si il n'existe pas (install neuve
+		// sur une vieille base
+		$t = sql_showtable("spip_auteurs", true);
+		if (!isset($t['field']['webmestre'])){
+			@sql_alter("TABLE spip_auteurs ADD webmestre varchar(3)  DEFAULT 'non' NOT NULL",'mysql');
+			//echo 'sql alter done';
+		}
+
+		$id_auteur = sql_getfetsel("id_auteur", "spip_auteurs", "login=" . sql_quote($login));
+
+		if ($id_auteur !== NULL) {
+			sql_updateq('spip_auteurs', array("nom"=> $nom, 'email'=> $email, 'login'=>$login, 'pass'=>$shapass, 'alea_actuel'=>$alea_actuel, 'alea_futur'=> $alea_futur, 'htpass'=>$htpass, 'statut'=>'0minirezo'), "id_auteur=$id_auteur");
+		}
+		else {
+			$id_auteur = sql_insertq('spip_auteurs', array(
+				'nom' => $nom,
+				'email' => $email,
+				'login' => $login,
+				'pass' => $shapass,
+				'htpass' => $htpass,
+				'alea_actuel' => $alea_actuel,
+				'alea_futur' => $alea_futur,
+				'statut' =>'0minirezo'),array());
+		}
+
+		//nf patch: check the user has been created
+		$id_auteur = sql_getfetsel("id_auteur", "spip_auteurs", "login=" . sql_quote($login));
+
+		if ($id_auteur == NULL) {
+			error_log("Error: adding admin user into database has failed. Installation is not OK.");
+			
+		}
+
+		// le passer webmestre separrement du reste, au cas ou l'alter n'aurait pas fonctionne
+		@sql_updateq('spip_auteurs', array('webmestre' => 'oui'), "id_auteur=$id_auteur");
+
+		// inserer email comme email webmaster principal
+		// (sauf s'il est vide: cas de la re-installation)
+		if ($email)
+		ecrire_meta('email_webmaster', $email);
+		// Connecter directement celui qui vient de (re)donner son login
+		// mais sans cookie d'admin ni connexion longue
+		include_spip('inc/auth');
+		//suppression de l'appel à la fonction auth_loger()    qui fait appel à une seesion; ce qui n'est pas notre cas ...
+		//		if (!$auteur = auth_identifier_login($login, $pass)
+		//OR !auth_loger($auteur, true))
+		if (!$auteur = auth_identifier_login($login, $pass, '')){
+			//do not generate an error because does not prevent to log manually
+			spip_log("************ login automatique impossible $auth_spip $session" . count($row));
+		}
+	}
+
+	// installer les metas
+	$config = charger_fonction('config', 'inc');
+	//call to inc_config_dist() function from config.php which calls: actualise_metas(liste_metas())
+	//liste_metas() defines the list of meta.
+	$config();
+
+	//patch novaforge: rajouter automatiquel le nom du site et sa description
+	ecrire_meta('nom_site', $site_nom);
+	ecrire_meta('descriptif_site', $site_description);
+
+	// activer les plugins
+	// leur installation ne peut pas se faire sur le meme hit, il faudra donc
+	// poursuivre au hit suivant
+	include_spip('inc/plugin');
+
+	//TODO: A revoir car plante .......
+	//actualise_plugins_actifs();
+
+}
+
+
+
+function etape2_initialisation($adresse_db='', $login_db='', $pass_db='',  $server_db='', $choix_db='', $sel_db='', $chmod_db=''){
+	$link = spip_connect_db($adresse_db, 0, $login_db, $pass_db, $name_db, $server_db);
+	$GLOBALS['connexions'][$server_db] = $link;
+
+	$GLOBALS['connexions'][$server_db][$GLOBALS['spip_sql_version']]
+	= $GLOBALS['spip_' . $server_db .'_functions_' . $GLOBALS['spip_sql_version']];
+
+
+	// prenons toutes les dispositions possibles pour que rien ne s'affiche !
+
+	/*
+	 * /!\ sqlite3/PDO : erreur sur join(', ', $link)
+	 * L'objet PDO ne peut pas etre transformee en chaine
+	 * Un echo $link ne fonctionne pas non plus
+	 * Il faut utiliser par exemple print_r($link)
+	 */
+	//echo "\n<!--\n", join(', ', $link), " $login_db ";
+	$db_connect = 0; // revoirfunction_exists($ferrno) ? $ferrno() : 0;
+	//echo join(', ', $GLOBALS['connexions'][$server_db]);
+	//echo "\n-->\n";	//call patched spip function that delete tables and configuration files.
+	//Note:
+	//  $siteId is not used when using initial spip function (here after).
+	//  Spip Mechanics is using  _DIR_CONNECT  (ex. ../sites/spip2.localhost/config/)
+	//  which is initialized
+
+	if (($db_connect=="0") && $link) {
+		spip_connect_db($adresse_db, 0, $login_db, $pass_db, '',$server_db);
+	}
+}
+
+
+function create_base($adresse_db='', $login_db='', $pass_db='',  $server_db='', $choix_db='', $sel_db='', $chmod_db=''){
+
+	//added to do same initialisation as into etape2
+	etape2_initialisation();
+
+	global $spip_version_base;
+
+	// Prefix des tables :
+	// contrairement a ce qui est dit dans le message (trop strict mais c'est
+	// pour notre bien), on va tolerer les chiffres en plus des minuscules
+	// S'il n'est pas defini par mes_options/inc/mutualiser, on va le creer
+	// a partir de ce qui est envoye a l'installation
+	if (!defined('_INSTALL_TABLE_PREFIX')) {
+		$table_prefix = ($GLOBALS['table_prefix'] != 'spip')
+		? $GLOBALS['table_prefix']
+		: trim(preg_replace(',[^a-z0-9],','',strtolower(_request('tprefix'))));
+		// S'il est vide on remet spip
+		if (!$table_prefix)
+		$table_prefix = 'spip';
+	} else {
+		$table_prefix = _INSTALL_TABLE_PREFIX;
+	}
+	//spip_connect_db($adresse_db, 0, $login_db, $pass_db, $name_db, $server_db);
+	$GLOBALS['connexions'][$server_db]
+	= spip_connect_db($adresse_db, 0, $login_db, $pass_db, '', $server_db);
+
+	$GLOBALS['connexions'][$server_db][$GLOBALS['spip_sql_version']]
+	= $GLOBALS['spip_' . $server_db .'_functions_' . $GLOBALS['spip_sql_version']];
+
+	$fquery = sql_serveur('query', $server_db);
+	if ($choix_db == "new_spip") {
+		$re = ',^[a-z_][a-z_0-9-]*$,i';
+		if (preg_match($re, $sel_db))
+		sql_create_base($sel_db, $server_db);
+		else {
+			$re = "Error: le nom de la base doit correspondre a $re";
+			spip_log($re);
+			error_log($re);
+			
+		}
+	}
+
+	// on rejoue la connexion apres avoir teste si il faut lui indiquer
+	// un sql_mode
+	install_mode_appel($server_db, false);
+
+
+	$GLOBALS['connexions'][$server_db]
+	= spip_connect_db($adresse_db, $sel_db, $login_db, $pass_db, $sel_db, $server_db);
+
+	$GLOBALS['connexions'][$server_db][$GLOBALS['spip_sql_version']]
+	= $GLOBALS['spip_' . $server_db .'_functions_' . $GLOBALS['spip_sql_version']];
+
+	// Completer le tableau decrivant la connexion
+
+	$GLOBALS['connexions'][$server_db]['prefixe'] = $table_prefix;
+	$GLOBALS['connexions'][$server_db]['db'] = $sel_db;
+
+	$old = sql_showbase($table_prefix  . "_meta", $server_db);
+	if ($old) $old = sql_fetch($old, $server_db);
+	if (!$old) {
+
+		// Si possible, demander au serveur d'envoyer les textes
+		// dans le codage std de SPIP,
+		$charset = sql_get_charset(_DEFAULT_CHARSET, $server_db);
+
+		if ($charset) {
+			sql_set_charset($charset['charset'], $server_db);
+			$GLOBALS['meta']['charset_sql_base'] =
+			$charset['charset'];
+			$GLOBALS['meta']['charset_collation_sql_base'] =
+			$charset['collation'];
+			$GLOBALS['meta']['charset_sql_connexion'] =
+			$charset['charset'];
+			$charsetbase = $charset['charset'];
+		} else {
+			spip_log(_DEFAULT_CHARSET . " inconnu du serveur SQL");
+			error_log(_DEFAULT_CHARSET . " inconnu du serveur SQL");
+			$charsetbase = 'standard';
+		}
+		spip_log("Creation des tables. Codage $charsetbase");
+		creer_base($server_db); // AT LAST
+		creer_base_types_doc($server_db);
+		// memoriser avec quel charset on l'a creee
+
+		if ($charset) {
+			$t = array('nom' => 'charset_sql_base',
+				   'valeur' => $charset['charset'],
+				   'impt' => 'non');
+			@sql_insertq('spip_meta', $t, '', $server_db);
+			$t['nom'] = 'charset_collation_sql_base';
+			$t['valeur'] = $charset['collation'];
+			@sql_insertq('spip_meta', $t, '', $server_db);
+			$t['nom'] = 'charset_sql_connexion';
+			$t['valeur'] = $charset['charset'];
+			@sql_insertq('spip_meta', $t, '', $server_db);
+		}
+		$t = array('nom' => 'version_installee',
+			   'valeur' => $spip_version_base,
+			   'impt' => 'non');
+		@sql_insertq('spip_meta', $t, '', $server_db);
+		$t['nom'] = 'nouvelle_install';
+		$t['valeur'] = 1;
+		@sql_insertq('spip_meta', $t, '', $server_db);
+		// positionner la langue par defaut du site si un cookie de lang a ete mis
+		if (isset($_COOKIE['spip_lang_ecrire'])){
+			@sql_insertq('spip_meta', array('nom'=>'langue_site','valeur'=>$_COOKIE['spip_lang_ecrire']), '', $server_db);
+		}
+	} else {
+
+		// pour recreer les tables disparues au besoin
+		spip_log("Table des Meta deja la. Verification des autres.");
+		creer_base($server_db);
+		$fupdateq = sql_serveur('updateq', $server_db);
+
+		$r = $fquery("SELECT valeur FROM spip_meta WHERE nom='version_installee'", $server_db);
+
+		if ($r) $r = sql_fetch($r, $server_db);
+		$version_installee = !$r ? 0 : (double) $r['valeur'];
+		if (!$version_installee OR ($spip_version_base < $version_installee)) {
+			$fupdateq('spip_meta', array('valeur'=>$spip_version_base, 'impt'=>'non'), "nom='version_installee'", $server_db);
+			spip_log("nouvelle version installee: $spip_version_base");
+		}
+		// eliminer la derniere operation d'admin mal terminee
+		// notamment la mise a jour
+		@$fquery("DELETE FROM spip_meta WHERE nom='import_all' OR  nom='admin'", $server_db);
+	}
+
+	$ligne_rappel = install_mode_appel($server_db);
+
+	$result_ok = @$fquery("SELECT COUNT(*) FROM spip_meta", $server_db);
+	if (!$result_ok) {
+		error_log("ERROR into create_base() function when checking query to spip_meta");
+	}
+
+	if ($chmod_db) {
+		install_fichier_connexion(_FILE_CHMOD_TMP, "if (!defined('_SPIP_CHMOD')) define('_SPIP_CHMOD', ". sprintf('0%3o',$chmod_db).");\n");
+	}
+
+	if (preg_match(',(.*):(.*),', $adresse_db, $r))
+	list(,$adresse_db, $port) = $r;
+	else $port = '';
+
+	// si ce fichier existe a cette etape c'est qu'il provient
+	// d'une installation qui ne l'a pas cree correctement.
+	// Le supprimer pour que _FILE_CONNECT_TMP prime.
+
+	if (_FILE_CONNECT AND file_exists(_FILE_CONNECT))
+	spip_unlink(_FILE_CONNECT);
+
+	install_fichier_connexion(_FILE_CONNECT_TMP,
+	$ligne_rappel
+	. install_connexion($adresse_db,
+	$port,
+	$login_db,
+	$pass_db,
+	$sel_db,
+	$server_db,
+	$table_prefix));
+	return '';
+}
+
+function install_etape_4_dist()
+{
+
+	// creer le repertoire cache, qui sert partout !
+	if(!@file_exists(_DIR_CACHE)) {
+		$rep = preg_replace(','._DIR_TMP.',', '', _DIR_CACHE);
+		$rep = sous_repertoire(_DIR_TMP, $rep, true,true);
+	}
+
+
+
+	// installer les extensions
+	include_spip('inc/plugin');
+	$afficher = charger_fonction("afficher_liste",'plugins');
+	//  patch nf: avoid to list into  the web service response
+	//	echo $afficher(self(), liste_plugin_files(_DIR_EXTENSIONS),array(), _DIR_EXTENSIONS,'afficher_nom_plugin');
+	installe_plugins();
+
+	// mettre a jour si necessaire l'adresse du site
+	// securite si on arrive plus a se loger
+	include_spip('inc/config');
+	//TODO:
+	$_POST['adresse_site'] = '';
+	appliquer_modifs_config();
+
+}
+
+// http://doc.spip.org/@base_delete_all_dist
+function nf_base_delete_all($delete, $site)
+{
+	$res = array();
+	if (is_array($delete)) {
+		foreach ($delete as $table) {
+			if (sql_drop_table($table))
+			$res[] = $table;
+			else {
+				spip_log("SPIP n'a pas pu detruire $table. pour le siteId = ". $site);
+				error_log("SPIP n'a pas pu detruire $table. pour le siteId = ". $site);
+			}
+		}
+
+		// un pipeline pour detruire les tables installees par les plugins
+		//		pipeline('delete_tables', '');
+	}
+	$d = count($delete);
+	$r = count($res);
+	spip_log("Tables detruites: $r sur $d: " . join(', ',$res));
+	if ($r != $d ){
+		error_log("Tables detruites: $r sur $d: " . join(', ',$res));
+	}
+
+	$current_dir=getcwd();
+	//go to: ../sites/spip2.localhost/
+	$host_site = $site . "." . _SPIP_DOMAIN;
+	@chdir("../sites");
+
+	spip_log($host_site);
+	if (is_dir($host_site)) {
+		$format="d-m-Y-g:i:s-a";
+		$today = date($format);
+		$r = @rename($host_site, $host_site . $today);
+		if ($r){
+			spip_log("The configuration directory: " . $host_site . " has been renamed. ");
+		}
+		else {
+			error_log("Pb. to rename the configuration directory: " . $host_site);
+		}
+	}
+	// go back to initial dir.
+	@chdir($current_dir);
+
+	//		spip_unlink(_FILE_CONNECT);
+	//		spip_unlink(_FILE_CHMOD);
+	//		spip_unlink(_FILE_META);
+	//		spip_unlink(_ACCESS_FILE_NAME);
+	//		spip_unlink(_CACHE_RUBRIQUES);
+
+}
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/ecrire/nf_spip_site_api.php spip/ecrire/nf_spip_site_api.php
--- spip-ori/ecrire/nf_spip_site_api.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nf_spip_site_api.php	2013-04-05 11:06:41.153923139 +0200
@@ -0,0 +1,683 @@
+<?php
+/**
+ NovaForge(tm)
+ Copyright (c) 2010-2011 Bull S.A.S.
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU Lesser General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+//Not used function .....
+function get_site($username, $password){
+	require_once('inc/presentation.php');
+	require_once('inc/config.php');
+
+	if (!$auteur = check_login_config_file($username, $password)){
+		return new soap_fault( 'Client', '', 'Access Denied', 'Username/password combination was incorrect');
+	}
+
+	if ( !has_administrator_access_config_file( $auteur.login ) ) {
+		return new soap_fault( 'Client', '', 'Access Denied', 'User does not have administrator access');
+	}
+
+	$url_site = entites_html($GLOBALS['meta']["url_site"]);
+	$nom_site = entites_html($GLOBALS['meta']["nom_site"]);
+	$email_webmaster = entites_html($GLOBALS['meta']["email_webmaster"]);
+	$descriptif_site = entites_html($GLOBALS['meta']["descriptif_site"]);
+	//	error_log("url_site = " . $url_site . " nom_site = " . $nom_site . " email_webmaster = ". $email_webmaster . "descriptif_site = " . $descriptif_site);
+	$site_info=array("url_site" => $url_site, "nom_site" => $nom_site, "email_webmaster" => $email_webmaster, "descriptif_site" => $descriptif_site);
+	return $site_info;
+}
+
+//not used function ....
+function update_site($username, $password, $site_input){
+	if (!$auteur = check_login_config_file($username, $password)){
+		return new soap_fault( 'Client', '', 'Access Denied', 'Username/password combination was incorrect');
+	}
+
+	if ( !has_administrator_access_config_file( $auteur.login ) ) {
+		return new soap_fault( 'Client', '', 'Access Denied', 'User does not have administrator access');
+	}
+
+	if ( is_blank($site_input['site_id']) ) {
+		return new soap_fault( 'Client', '', 'Spip site creation error', 'The site id is blank');
+	}
+	//buid site name with the site_id (which is the sub domain)
+	//	$host_site = $site_input['site_id'] . "." ._SPIP_DOMAIN;
+	$host_site = $_SERVER['HTTP_HOST'];
+
+	$site_nom=$site_input['nom_site'];
+	$site_description=$site_input['descriptif_site'];
+	$adresse_site="http://" . $host_site . "/spip";
+	ecrire_meta('nom_site', $site_nom);
+	ecrire_meta('descriptif_site', $site_description);
+	ecrire_meta('adresse_site', $adresse_site);
+	return true;
+}
+
+//in order to change the default statut set at user creation (5poubelle) to one of possible statut:"1comite" , "0minirezo".
+function add_user_site($username, $password, $login='', $siteId, $role ){
+	//	require_once 'action/editer_auteur.php';
+	//Note:
+	//  $siteId is not used when using initial spip function (here after).
+	//  Spip Mechanics is using  _DIR_CONNECT  (ex. ../sites/spip2.localhost/config/)
+	//  which is initialized into mes_options.php (depends on: $site = $_SERVER['HTTP_HOST'];)
+	if (!$auteur = check_login_config_file($username, $password)){
+		return new soap_fault( 'Client', '', 'Access Denied', 'Username/password combination was incorrect');
+	}
+
+	if ( !has_administrator_access_config_file( $auteur.login ) ) {
+		return new soap_fault( 'Client', '', 'Access Denied', 'User does not have administrator access');
+	}
+
+	$id_auteur = sql_getfetsel("id_auteur", "spip_auteurs", "login=" . sql_quote($login));
+
+	switch ($role){
+		case _NF_ADMINISTRATOR:
+			$user_role = array(
+	'webmestre' => _SPIP_WEBMESTRE_NON,
+	'statut' => _SPIP_0minirezo);
+			break;
+		case _NF_WEBMASTER:
+			$user_role = array(
+	'webmestre' => _SPIP_WEBMESTRE_OUI,
+	'statut' => _SPIP_0minirezo);
+			break;
+		case _NF_AUTHOR:
+			$user_role = array(
+	'webmestre' => _SPIP_WEBMESTRE_NON,
+	'statut' => _SPIP_1comite);
+			break;
+		case _NF_VISITOR:
+			$user_role = array(
+	'webmestre' => _SPIP_WEBMESTRE_NON,
+	'statut' => _SPIP_6forum);
+			break;
+	}
+
+	//pb. with this function to set webmestre to: oui (because of autorisation .....)
+	//$err = auteurs_set($id_auteur, $user_role);
+	sql_updateq('spip_auteurs', $user_role , 'id_auteur='.$id_auteur);
+	if ($err==''){
+		spip_log("userID = " . $id_auteur. " has been added to site with siteId = " . $siteId .  ", role = " .  $role . ", connect dir= " . _DIR_CONNECT);
+		return $id_auteur;
+	}
+	else {
+		return new soap_fault( 'Client', '', 'Add user to site error', 'Error when adding user= ' . $login . ' to site=' . $siteId );
+	}
+}
+
+function delete_site($username, $password, $siteId){
+	//TODO: refactor (?) the implementation. Currently, tables are dropped but database instance still exists. (Not a pb. to redo the creation).
+	// But the root dorectory for the config is not removed. Only config file. The root dir under sites needs to be removed manually.
+
+	if (!$auteur = check_login_config_file($username, $password)){
+		return new soap_fault( 'Client', '', 'Access Denied', 'Username/password combination was incorrect');
+	}
+
+	if ( !has_administrator_access_config_file( $auteur.login ) ) {
+		return new soap_fault( 'Client', '', 'Access Denied', 'User does not have administrator access');
+	}
+
+	if ( is_blank($siteId) ) {
+		return new soap_fault( 'Client', '', 'Spip site delete error', 'The site id is blank');
+	}
+
+	$delete= array('spip_articles','spip_auteurs','spip_auteurs_articles','spip_auteurs_messages','spip_auteurs_rubriques','spip_breves','spip_documents','spip_documents_liens','spip_forum','spip_groupes_mots','spip_messages','spip_meta','spip_mots','spip_mots_articles','spip_mots_breves','spip_mots_documents','spip_mots_forum','spip_mots_rubriques','spip_mots_syndic','spip_petitions','spip_referers','spip_referers_articles','spip_resultats','spip_rubriques','spip_signatures','spip_syndic','spip_syndic_articles','spip_types_documents','spip_urls','spip_versions','spip_versions_fragments','spip_visites' ,'spip_visites_articles');
+
+	//call patched spip function that delete tables and configuration files.
+	//Note:
+	//  $siteId is not used when using initial spip function (here after).
+	//  Spip Mechanics is using  _DIR_CONNECT  (ex. ../sites/projet1_spip2/config/)
+	//  which is initialized into mes_options.php
+
+	nf_base_delete_all($delete, $siteId);
+	return true;
+}
+
+
+function create_site($username, $password, $site_input=array()){
+	//this variable setting forces variable: $serveur to 'mysql' into : abstract_sql.php
+	//Note: abstract_sql.php needs to be patched
+	$GLOBALS['novaforge_force_serveur']="novaforge_force_serveur";
+
+	require_once('inc/minipres.php');
+	require_once('inc/install.php');
+	require_once('inc/autoriser.php');
+
+	define('_ECRIRE_INSTALL', "1");
+	define('_FILE_TMP', '_install');
+	if (!$auteur = check_login_config_file($username, $password)){
+		return new soap_fault( 'Client', '', 'Access Denied', 'Username/password combination does not match one into the configuration file: nf_config_inc.php');
+	}
+	if ( !has_administrator_access_config_file( $auteur.login ) ) {
+		return new soap_fault( 'Client', '', 'Access Denied', 'User does not have administrator access');
+	}
+
+	if ( is_blank($site_input['site_id']) ) {
+		return new soap_fault( 'Client', '', 'Spip site creation error', 'The site id is blank');
+	}
+	$deja = (_FILE_CONNECT AND analyse_fichier_connection(_FILE_CONNECT));
+	if ($deja) {
+		// Rien a faire ici
+		error_log("ERROR lors de l'installation du site = " . $site_input[site_id] .". le fichier de connection: " . _FILE_CONNECT . "existe déjà");
+		return new soap_fault( 'Client', '', 'Spip site creation error', 'The connextion file for the new site: already exists');
+	} else {
+		require_once('base/create.php');
+		utiliser_langue_visiteur();
+	}
+
+	//create repository structure for site installation (au lieu de etape_1)
+	require_once('install/etape_3.php');
+
+
+
+	//buid site name with the site_id (which is the sub domain)
+	//	$host_site = $site_input['site_id'] . "." ._SPIP_DOMAIN;
+	$host_site = $_SERVER['HTTP_HOST'];
+	preg_match(',/spip/([a-zA-Z0-9_-]+)/?,',$_SERVER['REQUEST_URI'],$r);
+	//	error_log("******* nf_spip_site_api.php ************ _SERVER['REQUEST_URI'] =". $_SERVER['REQUEST_URI']);
+	//	error_log("******* nf_spip_site_api.php ************ r[0] =". $r[0]);
+	//	error_log("******** nf_spip_site_api.php *********** r[1] =". $r[1]);
+	$site_name=$r[1];
+
+	//call creation of configuration file function.
+	create_install_directories($site_name);
+	//create database  (etape_3)
+	$port_db=_NF_PORT_DB;
+	$login_db=_NF_LOGIN_DB;
+	$pass_db=_NF_PASS_DB;
+
+
+
+	//build the Db shema name
+	$sel_db=_NF_SAFRAN.$site_input['site_id'];
+
+	$adresse_db=$host_site.":".$port_db;
+	$server_db=_NF_SERVER_DB;
+	$choix_db=_NF_CHOIX_DB;
+	$chmod_db=_NF_CHMOD_DB;
+
+
+	//debug
+	//error_log("BEGIN create_base with: " . $adresse_db."- ". $login_db."- ". $pass_db. "- ". $server_db."- ". $choix_db. "- ".$sel_db."- ". $chmod_db);
+	create_base($adresse_db, $login_db, $pass_db,  $server_db, $choix_db, $sel_db, $chmod_db);
+	//webmaster infos (etape_3b)
+	//$login = $initialisation_data['login'];
+	$login = _NF_LOGIN_ADMIN_SPIP;
+	//$email = $initialisation_data['email'];
+	$email = _NF_EMAIL_ADMIN_SPIP;
+	//$nom = $initialisation_data['nom'];
+	$nom = _NF_NOM_ADMIN_SPIP;
+	//$pass = $initialisation_data['pass'];
+	$pass = _NF_PASS_ADMIN_SPIP;
+	//$pass_verif = $initialisation_data['pass_verif'];
+	$pass_verif = _NF_PASS_ADMIN_SPIP;
+
+	$site_nom=$site_input['nom_site'];
+	$site_description=$site_input['descriptif_site'];
+
+	base_initialisation($login,$email,$nom,$pass,$pass_verif,$server_db, $adresse_db, $login_db, $pass_db, $server_db, $sel_db, $choix_db, $sel_db, $site_nom, $site_description);
+
+	install_etape_4_dist();
+
+	include_spip('inc/headers');
+
+	//add this function to rename some files ....
+	//        and test it .....
+	require_once('install/etape_fin.php');
+	install_etape_fin_dist();
+
+	//patch novaforge: unset the used global variables.
+	unset($GLOBALS['novaforge_site_install']);
+	unset($GLOBALS['novaforge_force_serveur']);
+
+	//return the site_id which will map the project id of novaforge
+	return $site_name;
+}
+
+//***********************************************************************************************************
+//                                      utilities functions
+//***********************************************************************************************************
+
+function create_install_directories($site='') {
+	$chmod = 0755;
+	//to keep the initial path
+	$current_dir=getcwd();
+	spip_log("create_install_directories current_dir: ".$current_dir);
+	@chdir("../sites");
+	$ok = @mkdir($site);
+	if (!$ok) {
+		error_log("ERROR creating the root directory " . $site . " under sites.");
+		return new soap_fault( 'Client', '', 'Spip site creation error', 'Error when creating the root directory: ' . $site . ' under sites.');
+		exit;
+	}
+
+	@chmod($site, $chmod);
+	$ok= @chdir($site);
+	$dirs=array('IMG', 'tmp', 'local', 'config');
+	foreach ($dirs as &$my_dir) {
+		$ok= @mkdir($my_dir);
+		if ($ok) {
+			@chmod($my_dir, $chmod);
+		} else {
+			error_log("ERROR creating " .$my_dir . " directory under sites: " . $site );
+			return new soap_fault( 'Client', '', 'Spip site creation error', 'Error when creating the directory: ' . $my_dir . ' under' . $site . '.');
+			exit;
+		}
+
+	}
+	//to set back initial path
+	@chdir($current_dir);
+	return $ok;
+}
+
+
+//(etape3b)
+function base_initialisation($login='',$email='',$nom='',$pass='',$pass_verif='',$server_db='', $adresse_db='', $login_db='', $pass_db='', $server_db='', $sel_db='', $choix_db='', $sel_db='', $site_nom='', $site_description='')
+{
+	global $spip_version_base;
+	define('_ESPACE_PRIVE', true);
+
+	if($login) {
+		$echec = ($pass!=$pass_verif) ?
+		_T('info_passes_identiques')
+		: ((strlen($pass)<6) ?
+		_T('info_passe_trop_court')
+		: ((strlen($login)<3) ?
+		_T('info_login_trop_court')
+		: ''));
+		if ($echec) {
+			error_log('Incorrect login or password for the admin when initializing the database after instance creation.');
+			return new soap_fault( 'Client', '', 'Spip site creation error', 'Incorrect login or password for the admin when initializing the database after instance creation.') ;
+		}
+	}
+
+	if (@file_exists(_FILE_CHMOD_TMP)){
+		require_once (_FILE_CHMOD_TMP);
+	}
+	else{
+		error_log("_FILE_CHMOD_TMP = " . _FILE_CHMOD_TMP . "does not exist. Before launching again the site creation, remove created site directory and database instance." );
+		spip_log("_FILE_CHMOD_TMP = " . _FILE_CHMOD_TMP . "does not exist. " );
+		return new soap_fault( 'Client', '', 'Spip site creation error', '_FILE_CHMOD_TMP = ' . _FILE_CHMOD_TMP . ' does not exist.' );
+	}
+
+	if (!@file_exists(_FILE_CONNECT_TMP)){
+		spip_log("_FILE_CONNECT_TMP = " . _FILE_CONNECT_TMP . "does not exist. Before launching again the site creation, remove created site directory and database instance." );
+		error_log("_FILE_CONNECT_TMP = " . _FILE_CONNECT_TMP . "does not exist. Before launching again the site creation, remove created site directory and database instance." );
+		return new soap_fault( 'Client', '', 'Spip site creation error', '_FILE_CONNECT_TMP = ' . _FILE_CONNECT_TMP . ' does not exist.' );
+		//redirige_url_ecrire('install');
+	}
+
+	# maintenant on connait le vrai charset du site s'il est deja configure
+	# sinon par defaut lire_meta reglera _DEFAULT_CHARSET
+	# (les donnees arrivent de toute facon postees en _DEFAULT_CHARSET)
+
+	lire_metas();
+	if ($login) {
+		include_spip('inc/charsets');
+		//require_once('inc/charsets.php');
+
+		$nom = (importer_charset($nom, _DEFAULT_CHARSET));
+		$login = (importer_charset($login, _DEFAULT_CHARSET));
+		$email = (importer_charset($email, _DEFAULT_CHARSET));
+		# pour le passwd, bizarrement il faut le convertir comme s'il avait
+		# ete tape en iso-8859-1 ; car c'est en fait ce que voit md5.js
+		$pass = unicode2charset(utf_8_to_unicode($pass), 'iso-8859-1');
+		include_spip('auth/sha256.inc');
+		include_spip('inc/acces');
+		$htpass = generer_htpass($pass);
+		$alea_actuel = creer_uniqid();
+		$alea_futur = creer_uniqid();
+		$shapass = _nano_sha256($alea_actuel.$pass);
+		// prelablement, creer le champ webmestre si il n'existe pas (install neuve
+		// sur une vieille base
+		$t = sql_showtable("spip_auteurs", true);
+		if (!isset($t['field']['webmestre'])){
+			@sql_alter("TABLE spip_auteurs ADD webmestre varchar(3)  DEFAULT 'non' NOT NULL",'mysql');
+			//echo 'sql alter done';
+		}
+
+		$id_auteur = sql_getfetsel("id_auteur", "spip_auteurs", "login=" . sql_quote($login));
+
+		if ($id_auteur !== NULL) {
+			sql_updateq('spip_auteurs', array("nom"=> $nom, 'email'=> $email, 'login'=>$login, 'pass'=>$shapass, 'alea_actuel'=>$alea_actuel, 'alea_futur'=> $alea_futur, 'htpass'=>$htpass, 'statut'=>'0minirezo'), "id_auteur=$id_auteur");
+		}
+		else {
+			$id_auteur = sql_insertq('spip_auteurs', array(
+				'nom' => $nom,
+				'email' => $email,
+				'login' => $login,
+				'pass' => $shapass,
+				'htpass' => $htpass,
+				'alea_actuel' => $alea_actuel,
+				'alea_futur' => $alea_futur,
+				'statut' =>'0minirezo'),array());
+		}
+
+		//nf patch: check the user has been created
+		$id_auteur = sql_getfetsel("id_auteur", "spip_auteurs", "login=" . sql_quote($login));
+
+		if ($id_auteur == NULL) {
+			error_log("Error: adding admin user into database has failed. Installation is not OK.");
+			return new soap_fault( 'Client', '', 'Spip site creation error', 'Adding admin user into database has failed. Installation is not OK.' );
+		}
+
+		// le passer webmestre separrement du reste, au cas ou l'alter n'aurait pas fonctionne
+		@sql_updateq('spip_auteurs', array('webmestre' => 'oui'), "id_auteur=$id_auteur");
+
+		// inserer email comme email webmaster principal
+		// (sauf s'il est vide: cas de la re-installation)
+		if ($email)
+		ecrire_meta('email_webmaster', $email);
+		// Connecter directement celui qui vient de (re)donner son login
+		// mais sans cookie d'admin ni connexion longue
+
+		include_spip('inc/auth');
+		if (!$auteur = auth_identifier_login($login, $pass, '')){
+			//do not generate an error because does not prevent to log manually
+			error_log("Error: login automatique impossible with login = " . $login . "during site creation");
+		}
+
+	}
+
+	// installer les metas
+	$config = charger_fonction('config', 'inc');
+	//call to inc_config_dist() function from config.php which calls: actualise_metas(liste_metas())
+	//liste_metas() defines the list of meta.
+	$config();
+
+	//patch novaforge: rajouter automatiquel le nom du site et sa description
+	ecrire_meta('nom_site', $site_nom);
+	ecrire_meta('descriptif_site', $site_description);
+
+	// activer les plugins
+	// leur installation ne peut pas se faire sur le meme hit, il faudra donc
+	// poursuivre au hit suivant
+	include_spip('inc/plugin');
+
+	//TODO: A revoir car plante .......
+	//actualise_plugins_actifs();
+
+}
+
+
+
+function etape2_initialisation($adresse_db='', $login_db='', $pass_db='',  $server_db='', $choix_db='', $sel_db='', $chmod_db=''){
+	$link = spip_connect_db($adresse_db, 0, $login_db, $pass_db, $name_db, $server_db);
+	$GLOBALS['connexions'][$server_db] = $link;
+
+	$GLOBALS['connexions'][$server_db][$GLOBALS['spip_sql_version']]
+	= $GLOBALS['spip_' . $server_db .'_functions_' . $GLOBALS['spip_sql_version']];
+
+
+	// prenons toutes les dispositions possibles pour que rien ne s'affiche !
+
+	/*
+	 * /!\ sqlite3/PDO : erreur sur join(', ', $link)
+	 * L'objet PDO ne peut pas etre transformee en chaine
+	 * Un echo $link ne fonctionne pas non plus
+	 * Il faut utiliser par exemple print_r($link)
+	 */
+	//echo "\n<!--\n", join(', ', $link), " $login_db ";
+	$db_connect = 0; // revoirfunction_exists($ferrno) ? $ferrno() : 0;
+	//echo join(', ', $GLOBALS['connexions'][$server_db]);
+	//echo "\n-->\n";	//call patched spip function that delete tables and configuration files.
+	//Note:
+	//  $siteId is not used when using initial spip function (here after).
+	//  Spip Mechanics is using  _DIR_CONNECT  (ex. ../sites/spip2.localhost/config/)
+	//  which is initialized
+
+	if (($db_connect=="0") && $link) {
+		spip_connect_db($adresse_db, 0, $login_db, $pass_db, '',$server_db);
+	}
+}
+
+
+function create_base($adresse_db='', $login_db='', $pass_db='',  $server_db='', $choix_db='', $sel_db='', $chmod_db=''){
+	//added to do same initialisation as into etape2
+	etape2_initialisation();
+
+	global $spip_version_base;
+
+	// Prefix des tables :
+	// contrairement a ce qui est dit dans le message (trop strict mais c'est
+	// pour notre bien), on va tolerer les chiffres en plus des minuscules
+	// S'il n'est pas defini par mes_options/inc/mutualiser, on va le creer
+	// a partir de ce qui est envoye a l'installation
+	if (!defined('_INSTALL_TABLE_PREFIX')) {
+		$table_prefix = ($GLOBALS['table_prefix'] != 'spip')
+		? $GLOBALS['table_prefix']
+		: trim(preg_replace(',[^a-z0-9],','',strtolower(_request('tprefix'))));
+		// S'il est vide on remet spip
+		if (!$table_prefix)
+		$table_prefix = 'spip';
+	} else {
+		$table_prefix = _INSTALL_TABLE_PREFIX;
+	}
+	//spip_connect_db($adresse_db, 0, $login_db, $pass_db, $name_db, $server_db);
+	$GLOBALS['connexions'][$server_db]
+	= spip_connect_db($adresse_db, 0, $login_db, $pass_db, '', $server_db);
+
+	$GLOBALS['connexions'][$server_db][$GLOBALS['spip_sql_version']]
+	= $GLOBALS['spip_' . $server_db .'_functions_' . $GLOBALS['spip_sql_version']];
+
+	$fquery = sql_serveur('query', $server_db);
+	if ($choix_db == "new_spip") {
+		$re = ',^[a-z_][a-z_0-9-]*$,i';
+		if (preg_match($re, $sel_db))
+		sql_create_base($sel_db, $server_db);
+		else {
+			$re = "Error: le nom de la base doit correspondre a $re";
+			spip_log($re);
+			error_log($re);
+			return new soap_fault( 'Client', '', 'Spip site creation error', 'Error: le nom de la base doit correspondre a: ' . $re);
+		}
+	}
+
+	// on rejoue la connexion apres avoir teste si il faut lui indiquer
+	// un sql_mode
+	install_mode_appel($server_db, false);
+
+
+	$GLOBALS['connexions'][$server_db]
+	= spip_connect_db($adresse_db, $sel_db, $login_db, $pass_db, $sel_db, $server_db);
+
+	$GLOBALS['connexions'][$server_db][$GLOBALS['spip_sql_version']]
+	= $GLOBALS['spip_' . $server_db .'_functions_' . $GLOBALS['spip_sql_version']];
+
+	// Completer le tableau decrivant la connexion
+
+	$GLOBALS['connexions'][$server_db]['prefixe'] = $table_prefix;
+	$GLOBALS['connexions'][$server_db]['db'] = $sel_db;
+
+	$old = sql_showbase($table_prefix  . "_meta", $server_db);
+	if ($old) $old = sql_fetch($old, $server_db);
+	if (!$old) {
+
+		// Si possible, demander au serveur d'envoyer les textes
+		// dans le codage std de SPIP,
+		$charset = sql_get_charset(_DEFAULT_CHARSET, $server_db);
+
+		if ($charset) {
+			sql_set_charset($charset['charset'], $server_db);
+			$GLOBALS['meta']['charset_sql_base'] =
+			$charset['charset'];
+			$GLOBALS['meta']['charset_collation_sql_base'] =
+			$charset['collation'];
+			$GLOBALS['meta']['charset_sql_connexion'] =
+			$charset['charset'];
+			$charsetbase = $charset['charset'];
+		} else {
+			spip_log(_DEFAULT_CHARSET . " inconnu du serveur SQL");
+			error_log(_DEFAULT_CHARSET . " inconnu du serveur SQL");
+			$charsetbase = 'standard';
+		}
+		spip_log("Creation des tables. Codage $charsetbase");
+		creer_base($server_db); // AT LAST
+		creer_base_types_doc($server_db);
+		// memoriser avec quel charset on l'a creee
+
+		if ($charset) {
+			$t = array('nom' => 'charset_sql_base',
+				   'valeur' => $charset['charset'],
+				   'impt' => 'non');
+			@sql_insertq('spip_meta', $t, '', $server_db);
+			$t['nom'] = 'charset_collation_sql_base';
+			$t['valeur'] = $charset['collation'];
+			@sql_insertq('spip_meta', $t, '', $server_db);
+			$t['nom'] = 'charset_sql_connexion';
+			$t['valeur'] = $charset['charset'];
+			@sql_insertq('spip_meta', $t, '', $server_db);
+		}
+		$t = array('nom' => 'version_installee',
+			   'valeur' => $spip_version_base,
+			   'impt' => 'non');
+		@sql_insertq('spip_meta', $t, '', $server_db);
+		$t['nom'] = 'nouvelle_install';
+		$t['valeur'] = 1;
+		@sql_insertq('spip_meta', $t, '', $server_db);
+		// positionner la langue par defaut du site si un cookie de lang a ete mis
+		if (isset($_COOKIE['spip_lang_ecrire'])){
+			@sql_insertq('spip_meta', array('nom'=>'langue_site','valeur'=>$_COOKIE['spip_lang_ecrire']), '', $server_db);
+		}
+	} else {
+
+		// pour recreer les tables disparues au besoin
+		spip_log("Table des Meta deja la. Verification des autres.");
+		creer_base($server_db);
+		$fupdateq = sql_serveur('updateq', $server_db);
+
+		$r = $fquery("SELECT valeur FROM spip_meta WHERE nom='version_installee'", $server_db);
+
+		if ($r) $r = sql_fetch($r, $server_db);
+		$version_installee = !$r ? 0 : (double) $r['valeur'];
+		if (!$version_installee OR ($spip_version_base < $version_installee)) {
+			$fupdateq('spip_meta', array('valeur'=>$spip_version_base, 'impt'=>'non'), "nom='version_installee'", $server_db);
+			spip_log("nouvelle version installee: $spip_version_base");
+		}
+		// eliminer la derniere operation d'admin mal terminee
+		// notamment la mise a jour
+		@$fquery("DELETE FROM spip_meta WHERE nom='import_all' OR  nom='admin'", $server_db);
+	}
+
+	$ligne_rappel = install_mode_appel($server_db);
+
+	$result_ok = @$fquery("SELECT COUNT(*) FROM spip_meta", $server_db);
+	if (!$result_ok) {
+		error_log("ERROR into create_base() function when checking query to spip_meta");
+	}
+	error_log("*****createbase _FILE_CHMOD_TMP:"._FILE_CHMOD_TMP);
+	if ($chmod_db) {
+		install_fichier_connexion(_FILE_CHMOD_TMP, "if (!defined('_SPIP_CHMOD')) define('_SPIP_CHMOD', ". sprintf('0%3o',$chmod_db).");\n");
+	}
+
+	if (preg_match(',(.*):(.*),', $adresse_db, $r))
+	list(,$adresse_db, $port) = $r;
+	else $port = '';
+
+	// si ce fichier existe a cette etape c'est qu'il provient
+	// d'une installation qui ne l'a pas cree correctement.
+	// Le supprimer pour que _FILE_CONNECT_TMP prime.
+
+	if (_FILE_CONNECT AND file_exists(_FILE_CONNECT))
+	spip_unlink(_FILE_CONNECT);
+
+	install_fichier_connexion(_FILE_CONNECT_TMP,
+	$ligne_rappel
+	. install_connexion($adresse_db,
+	$port,
+	$login_db,
+	$pass_db,
+	$sel_db,
+	$server_db,
+	$table_prefix));
+	return '';
+}
+
+function install_etape_4_dist()
+{
+
+	// creer le repertoire cache, qui sert partout !
+	if(!@file_exists(_DIR_CACHE)) {
+		$rep = preg_replace(','._DIR_TMP.',', '', _DIR_CACHE);
+		$rep = sous_repertoire(_DIR_TMP, $rep, true,true);
+	}
+
+
+
+	// installer les extensions
+	include_spip('inc/plugin');
+	$afficher = charger_fonction("afficher_liste",'plugins');
+	//  patch nf: avoid to list into  the web service response
+	//	echo $afficher(self(), liste_plugin_files(_DIR_EXTENSIONS),array(), _DIR_EXTENSIONS,'afficher_nom_plugin');
+	installe_plugins();
+
+	// mettre a jour si necessaire l'adresse du site
+	// securite si on arrive plus a se loger
+	include_spip('inc/config');
+	//TODO:
+	$_POST['adresse_site'] = '';
+	appliquer_modifs_config();
+
+}
+
+// http://doc.spip.org/@base_delete_all_dist
+function nf_base_delete_all($delete, $site_id)
+{
+	$res = array();
+	if (is_array($delete)) {
+		foreach ($delete as $table) {
+			if (sql_drop_table($table))
+			$res[] = $table;
+			else {
+				spip_log("SPIP n'a pas pu detruire $table. pour le siteId = ". $site);
+				error_log("SPIP n'a pas pu detruire $table. pour le siteId = ". $site);
+			}
+		}
+
+		// un pipeline pour detruire les tables installees par les plugins
+		//		pipeline('delete_tables', '');
+	}
+	$d = count($delete);
+	$r = count($res);
+	spip_log("Tables detruites: $r sur $d: " . join(', ',$res));
+	if ($r != $d ){
+		error_log("Tables detruites: $r sur $d: " . join(', ',$res));
+	}
+
+	// saving the current working directory for configuration, cache, tmp, ....
+	$current_dir=getcwd();
+	@chdir("../sites");
+	if (is_dir($site_id)) {
+		$format="d-m-Y-g:i:s-a";
+		$today = date($format);
+		$r = @rename($site_id, $site_id . "_" . $today);
+		if ($r){
+			spip_log("The configuration directory: " . $site_id . " has been renamed. ");
+		}
+		else {
+			error_log("Pb. to rename the configuration directory: " . $site_id);
+		}
+	}
+	// go back to initial dir.
+	@chdir($current_dir);
+
+	//		spip_unlink(_FILE_CONNECT);
+	//		spip_unlink(_FILE_CHMOD);
+	//		spip_unlink(_FILE_META);
+	//		spip_unlink(_ACCESS_FILE_NAME);
+	//		spip_unlink(_CACHE_RUBRIQUES);
+
+}
+?>
diff -rNU5 spip-ori/ecrire/nf_test_client_php.php spip/ecrire/nf_test_client_php.php
--- spip-ori/ecrire/nf_test_client_php.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nf_test_client_php.php	2013-04-05 11:06:41.153923139 +0200
@@ -0,0 +1,76 @@
+<div id="form_container">
+
+<h1><a>Untitled Form</a></h1>
+<form id="form_258914" class="appnitro" method="post" action="">
+<div class="form_description">
+<h2>Untitled Form</h2>
+<p>This is your form description. Click here to edit.</p>
+</div>
+<ul>
+
+	<li id="li_1"><label class="description" for="element_1">Text </label>
+	<div><input id="element_1" name="element_1" class="element text medium"
+		type="text" maxlength="255" value="" /></div>
+	</li>
+
+	<li class="buttons"><input type="hidden" name="form_id" value="258914" />
+
+	<input id="saveForm" class="button_text" type="submit" name="submit"
+		value="Submit" /></li>
+</ul>
+</form>
+<div id="footer">Generated by <a href="http://www.phpform.org">pForm</a>
+</div>
+</div>
+<?php
+if (isset($_POST['form_id']))
+{
+
+	require_once('nf_spip_site_api_for_php_debug.php');
+
+
+	// TODO:  WARNING !!!! this php has been used to be able to debug php.
+	//        need to be updated ......
+
+	//----------------------------------- create site structures ------------------------------------------------------
+	//data for base creation
+
+
+	//----------------------------------------- test add user -----------------------------------------------
+	$nom = "pseudo_test1";
+	$email="pp@rr";
+	$login="login123";
+	$pass="login123";
+
+	$user = array(
+	'nom' => $nom,
+	'email' => $email, 
+	'login' => $login, 
+	'pass' => $pass);
+
+	//----------------------------- test connect -------------------------------------------------
+	function connect($login, $password)
+	{
+		$auteur = nf_auth_identifier_login($login, $password);
+		return $auteur;
+	}
+	//$auteur= connect('administrator', 'root123');
+
+	//------------------------------------- test create site -----------------------------------------
+
+	$site_id = 'spip2';
+	$nom_site = 'mon site';
+	$descriptif_site = 'my desc';
+
+	$site_input=array(
+	'site_id' => $site_id,
+	'nom_site' => $nom_site,
+	'descriptif_site' => $descriptif_site);
+
+	$username= "administrator";
+	$password= "root123";
+
+
+	create_site($username, $password, $site_input);
+}
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/ecrire/nf_test_client_soap.php spip/ecrire/nf_test_client_soap.php
--- spip-ori/ecrire/nf_test_client_soap.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nf_test_client_soap.php	2013-04-05 11:06:41.153923139 +0200
@@ -0,0 +1,369 @@
+<?php
+/**
+  NovaForge(tm)
+  Copyright (c) 2010-2011 Bull S.A.S.
+  
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published by 
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+  
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU Lesser General Public License for more details.
+  
+  You should have received a copy of the GNU Lesser General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+/*
+ * 
+ * 
+ * This file has been introduced to test the soap service by creating a soap client (with bnusoap)
+ * it avoids to use soapUI then avoid to fill-in parameter for the soap services.
+ * Note:  need to have soap_spip.wsdl published at the root docuiment of the default apache server.
+ * 
+ */
+require_once('nusoap/nusoap.php');
+set_time_limit(0);
+ini_set("soap.wsdl_cache_enabled", "0");
+
+//-------------------------------- launching soap tests --------------------------------------------
+//$ret=hello();
+//soap_create_site();
+//soap_delete_site();
+//soap_update_site();
+soap_add_user();
+//soap_add_user_site();
+//soap_delete_user();
+//soap_update_user();   //does not run with soap client but OK with soap UI.
+//soap_get_user_id();
+//--------------------------------------------------------------------------------------------------
+
+function hello(){
+	$clientSOAP = new nusoap_client('http://@HOSTSPIP/soap_spip.wsdl',true);
+	$clientSOAP->setUseCurl(false);
+	$result = $clientSOAP->call('hello', array('arg0' => 'hello toto') );
+	// Check for a fault
+	if ($clientSOAP->fault) {
+		error_log( "fault :'" . $result['faultstring'] ."'");
+		return false;
+	} else {
+		// Check for errors
+		$err = $clientSOAP->getError();
+		if ($err) {
+			// Display the error
+			error_log( "err :'" . $err ."'");
+			return false;
+		}
+	}
+	return $result['return'];
+}
+
+function soap_create_site(){
+	ini_set("soap.wsdl_cache_enabled", "0");
+	$clientSOAP = new nusoap_client('http://@HOSTSPIP/soap_spip.wsdl',true);
+	$clientSOAP->setUseCurl(false);
+
+	$username = "toto";
+	$password = "hjhjhj";
+
+	//data for base creation
+	$site_id="spip2";
+	$nom_site = "site marc";
+	$descriptif_site = "site description";
+	$site_input = array(
+	'site_id' => $site_id,
+	'nom_site' => $nom_site,
+	'descriptif_site' => $descriptif_site);
+
+	//$result = $clientSOAP->call('create_site', array('username' => $username, 'password'=> $password, 'createBaseData' => $create_base_data,'initBaseData' => $init_base_data) );
+	$result = $clientSOAP->call('create_site', array('username' => $username, 'password'=> $password, 'siteInput' => $site_input) );
+	// Check for a fault
+	if ($clientSOAP->fault) {
+		error_log( "fault :'" . $result['faultstring'] ."'");
+		return false;
+	} else {
+		// Check for errors
+		$err = $clientSOAP->getError();
+		if ($err) {
+			// Display the error
+			error_log( "err :'" . $err ."'");
+			return false;
+		}
+	}
+	return $result['return'];
+}
+
+function soap_update_site(){
+	$clientSOAP = new nusoap_client('http://@HOSTSPIP/soap_spip.wsdl',true);
+	$clientSOAP->setUseCurl(false);
+
+	$username = "toto";
+	$password = "hjhjhj";
+
+	$site_id="spip2";
+	$nom_site = "site marcI";
+	$descriptif_site = "site descriptionO";
+	$site_input = array(
+	'site_id' => $site_id,
+	'nom_site' => $nom_site,
+	'descriptif_site' => $descriptif_site);
+
+	$result = $clientSOAP->call('update_site', array('username' => $username, 'password'=> $password, 'siteInput' => $site_input) );
+	// Check for a fault
+	if ($clientSOAP->fault) {
+		error_log( "fault :'" . $result['faultstring'] ."'");
+		return false;
+	} else {
+		// Check for errors
+		$err = $clientSOAP->getError();
+		if ($err) {
+			// Display the error
+			error_log( "err :==> '" . $err ."'");
+			error_log ( '<p><b>Error: ' . $err . '</b></p>');
+			error_log ( '<p><b>Request: <br>');
+			error_log ( htmlspecialchars($client->request, ENT_QUOTES) . '</b></p>');
+			error_log ( '<p><b>Response: <br>');
+			error_log ( htmlspecialchars($client->response, ENT_QUOTES) . '</b></p>');
+			error_log ( '<p><b>Debug: <br>');
+			error_log (  htmlspecialchars($client->debug_str, ENT_QUOTES) . '</b>');
+			return false;
+		}
+	}
+	return $result['return'];
+}
+
+function soap_delete_site(){
+	//$clientSOAP = new nusoap_client('http://@HOSTSPIP/soap_spip.wsdl',true);
+	$clientSOAP = new nusoap_client('http://@HOSTSPIP/soap_spip.wsdl',true);
+	$clientSOAP->setUseCurl(false);
+	$username = "toto";
+	$password = "hjhjhj";
+
+	$siteId="spip2";
+
+	$result = $clientSOAP->call('delete_site', array('username' => $username, 'password'=> $password, 'siteId'=>$siteId) );
+	// Check for a fault
+	if ($clientSOAP->fault) {
+		error_log( "fault :'" . $result['faultstring'] ."'");
+		return false;
+	} else {
+		// Check for errors
+		$err = $clientSOAP->getError();
+		if ($err) {
+			// Display the error
+			error_log( "err :'" . $err ."'");
+			return false;
+		}
+	}
+	return $result['return'];
+}
+
+function soap_add_user(){
+	$username = "toto";
+	$password = "hjhjhj";
+
+	$nom = "pseudo_test1";
+	$email="pp@rr";
+	$login="login123";
+	$pass="login123";
+	$webmestre="non";
+	$statut="5poubelle";
+
+	$userData = array(
+	'nom' => $nom,
+	'email' => $email, 
+	'login' => $login, 
+	'pass' => $pass, 
+	'webmestre' => $webmestre, 
+	'statut' => $statut);
+
+	ini_set("soap.wsdl_cache_enabled", "0");
+	$clientSOAP = new nusoap_client('http://@HOSTSPIP/soap_spip.wsdl',true);
+	$clientSOAP->setUseCurl(false);
+
+	$result = $clientSOAP->call('add_user', array('username' => $username, 'password'=> $password, 'userData' => $userData) );
+	// Check for a fault
+	if ($clientSOAP->fault) {
+		error_log( "fault :'" . $result['faultstring'] ."'");
+		return false;
+	} else {
+		// Check for errors
+		$err = $clientSOAP->getError();
+		if ($err) {
+			// Display the error
+			//			error_log( "err :'" . $err ."'");
+			//			  error_log( "err :==> '" . $err ."'");
+			//			   error_log ( '<p><b>Error: ' . $err . '</b></p>');
+			//               error_log ( '<p><b>Request: <br>');
+			//               error_log ( $clientSOAP->request );
+			error_log('*error ------------------------------------------------------*');
+			error_log($err);
+			error_log('*Response: ---------------------------------------------------*');
+			error_log ($clientSOAP->response);
+			error_log('*------------------------------------------------------------*');
+			//error_log ( '<p><b>Debug: <br>');
+			//error_log (  htmlspecialchars($clientSOAP->debug_str, ENT_QUOTES) . '</b>');
+			return false;
+		}
+	}
+	return $result['return'];
+}
+
+function soap_add_user_site(){
+
+	require_once ('nf_config_inc.php');
+
+	$username = "toto";
+	$password = "hjhjhj";
+	$login='login123';
+
+	$siteId="spip2";
+	//	$statut="1comite";
+	//	$role=_NF_ADMINISTRATOR;
+	//	$role =_NF_WEBMASTER;
+	//	$role=_NF_AUTHOR;
+	$role= _NF_VISITOR;
+
+	//	$userStatut = array(
+	//	'statut' => $statut);
+
+	$clientSOAP = new nusoap_client('http://@HOSTSPIP/soap_spip.wsdl',true);
+	$clientSOAP->setUseCurl(false);
+
+	$result = $clientSOAP->call('add_user_site', array('username' => $username, 'password'=> $password, 'login'=>$login, 'siteId'=>$siteId, 'role' => $role) );
+	// Check for a fault
+	if ($clientSOAP->fault) {
+		error_log( "fault :'" . $result['faultstring'] ."'");
+		return false;
+	} else {
+		// Check for errors
+		$err = $clientSOAP->getError();
+		if ($err) {
+			// Display the error
+			error_log( "err :'" . $err ."'");
+			return false;
+		}
+	}
+	return $result['return'];
+}
+
+function soap_get_user_info(){
+	$username = "toto";
+	$password = "hjhjhj";
+
+	$clientSOAP = new nusoap_client('http://@HOSTSPIP/soap_spip.wsdl',true);
+	$clientSOAP->setUseCurl(false);
+
+	$login="blachonm";
+	$result = $clientSOAP->call('get_user', array('username' => $username, 'password'=> $password, 'login' => $login) );
+	// Check for a fault
+	if ($clientSOAP->fault) {
+		error_log( "fault :'" . $result['faultstring'] ."'");
+		return false;
+	} else {
+		// Check for errors
+		$err = $clientSOAP->getError();
+		if ($err) {
+			// Display the error
+			error_log( "err :'" . $err ."'");
+			return false;
+		}
+	}
+	return $result['return'];
+}
+
+function soap_get_user_id(){
+
+	$username = "toto";
+	$password = "hjhjhj";
+
+	$clientSOAP = new nusoap_client('http://@HOSTSPIP/soap_spip.wsdl',true);
+	$clientSOAP->setUseCurl(false);
+
+	$login="blachonm";
+	$result = $clientSOAP->call('get_user_id', array('username' => $username, 'password'=> $password, 'login' => $login) );
+	// Check for a fault
+	if ($clientSOAP->fault) {
+		error_log( "fault :'" . $result['faultstring'] ."'");
+		return false;
+	} else {
+		// Check for errors
+		$err = $clientSOAP->getError();
+		if ($err) {
+			// Display the error
+			error_log( "err :'" . $err ."'");
+			return false;
+		}
+	}
+	return $result['return'];
+
+}
+
+function soap_delete_user(){
+	$username = "toto";
+	$password = "hjhjhj";
+
+	$login="login123";
+
+	$clientSOAP = new nusoap_client('http://@HOSTSPIP/soap_spip.wsdl',true);
+	$clientSOAP->setUseCurl(false);
+
+	$result = $clientSOAP->call('delete_user', array('username' => $username, 'password'=> $password, 'login' => $login) );
+	// Check for a fault
+	if ($clientSOAP->fault) {
+		error_log( "fault :'" . $result['faultstring'] ."'");
+		return false;
+	} else {
+		// Check for errors
+		$err = $clientSOAP->getError();
+		if ($err) {
+			// Display the error
+			error_log( "err :'" . $err ."'");
+			return false;
+		}
+	}
+	return $result['return'];
+}
+
+function soap_update_user(){
+	$username = "toto";
+	$password = "hjhjhj";
+
+	$nom = "pseudo_test1";
+	$email="pppppp@rr";
+	$login="login123";
+	$pass="login123";
+	$webmestre="non";
+	$statut="1comite";
+
+	$userData = array(
+	'nom' => $nom,
+	'email' => $email, 
+	'login' => $login, 
+	'pass' => $pass, 
+	'webmestre' => $webmestre, 
+	'statut' => $statut);
+
+	$clientSOAP = new nusoap_client('http://@HOSTSPIP/soap_spip.wsdl',true);
+	//$clientSOAP = new nusoap_client('http://spip2.localhost/soap_spip.wsdl',true);
+	$clientSOAP->setUseCurl(false);
+
+	$result = $clientSOAP->call('update_user', array('username' => $username, 'password'=> $password, 'userData' => $userData) );
+	// Check for a fault
+	if ($clientSOAP->fault) {
+		error_log( "fault :'" . $result['faultstring'] ."'");
+		return false;
+	} else {
+		// Check for errors
+		$err = $clientSOAP->getError();
+		if ($err) {
+			// Display the error
+			error_log( "err :'" . $err ."'");
+			return false;
+		}
+	}
+	return $result['return'];
+}
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/ecrire/nusoap/0001-Fix-12312-NuSOAP-web-description-XSS-vulnerability.patch spip/ecrire/nusoap/0001-Fix-12312-NuSOAP-web-description-XSS-vulnerability.patch
--- spip-ori/ecrire/nusoap/0001-Fix-12312-NuSOAP-web-description-XSS-vulnerability.patch	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nusoap/0001-Fix-12312-NuSOAP-web-description-XSS-vulnerability.patch	2013-04-05 11:06:41.153923139 +0200
@@ -0,0 +1,119 @@
+From edb817991b99cd5538f102be26865fde7c6b7212 Mon Sep 17 00:00:00 2001
+From: David Hicks <hickseydr@optusnet.com.au>
+Date: Thu, 2 Sep 2010 21:51:21 +1000
+Subject: [PATCH] Fix #12312: NuSOAP web description XSS vulnerability
+
+Bogdan Calin from Acunetix discovered a number of XSS vulnerabilities in
+NuSOAP 0.9.5 (bundled with MantisBT) relating to improperly escaped
+URLs.
+
+A sample exploit URL is:
+/api/soap/mantisconnect.php?1<ScRiPt>prompt(923395)</ScRiPt>
+
+The upstream report for these XSS flaws in NuSOAP is located at the
+following URL:
+http://sourceforge.net/projects/nusoap/forums/forum/193579/topic/3834005
+
+This patch provides an interim fix for MantisBT users until upstream
+makes a new release.
+---
+ library/nusoap/class.wsdl.php |   16 ++++++++--------
+ library/nusoap/nusoap.php     |   14 +++++++-------
+ 2 files changed, 15 insertions(+), 15 deletions(-)
+
+diff --git a/library/nusoap/class.wsdl.php b/library/nusoap/class.wsdl.php
+index 6d2a693..7dcc307 100644
+--- a/library/nusoap/class.wsdl.php
++++ b/library/nusoap/class.wsdl.php
+@@ -842,9 +842,9 @@ class wsdl extends nusoap_base {
+ 		<body>
+ 		<div class=content>
+ 			<br><br>
+-			<div class=title>'.$this->serviceName.'</div>
++			<div class=title>'.htmlentities($this->serviceName).'</div>
+ 			<div class=nav>
+-				<p>View the <a href="'.$PHP_SELF.'?wsdl">WSDL</a> for the service.
++				<p>View the <a href="'.htmlentities($PHP_SELF).'?wsdl">WSDL</a> for the service.
+ 				Click on an operation name to view it&apos;s details.</p>
+ 				<ul>';
+ 				foreach($this->getOperations() as $op => $data){
+@@ -854,21 +854,21 @@ class wsdl extends nusoap_base {
+ 				    <a href='#' onclick='popout()'><font color='#ffffff'>Close</font></a><br><br>";
+ 				    foreach($data as $donnie => $marie){ // loop through opdata
+ 						if($donnie == 'input' || $donnie == 'output'){ // show input/output data
+-						    $b .= "<font color='white'>".ucfirst($donnie).':</font><br>';
++						    $b .= "<font color='white'>".htmlentities(ucfirst($donnie)).':</font><br>';
+ 						    foreach($marie as $captain => $tenille){ // loop through data
+ 								if($captain == 'parts'){ // loop thru parts
+-								    $b .= "&nbsp;&nbsp;$captain:<br>";
++								    $b .= "&nbsp;&nbsp;".htmlentities($captain).":<br>";
+ 					                //if(is_array($tenille)){
+ 								    	foreach($tenille as $joanie => $chachi){
+-											$b .= "&nbsp;&nbsp;&nbsp;&nbsp;$joanie: $chachi<br>";
++											$b .= "&nbsp;&nbsp;&nbsp;&nbsp;".htmlentities($joanie).": ".htmlentities($chachi)."<br>";
+ 								    	}
+ 					        		//}
+ 								} else {
+-								    $b .= "&nbsp;&nbsp;$captain: $tenille<br>";
++								    $b .= "&nbsp;&nbsp;".htmlentities($captain).": ".htmlentities($tenille)."<br>";
+ 								}
+ 						    }
+ 						} else {
+-						    $b .= "<font color='white'>".ucfirst($donnie).":</font> $marie<br>";
++						    $b .= "<font color='white'>".htmlentities(ucfirst($donnie)).":</font> ".htmlentities($marie)."<br>";
+ 						}
+ 				    }
+ 					$b .= '</div>';
+@@ -1935,4 +1935,4 @@ class wsdl extends nusoap_base {
+ 	} 
+ }
+ 
+-?>
+\ No newline at end of file
++?>
+diff --git a/library/nusoap/nusoap.php b/library/nusoap/nusoap.php
+index 4973532..10750aa 100644
+--- a/library/nusoap/nusoap.php
++++ b/library/nusoap/nusoap.php
+@@ -5424,9 +5424,9 @@ class wsdl extends nusoap_base {
+ 		<body>
+ 		<div class=content>
+ 			<br><br>
+-			<div class=title>'.$this->serviceName.'</div>
++			<div class=title>'.htmlentities($this->serviceName).'</div>
+ 			<div class=nav>
+-				<p>View the <a href="'.$PHP_SELF.'?wsdl">WSDL</a> for the service.
++				<p>View the <a href="'.htmlentities($PHP_SELF).'?wsdl">WSDL</a> for the service.
+ 				Click on an operation name to view it&apos;s details.</p>
+ 				<ul>';
+ 				foreach($this->getOperations() as $op => $data){
+@@ -5436,21 +5436,21 @@ class wsdl extends nusoap_base {
+ 				    <a href='#' onclick='popout()'><font color='#ffffff'>Close</font></a><br><br>";
+ 				    foreach($data as $donnie => $marie){ // loop through opdata
+ 						if($donnie == 'input' || $donnie == 'output'){ // show input/output data
+-						    $b .= "<font color='white'>".ucfirst($donnie).':</font><br>';
++						    $b .= "<font color='white'>".htmlentities(ucfirst($donnie)).':</font><br>';
+ 						    foreach($marie as $captain => $tenille){ // loop through data
+ 								if($captain == 'parts'){ // loop thru parts
+-								    $b .= "&nbsp;&nbsp;$captain:<br>";
++								    $b .= "&nbsp;&nbsp;".htmlentities($captain).":<br>";
+ 					                //if(is_array($tenille)){
+ 								    	foreach($tenille as $joanie => $chachi){
+-											$b .= "&nbsp;&nbsp;&nbsp;&nbsp;$joanie: $chachi<br>";
++											$b .= "&nbsp;&nbsp;&nbsp;&nbsp;".htmlentities($joanie).": ".htmlentities($chachi)."<br>";
+ 								    	}
+ 					        		//}
+ 								} else {
+-								    $b .= "&nbsp;&nbsp;$captain: $tenille<br>";
++								    $b .= "&nbsp;&nbsp;".htmlentities($captain).": ".htmlentities($tenille)."<br>";
+ 								}
+ 						    }
+ 						} else {
+-						    $b .= "<font color='white'>".ucfirst($donnie).":</font> $marie<br>";
++						    $b .= "<font color='white'>".htmlentities(ucfirst($donnie)).":</font> ".htmlentities($marie)."<br>";
+ 						}
+ 				    }
+ 					$b .= '</div>';
+-- 
+1.7.2.2
+
diff -rNU5 spip-ori/ecrire/nusoap/changelog spip/ecrire/nusoap/changelog
--- spip-ori/ecrire/nusoap/changelog	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nusoap/changelog	2013-04-05 11:06:41.153923139 +0200
@@ -0,0 +1,648 @@
+2003-07-21, version 0.6.5
+- soap_transport_http: SOAPAction header is quoted again, fixes problem w/ Weblogic Server
+- applied Jason Levitt patch for proper array serialization, fixes problem w/ Amazon shopping cart services
+- fixed null value serialization
+- applied patch from "BZC ToOn'S" - fixes wsdl serialization when no parameters
+- applied John's patch, implementing compression for the server
+
+2003-07-22, version 0.6.5
+- soap_server: fixed bug causing charset encoding not to be passed to the parser
+- soap_fault: added default encoding to the fault serialization
+- soap_parser: changed the parser to pre-load the parent's result array when processing scalar values. This increases parsing speed.
+
+2003-07-23, version 0.6.5
+- soap_base: fix code that overwrites user-supplied attributes in serialize_val
+- soap_base: use arrays-of-arrays rather than attempting multi-dimensional in serialize_val
+- xmlschema: emit import statements and qualify all elements with prefix in serializeSchema (better interop with validation tools)
+- soapclient: get xml character encoding from HTTP Content-Type header if provided, e.g. text/xml;charset="UTF-8"
+- soapclient: use headers in call if provided (previously ignored this parameter)
+- soap_server: in parse_request, if neither getallheaders nor $_SERVER are available, use $HTTP_SERVER_VARS to get SOAPAction and xml encoding
+
+2003-07-24, version 0.6.5
+- soap_transport_http: apply patch from Steven Brown "if the server closes connection prematurely, nusoap would spin trying to read data that isn't there"
+
+2003-07-25, version 0.6.5
+- wsdl: apply patch from Sven to workaround single schema limitation
+- wsdl: apply a variant of the patch from Holger to handle empty values for array by serializing an array with 0 elements
+- xmlschema: remove the redundant default namespace attribute on the schema element; everything in xsd is explicitly specified as being from xsd
+- soap_transport_http: fix setCredentials and add TODO comments in sendHTTPS about what to change if this setCredentials stays
+
+2003-07-30, version 0.6.5
+- nusoap_base: change documentation of soap_defencoding to specify it is the encoding for outgoing messages
+- nusoap_base: only change &, <, > to entities, not all HTML entities
+- soap_transport_http: update the Content-Type header in sendRequest, since soap_defencoding could be changed after ctor is called
+- soap_server: use soap_defencoding instead of charset_encoding
+- soap_server: read encoding from _SERVER if available
+- nusoap_base: do entity translation for string parameters with an xsd type specified (thanks David Derr)
+
+2003-07-31, version 0.6.5
+- soap_transport_http: add proxy authentication
+- soap_transport_http: build payload the same way for http and https
+- wsdl: add proxy authentication
+- soapclient: add proxy authentication
+- soapclient: allow proxy information in ctor, so that it can be used for wsdl
+
+2003-08-01, version 0.6.5
+- soap_transport_http: close a persistent connection that's at EOF
+- soap_transport_http: prevent conflicts between setEncoding and usePersistentConnection
+- soap_transport_http: fix use of $headers instead of $this->incoming_headers in getResponse
+- soapclient: improve handling of persistent connections
+- soapclient: force xml_encoding to upper case
+- soap_server: let the Web server decide whether to close the connection (no Connection: close header)
+- soap_server: force xml_encoding to upper case
+
+2003-08-04, version 0.6.5
+- soap_parser: use XML type information to pick a PHP data type; also decode base64
+- soap_server: read all HTTP headers when using _SERVER or HTTP_SERVER_VARS
+- soap_server: add gzip encoding support for outgoing messages
+- soap_transport_http: deflate is gzcompress/gzuncompress (cf. http://archive.develooper.com/libwww@perl.org/msg04650.html)
+- soap_transport_http: clean use of persistentConnection so it's always a set boolean
+- soapclient: add responseData member to access deflated/gunzipped payload
+
+2003-08-05, version 0.6.5
+- soap_server: look multiple places when setting debug_flag
+
+2003-08-07, version 0.6.5
+- nusoap_base: serialize specified type (e.g. ArrayOfString) even for simple array
+- wsdl: only specify encodingStyle in the input/output soap bindings when it is not empty (thanks Guillaume)
+
+2003-08-15, version 0.6.5
+- soap_parser: fix parsing of elements with no XSD type specified
+- soap_parser: use PHP string type for XSD long and unsignedLong types
+
+2003-08-16, version 0.6.5
+- soap_parser: fix code generating warning (thanks Torsten)
+
+2003-08-19, version 0.6.5
+- soap_parser: fix another line of code generating a warning (thanks Torsten)
+
+2003-08-22, version 0.6.5
+- soap_server: remove all '--' from debug_str; previous code changed '---' to '- --'
+- wsdl, soapclient, soap_parser: patch submitted by Mark Spavin as described by
+                                 the following...
+> Changes for the multiple/nested imports from the wsdl file. This builds an
+> array of files not just the last one and also checks for relative paths to
+> the parent. This will then get the imported files from the remote site
+> instead of your local disk. Local wsdl files should still work (untested).
+>
+> Changes for multiple encoding sytles as previously posted
+
+2003-08-24, version 0.6.5
+- wsdl, soapclient: fix some PHP notices from previous update
+
+2003-08-26, version 0.6.5
+- wsdl: support multiple SOAP ports
+- soapclient, soap_server: when no charset is specified, use UTF-8, even though HTTP specifies US-ASCII.
+- soap_transport_http: do not prepend $host with 'ssl://' for https (is this required for older cURL versions?)
+
+2003-08-27, version 0.6.5
+- soap_server: support compressed request messages (thanks John Huong)
+- soap_parser: deserialize Apache Vector as an array
+- xmlschema: use $this->typemap in getPHPType (which is not used)
+- soapclient, wsdl: check for WSDL errors after serializing parameters
+- nusoap_base: add serialization of Apache Map (when not using WSDL)
+- wsdl: add serialization of Apache Map (when using WSDL)
+- wsdl: only change &, <, > to entities, not all HTML entities
+
+2003-08-28, version 0.6.5
+- soap_transport_http: disable cURL verification of peer and server (formerly the cURL default)
+- soap_transport_http: mingle cURL code with straight http, so sendHTTP is no longer needed
+
+2003-08-29, version 0.6.6
+- soap_transport_http: add setContentType
+- soapclient: call setContentType using new getHTTPContentType and getHTTPContentTypeCharset
+
+2003-09-05, version 0.6.6
+- wsdl: add some more code to handle null/nil values (but there's still a way to go)
+
+2003-10-21, version 0.6.6
+- soap_transport_http: only include port in Host header if it was specified in the URL
+- soap_transport_http: add some code to use OpenSSL for PHP ssl:// scheme, but comment out since it's not ready
+- soap_server: use $_SERVER['PHP_SELF'] if $GLOBALS['PHP_SELF'] is not set
+- wsdl: add WSDL request and response and transport debug to debug
+- wsdl: handle custom type extending xmlschema namespace (GLUE ... Thanks Matt)
+- soap_parser: add param to docs
+- soapclient: add getHTTPBody, getHTTPContentType, getHTTPContentTypeCharset (anticipating MIME subclass)
+
+2003-10-28, version 0.6.6
+- nusoap_base: add expandEntities method
+- wsdl: use expandEntities
+- soap_fault: use expandEntities
+- soap_transport_http: Allow credentials to be included in URL, rather than requiring setCredentials
+- soap_transport_http: Merge HTTP headers that span multiple lines
+- soap_parser: Properly set errors in ctor
+- soapclient: Pass headers to parseResponse and parse them in that method
+
+2003-10-30, version 0.6.6
+- xmlschema: Add some information for the related type to an element
+
+2003-12-09, version 0.6.6
+- nusoap_base: Add some namespace methods previously in xmlschema
+- xmlschema: Improve parsing of complexType, element and simpleType
+- xmlschema: Improve serialization
+- xmlschema: Track imports
+- xmlschema: Track elementFormDefault and form attributes
+- wsdl: Support multiple <schema> (note that setting $server->wsdl->schemaTargetNamespace no longer does anything!  Use configureWSDL instead.)
+- wsdl: Use form attribute of element to control namespace specification
+- wsdl: Support chained imports (A imports B which imports C)
+- wsdl: Include port in endpoint address when serializing
+- soap_server: Fix use of style (rpc|document) and use (encoded|literal)
+- soap_server: Support _SERVER[CONTENT_TYPE] in addition to _SERVER[HTTP_CONTENT_TYPE]
+- soap_server: Support wsdl with multiple <schema>
+- soap_client: Remove a var_dump
+- soap_client: Add style and use parameters to call method to support doc/lit without WSDL
+- soap_transport_http: Check that $this->fp exists when doing persistent connections
+
+2003-12-17, version 0.6.6
+- soap_server: pass namespaces to xmlschema constructor
+- wsdl: post-process after all imports
+- wsdl: remove some debug, add some error handling
+- xmlschema: allow enclosing namespaces to be specified in constructor
+- xmlschema: improve handling of compositors and simple types
+
+2004-01-08, version 0.6.6
+- soap_server: when requested WSDL is in a file, return to client using passthru (thanks Ingo Fischer)
+- soapclient: have proxy inherit more client state
+- soapclient: allow timeout and response timeout to be specified in the constructor
+- wsdl: allow timeout and response timeout to be specified in the constructor
+- soap_transport_http: allow response timeout to be specified in send and sendHTTPS
+
+2004-01-28, version 0.6.6
+- wsdl: add namespace for array and scalar when form is qualified
+- wsdl: fix a bug in which data type of complexType elements were ignored in serialization
+- wsdl: enhance handling of URLs with file scheme
+- wsdl: add addSimpleType
+- xmlschema: add addSimpleType
+- xmlschema: always set phpType elements
+- soapclient: allow a wsdl instance to be specified in constructor
+- soap_server: allow a wsdl instance to be specified in constructor (not tested!)
+- soap_server: fix default SOAPAction created in register method
+- soap_transport_http: accept chunking with LF separators in addition to CRLF.
+- wsdlcache: added class
+- nusoapmime: fix comments
+
+2004-02-23, version 0.6.6
+- soap_transport_http: don't try to unchunk cURL data, since cURL already does it
+- soap_transport_http: append CVS revision to version in User-Agent
+- wsdl: serialize boolean as true|false, not 1|0, to agree with XML Schema
+- soap_server: always exit() after returning WSDL
+- soap_server: use the WSDL URL scheme as the default endpoint URL scheme
+- soap_server: append CVS revision to version in X-SOAP-Server
+- nusoap_base: add (CVS) revision
+- wsdlcache: synchronize using a per-WSDL lock file (Thanks Ingo)
+- wsdlcache: add cache lifetime, after which cache contents are invalidated (Thanks Ingo)
+
+2004-03-15, version 0.6.6
+- nusoap_base: add isArraySimpleOrStruct method
+- soap_server: improve WSDL URL scheme determination
+- soap_server: only deflate/gzip payloads > 1024 bytes
+- soap_server: fix parameter order in fault method (always used as faultcode, faultstring)
+- soap_server: refactor parse_request into multiple functions (for sanity)
+- soap_server: set the namespace on the Response element to the same as the request
+- soap_server: name the return value element 'return' by default
+- soap_server: added and documented data fields, so that service programmers can use them if desired
+- soap_parser: standardize parsing error message
+- soap_parser: fix document and responseHeaders so they are the correct XML text (as documented)
+- soap_transport_http: fix read from persistent connection
+- soapclient: clean up debugging for persistent connection
+- wsdl: enforce correct naming of messages parts when an associative array is used for parameters
+- wsdl: better serialization of null values
+- wsdl: standardize parsing error message
+- xmlschema: standardize parsing error message
+
+2004-03-24, version 0.6.7
+- soap_transport_http: add digest authentication (based on code by Kevin A. Miller)
+- xmlschema: improve parsing of import elements
+- wsdl: do schema imports even if there are no wsdl imports
+
+2004-04-12, version 0.6.7
+- wsdl: serialize multiple elements when maxOccurs="unbounded" and value is an array
+- wsdl: serialize soapval values (used to force an XML type, e.g. when WSDL uses an abstract type)
+- nusoapmime: do not require nusoap.php (it is now the programmer's responsibility)
+
+2004-04-21, version 0.6.7
+- soap_parser: parse repeated element name into an array (de-serializes doc/lit array into a PHP array when there is more than 1 array element)
+- soap_server: do not wrap response in a response element for a document style service
+
+2004-04-30, version 0.6.7
+- soap_transport_http: allow digest auth params to be separated by "," as well as ", "
+- soap_transport_http: re-initialize incoming headers for each response
+- soap_server: add methodreturnisliteralxml property to allow service function to return XML as a string
+- soapclient: improve rpc/literal support
+- soapclient: allow XML string as call params in addition to array
+- soapclient: support document style and literal encoding when not using WSDL
+
+2004-05-05, version 0.6.7
+- wsdl: serialize PHP objects for WSDL XML Schema complexTypes, in addition to associative arrays
+- wsdl: fix WSDL generation when there is no encodingStyle
+- soap_transport_http: suppress fsockopen warnings
+- soap_transport_http: detect socket timeouts when reading (0 bytes returned)
+- soap_transport_http: read chunked content "in-line" so it works on a persistent connection
+- nusoap_base: serialize boolean as true|false, not 1|0, to agree with XML Schema
+- nusoap_base: serialize array of struct differently than array of array
+
+2004-06-25, version 0.6.8
+- soap_server: prefer gzip to deflate, since IE does not like our deflate
+- soap_server: move webDescription to the wsdl class
+- soap_server: allow class and instance method calls for service (thanks Ingo Fischer and Roland Knall)
+- wsdl: get webDescription from the soap_server class
+- wsdl: allow compression from the server
+- wsdl: fix serialization of soapval without a type
+- wsdl: propagate debug value from query string to SOAP endpoint in programmatic WSDL generation
+- nusoap_base: add anyType, anySimpleType for 2001 XML Schema
+- nusoap_base: provide additional debug functions
+- soap_transport_http: ignore Content-Length when chunked encoding is used
+- soap_transport_http: remove ':' from username for Basic authentication (cf. RFC 2617)
+- soap_transport_http: urldecode username and password taken from URL
+- soap_transport_http: use raw inflate/deflate for IE/IIS compatibility, rather than having Zlib headers according to HTTP 1.1 spec
+- soap_transport_http: attempt to handle the case when both the service application and Web server compress the response
+- soapclient: when creating proxy methods, replace '.' in operation name with '__' in function name
+- soapclient: initialize requestHeaders in proxy
+- general: use new debug methods; never access debug_str directly
+
+2004-09-30, version 0.6.8
+- soapclient: do not allow getProxy call when WSDL is not used
+- soapclient: use ISO-8859-1 as the charset if not specified in the Content-Type header
+- soapclient: when an empty string is specified for the call namespace, do not put the method element in a namespace
+- soapclient: let soap_transport_http check for SSL support
+- soapclient: have proxy inherit soap_defencoding from the client from which it is generated
+- soapclient: do not assume that 'ns1' is an unused namespace prefix; always generate namespace prefixes randomly
+- soap_parser: compare any encoding in the XML declaration to the charset from the HTTP Content-Type header (thanks Ingo Fischer)
+- soap_parser: improve parse repeated element name into an array (de-serializes doc/lit array into a PHP array when there is more than 1 array element)
+- soap_server: use ISO-8859-1 as the charset if not specified in the Content-Type header
+- soap_server: allow suppression of automatic UTF-8 decoding
+- soap_server: fix a bug when call_user_func_array() is used
+- soap_transport_http: correct digest authentication through a proxy
+- wsdl: serialize SOAP-ENC types similarly to XSD types
+- xmlschema: force unprefixed type into default namespace
+- xmlschema: fix serialization of definition of simple types
+
+2004-10-01, version 0.6.8
+- soap_parser: handle default namespace attributes
+- soap_server: add default_utf8 field
+- soap_server: support literal encoding (with RPC style)
+- soap_transport_http: parse HTTP status and generate error for 300, 302-307, 400, 401-417, 501-505 (thanks for the idea Ghislain)
+- soap_transport_http: follow HTTP redirection (HTTP status 301 and Location header) (thanks for the idea Ghislain)
+- xmlschema: allow any attributes to be specified in an element of a complexType, e.g., abstract, default, form, minOccurs, maxOccurs, nillable (thanks Jirka Pech for the original patch)
+
+2004-10-02, version 0.6.8
+- soapclient: read/write cookies (thanks Ingo)
+- soap_server: change faultcode on non-resendable faults to Client
+- soap_transport_http: read/write cookies (thanks Ingo)
+
+2004-10-05, version 0.6.8
+- wsdl: add addElement method
+- wsdl: support the document style in the register method
+- xmlschema: parse unnamed simpleTypes, rather than ignoring them
+- xmlschema: include untyped elements when parsing a complexType
+- xmlschema: add addElement method
+
+2004-10-14, version 0.6.8
+- soapclient: support client certificates
+- soap_parser: deserialize attributes, prefixing names with "!"
+- soap_server: notify the client with HTML when WSDL is requested but not supported by service
+- soap_transport_http: support client certificates
+- wsdl: support defaults for elements of a complexType
+- wsdl: serialize elements from complexType extension base
+- wsdl: serialize data (associative array elements) as attributes according to XML Schema
+- xmlschema: record extension base if present for a complexType
+
+2004-12-15, version 0.6.8
+- nusoap_base: add 2000 XML Schema (rare, but used by Akamai)
+- soap_parser: avoid deserializing more common attributes that are not data
+- soap_parser: be lax when HTTP specifies ISO-8859-1 (the default) and XML specifies UTF-8 (the norm)
+- soap_server: account for the fact that get_class_methods returns methods in all lower case (thanks Steve Haldane)
+- soap_transport_http: parse digest info that includes '=' in the data (thanks Jinsuk Kim)
+- wsdl: feably handle some cases for literal serialization of form="unqualified" elements
+- wsdl: don't serialize the decimal portion of a PHP double when the XML type is long
+- wsdl: fix serialization of attributes for complexType that is an extension
+- wsdlcache: enhance diagnostics
+- xmlschema: handle untyped elements
+- xmlschema: handle WSDL for SOAP Array that uses the base attribute plus a sequence of element
+
+2005-01-22, version 0.6.8
+- wsdl: allow an element in one schema to have a type from another schema
+
+2005-01-24, version 0.6.8
+- xmlschema: correctly parse nested complexType definitions
+
+2005-02-14, version 0.6.8
+- nusoap_base: fix a bug in which attributes were sometimes not serialized with a value
+- nusoap_base: improve serialization of null values (thanks Dominique Stender)
+- soap_parser: parse null values by handling the nil attribute (thanks Dominique Stender)
+- soap_server: set character encoding for a fault to be the same as for the server (thanks Mark Scott)
+- soap_server: correctly check for null value returned from method when WSDL is used (without WSDL, cannot distinguish whether NULL or void return is desired)
+- soapclient: for document style, call should always return an array rooted at the response part (all bets are off when there are multiple parts)
+- xmlschema: save enumeration values parsed from WSDL
+
+2005-02-10, version 0.6.9
+- soapclient: only set SOAP headers when they are specified in call params (so setHeaders still works)
+
+2005-04-04, version 0.6.9
+- soap_server: use get_class instead of is_a (thanks Thomas Noel)
+- soapclient: use get_class instead of is_a (thanks Thomas Noel)
+- soapclient: add setEndpoint method
+- soap_transport_http: fix client certificates (thanks Doug Anarino and Eryan Eriobowo)
+
+2005-04-29, version 0.6.9
+- nusoap_base: add global variable and methods for setting debug level
+- nusoap_base: use xsd:anyType instead of xsd:ur-type to serialize arrays with multiple element types (thanks Ingo Fischer)
+- nusoap_base: expand entities in attributes (thanks Gaetano Giunta)
+- soapclient: call parent constructor
+- soapval: call parent constructor
+- soap_fault: call parent constructor
+- soap_parser: call parent constructor
+- soap_server: assume get_class_methods always returns lower case for PHP 4.x only
+- soap_server: call parent constructor
+- soap_transport_http: do nothing in setEncoding if gzdeflate is not present (thanks Franck Touanen for pointing this out)
+- soap_transport_http: fix check for server request for digest authentication (thanks Mark Spavin)
+- soap_transport_http: call parent constructor
+- wsdl: fix documentation page popup of one method after another (thanks Owen)
+- wsdl: call parent constructor
+- wsdl: expand entities in attributes (thanks Gaetano Giunta)
+- xmlschema: call parent constructor
+
+2005-06-03, version 0.6.9
+- nusoap_base: serialize empty arrays as having elements xsd:anyType[0]
+- nusoap_base: add encodingStyle parameter to serializeEnvelope
+- nusoap_base: serialize xsi:type with nil values
+- nusoap_base: improve debug and comments
+- soap_parser: correctly parse an empty array to an empty array, not an empty string
+- soap_parser: improve debug and comments
+- soap_server: specify encodingStyle for envelope when WSDL is used
+- soapclient: factor out new getProxyClassCode method
+- soapclient: specify encodingStyle for envelope
+- soapclient: improve debug and comments
+- wsdl: add namespace for Apache SOAP types if a variable of such type is serialized
+- wsdl: serialize nil value for nillable elements when no value is provided
+- wsdl: serialize xsi:type with nil values
+- wsdl: copy attributes as well as elements to an element from its complexType
+- wsdl: specify encodingStyle for operations
+- wsdl: improve debug and comments
+- xmlschema: improve debug and comments
+
+2005-06-03, version 0.7.0
+- nusoap_base: improve debug and comments
+- nusoap_base: fix version, which should have been 0.7.0 since 2005-03-04
+
+2005-06-06, version 0.7.1
+- nusoap_base: adjust numeric element names for serialization, instead of forcing them to 'soapVal'
+- nusoapmime: add type=text/xml to multipart/related (thanks Emmanuel Cordonnier)
+- soap_fault: fix serialization of detail
+- soap_server: check required parameters for register method
+- soap_server: when getallheaders is used, massage header names
+- soap_server: use SOAPAction to determine operation when doc/lit service does not wrap parameters in an element with the method name (thanks Peter Hrastnik)
+- soap_transport_http: correctly handle multiple HTTP/1.1 100 responses for https (thanks Jan Slabon)
+- wsdl: fixed documentation for addComplexType (thanks Csintalan �d�m)
+- wsdl: serialize array data when maxOccurs = 'unbounded' OR maxOccurs > 1 (thanks Dominique Schreckling)
+- wsdl: when serializing a string == 'false' as a boolean, set the value to false
+- wsdl: when serializing a complexType, require the PHP value supplied to be an array
+
+2005-07-01, version 0.7.1
+- nusoap_base: Allow SOAP headers to be supplied as an array like parameters
+- soap_parser: de-serialize simpleContent that accompanies complexContent
+- soap_server: append debug information when programmatically-defined WSDL is returned
+- soap_transport_http: Add debug when an outgoing header is set
+- soapclient: Allow SOAP headers to be supplied as an array like parameters
+- xmlschema: serialize attributes more generally, rather than assuming they are for SOAP 1.1 Array
+- wsdl: when serializing, look up types by namespace, not prefix (simple programmatic doc/lit WSDL now seems to work)
+- wsdl: process namespace declarations first when parsing an element
+
+2005-07-27, version 0.7.1
+- nusoap_base: do not override supplied element name with class name when serializing an object in serialize_val
+- nusoap_base: remove http://soapinterop.org/xsd (si) from namespaces array
+- nusoapmime: add nusoapservermime class to implement MIME attachments on the server
+- soap_fault: improve documentation
+- soap_server: improve documentation
+- soap_server: make consistent use of _SERVER and HTTP_SERVER_VARS
+- soap_server: make all incoming HTTP header keys lower case
+- soap_server: add hook functions to support subclassing for MIME attachments
+- soap_transport_http: remove an unnecessary global statement
+- soapclient: when creating a proxy, make $params within each function an associative array
+- soapval: improve documentation
+- wsdl: when serializing complexType elements, used typed serialization if there is either a type or a reference for the element
+- wsdl: allow PHP objects to be serialized as SOAP structs in serializeType
+- wsdl: for WSDL and XML Schema imports, don't forget to use the TCP port number (thanks Luca GIOPPO)
+- wsdl: make consistent use of _SERVER and HTTP_SERVER_VARS
+- xmlschema: improve documentation
+
+2005-07-31, version 0.7.2
+- nusoap_base: correctly serialize attributes in serialize_val (thanks Hidran Arias)
+- soap_parser: when resolving references, do not assume that buildVal returns an array (thanks Akshell)
+- soap_parser: removed decode_entities, which does not work (thanks Martin Sarsale)
+- soap_server: fix a bug parsing headers from _SERVER and HTTP_SERVER_VARS (thanks Bert Catsburg)
+- soap_server: parse all "headers" from HTTP_SERVER_VARS (not just HTTP_*)
+- soap_server: use PHP_SELF instead of SCRIPT_NAME for WSDL endpoint
+- soap_server: when generating a fault while debug_flag is true, put debug into faultdetail
+- wsdl: add enumeration parameter to addSimpleType
+- xmlschema: add enumeration parameter to addSimpleType
+
+2006-02-02, version 0.7.2
+- soapclient: initialize paramArrayStr to improve proxy generation
+- soap_parser: handle PHP5 soapclient's incorrect transmission of WSDL-described SOAP encoded arrays.
+- soap_server: don't assume _SERVER['HTTPS'] is set; try HTTP_SERVER_VARS['HTTPS'] if it is not
+- soap_server: "flatten out" the parameter array to call_user_func_array (thanks Andr� Mamitzsch)
+- soap_server: make thrown exceptions conform to specs
+- wsdl: use serialize_val to serialize an array when the XSD type is soapenc:Array (JBoss/Axis does this)
+- wsdl: change formatting of serialized XML for the WSDL
+- xmlschema: change formatting of namespaces when serializing XML for the schema
+
+2006-04-07, version 0.7.2
+- soap_server: if methodparams is not an array, call call_user_func_array with an empty array (thanks Eric Grossi)
+- wsdl: distinguish parts with element specified from those with type specified by suffixing element names with ^
+- wsdl: do a case-insensitive match on schema URI when looking for type
+- xmlschema: only get element (not type) when name has ^ suffix
+
+2006-05-16, version 0.7.2
+- soapclient: add getHeader to get parsed SOAP Header
+- soap_parser: check status when receiving Header or Body element
+- soap_parser: add soapheader
+- soap_server: add requestHeader with parsed SOAP Header
+
+2006-06-15, version 0.7.2
+- wsdl: fix bug in addComplexType (thanks Maarten Meijer)
+- soap_transport_http: change cURL message
+
+2007-03-19, version 0.7.2
+- soapclient: declare as nusoapclient, then also subclass soapclient if SOAP extension not loaded
+- soapclientmime: declare as nusoapclientmime, then also subclass soapclientmime if SOAP extension not loaded
+
+2007-03-28, version 0.7.2
+- nusoap_base: fix serialization of a soapval when its value is a soapval
+- soapval: fix serialization of a soapval when its value is a soapval
+- soapval: add __toString (cf. http://article.gmane.org/gmane.comp.php.nusoap.general/2776)
+- nusoapclient: use lazy retrieval of WSDL instead of always getting it in the constructor
+- nusoapclient: fix getProxy that was broken in last revision
+- wsdl: add ability to set authorization credentials and retrieve WSDL outside of constructor
+
+2007-04-05, version 0.7.2
+- nusoapclientmime: don't rely exclusively on Content-Disposition to distinguish the root part from attachment; also check Content-Type (thanks Ben Bosman)
+- nusoapclientmime: obey RFC 2045 Section 5.1 (thanks Chris Butler)
+- nusoapservermime: don't rely exclusively on Content-Disposition to distinguish the root part from attachment; also check Content-Type (thanks Ben Bosman)
+- nusoapservermime: obey RFC 2045 Section 5.1 (thanks Chris Butler)
+- nusoap_base: remove extra whitespace from some XML elements
+- nusoap_base: allow SOAP headers to be specified as an associative array (thanks Unique)
+- nusoap_base: implement __toString
+- nusoap_base: improve doc accuracy and consistency (thanks Martin K?gler)
+- iso8601_to_timestamp: avoid problem with negative hours after calculation, etc. (thanks Guntram Trebs)
+- nusoapclient: support user-settable cURL options (thanks Ciprian Popovici)
+- nusoapclient: call SOAP 1.2 binding operations if no SOAP 1.1 present (there is no reason to believe this will always work!)
+- nusoapclient: improve doc accuracy and consistency (thanks Martin K?gler)
+- soap_server: don't try to use eval to call function when any parameter is an object
+- soap_server: don't print return value within debug string; returned objects would need __toString in PHP 5.2
+- soap_server: use URL scheme for WSDL access as the scheme in SOAPAction
+- soap_server: strip port number from server name (some FastCGI implementations include port in server name)
+- soap_transport_http: support user-settable cURL options (thanks Ciprian Popovici)
+- soap_transport_http: use cURL for NTLM authentication
+- soap_transport_http: make digest authentication work for GET as well as POST
+- soap_transport_http: improve doc accuracy and consistency (thanks Martin K?gler)
+- soapval: remove __toString
+- wsdl: set operation style if necessary, but do not override one already provided (thanks Raffaele Capobianco)
+- wsdl: check SOAP 1.2 binding operations if no SOAP 1.1 present
+- wsdl: improve doc accuracy and consistency (thanks Martin K?gler)
+- xmlschema: fix simpleType serialization
+- xmlschema: improve doc accuracy and consistency (thanks Martin K?gler)
+
+2007-04-09, version 0.7.2
+- nusoapclient: set decode_utf8 when creating a proxy (thanks Dmitri Dmitrienko)
+- nusoapclient: rename class to nusoap_client
+- soap_fault: also provide a class named nusoap_fault
+- soap_parser: also provide a class named nusoap_parser
+- soap_server: also provide a class named nusoap_server
+- soap_transport_http: skip HTTP responses 301 and 401 when using cURL
+- soap_transport_http: don't force HTTP Connection header when using cURL
+- soap_transport_http: don't set HTTP Host and Content-Length headers when using cURL
+- soap_transport_http: support CURLOPT_SSLCERTPASSWD (thanks David Blanco)
+- wsdl: support user-settable cURL options (thanks Ciprian Popovici)
+- wsdl: serialize parameters for non-SOAP 1.1 binding operations (there is no reason to believe this will always work!)
+- xmlschema: also provide a class named nusoap_xmlschema
+- nusoapclientmime: rename class to nusoap_client_mime
+- nusoapservermime: rename class to nusoap_server_mime
+
+2007-04-11, version 0.7.2
+- nusoap_client: enable cURL usage to be forced (thanks Giunta Gaetano)
+- soap_transport_http: enable cURL proxy usage (thanks Giunta Gaetano)
+- soap_transport_http: enable cURL usage to be forced (thanks Giunta Gaetano)
+- soap_transport_http: use cURL's HTTP authentication options for basic, digest
+- wsdl: enable cURL usage to be forced (thanks Giunta Gaetano)
+
+2007-04-12, version 0.7.2
+- nusoap_client: add debug
+- nusoap_xmlschema: don't add elements of complexTypes to elements array (thanks Heiko Hund)
+- soap_transport_http: set cURL connection timeout if supported
+- soap_transport_http: add debug when setting cURL option
+- soap_transport_http: fix digest authentication broken in previous revision
+- wsdl: add debug
+- wsdlcache: address some issues with non-existing cache-files and PHP Warnings which came in such cases (thanks Ingo Fischer)
+- wsdlcache: change class name to nusoap_wsdlcache
+
+2007-04-13, version 0.7.2
+- wsdl: wrap parameters if unwrapped values are supplied and WSDL specifies Microsoft-style wrapping
+
+2007-04-16, version 0.7.2
+- nusoap_base: avoid warning in getDebugAsXMLComment
+- nusoap_client: small debug change
+- nusoap_client_mime: set responseData when the root part is found
+
+2007-04-17, version 0.7.2
+- soap_transport_http: improve detection of undefined cURL options (thanks Ingo Fischer)
+
+2007-05-28, version 0.7.2
+- soap_transport_http: support digest authentication opaque feature (cf. RFC 2617) (thanks Daniel Lacroix)
+- soap_transport_http: check safe_mode and open_basedir before setting CURLOPT_FOLLOWLOCATION
+- soap_transport_http: skip "HTTP/1.0 200 Connection established" header when cURL returns it (thanks Raimund Jacob)
+- nusoap_client: improve handling when getProxy is called and WSDL is not being used
+- nusoap_base: add comments about which specifications are used/implemented by NuSOAP
+- nusoap_xmlschema: create names for unnamed types that are unique by scope within XML Schema
+
+2007-06-11, version 0.7.2
+- wsdl: wrap return value if unwrapped value is supplied and WSDL specifies Microsoft-style wrapping
+
+2007-06-22, version 0.7.2
+- nusoap_xmlschema: fix serialization of simpleType restriction (thanks Rizwan Tejpar)
+
+2007-07-30, version 0.7.2
+- nusoap_server: Per http://www.ws-i.org/Profiles/BasicProfile-1.1-2004-08-24.html R2735, rpc/literal accessor elements should not be in a namespace (thanks Kostas Kalevras)
+- nusoap_client: Per http://www.ws-i.org/Profiles/BasicProfile-1.1-2004-08-24.html R2735, rpc/literal accessor elements should not be in a namespace (thanks Kostas Kalevras)
+
+2007-10-21, version 0.7.2
+- nusoap_server: Per http://www.ws-i.org/Profiles/BasicProfile-1.1-2004-08-24.html R2735, rpc/literal accessor elements should not be in a namespace (thanks Kostas Kalevras)
+- nusoap_client: Per http://www.ws-i.org/Profiles/BasicProfile-1.1-2004-08-24.html R2735, rpc/literal accessor elements should not be in a namespace (thanks Kostas Kalevras)
+
+2007-10-26, version 0.7.2
+- nusoap_server: Fix munging of _SERVER variables that start with HTTP_ (thanks Thomas Wieczorek)
+
+2007-10-30, version 0.7.2
+- nusoap_xmlschema: Serialize values for elementFormDefault, attributeFormDefault
+- wsdl: Improve consistency between doc/lit schema auto-wrapping and client's parsed schema
+- nusoap_server: Correct bug that placed encodingType in Envelope for doc/lit
+- nusoap_server: Specify elementFormDefault for schema within doc/lit wsdl
+
+2007-10-31, version 0.7.2
+- wsdl: Fix typo in parametersMatchWrapped (thanks Sam Stepanyan)
+- soap_transport_http: Fix three typos in setProxy (thanks Sam Stepanyan)
+- nusoap_xmlschema: Fix typo in serializeTypeDef (thanks Sam Stepanyan)
+
+2007-11-06, version 1.0rc1
+- wsdl: Improve handling of return values from doc/lit methods
+- nusoap_server: Handle case when method is not in a namespace
+
+2007-11-27, version 1.0rc1
+- nusoap_server: always try to invoke service for a POST
+- nusoap_server: only return Location: for WSDL at http://...
+- nusoap_base: change some syntax associated with globalDebugLevel
+
+2008-01-08, version 1.0rc1
+- nusoap_server: fix a typo where = was used instead of == (thanks J. (Johan) Bosma)
+
+2008-01-10, version 1.0rc1
+- nusoap_client: handle case where request or response has no content-type header (thanks Ingo Fischer)
+- nusoap_server: handle case where request or response has no content-type header (thanks Ingo Fischer)
+- wsdl: change CSS for .title in webDescription (thanks Marcus Uy)
+
+2008-01-25, version 1.0rc1
+- nusoap_xmlschema: when an element is of a complexType that is an extension, copy extensionBase from the type
+- nusoap_xmlschema: do not apply elementFormDefault to globally defined elements
+
+2008-02-11, version 1.0rc1
+- wsdl: internally set form of wrapped parameter elements to unqualified (so server handles correctly)
+
+2008-03-03, version 1.0.rc1
+- nusoap_xmlschema: fix extension when base type has no explicit prefix
+- nusoap_xmlschema: support XML Schema include
+- wsdl: improve support for sequence by serializing inherited attributes and elements first
+
+2008-03-04, version 1.0.rc1
+- wsdl: allow WSDL port name to be specified in getOperations
+- nusoap_client: allow WSDL port name to be specified in ctor
+
+2008-03-06, version 1.0rc1
+- wsdl: fix some port name variable references
+- nusoap_base: change comments regarding preferred mode of support
+- wsdl2nusoap: initial revision
+
+2008-03-14, version 1.0rc1
+- nusoap_base: fix timezone offset in timestamp_to_iso8601 (thanks Mario Trojan)
+
+2008-03-27, version 1.0rc1
+- nusoap_server: fix bug setting encodingStyle in serialize_return (thanks Luca Gobbo)
+
+2008-05-15, version 1.0rc1
+- nusoap_parser: handle case where Header or Body tags are used within SOAP messages (thanks Sergey Zhuravlev)
+
+2008-08-26, version 1.0rc1
+- wsdl: serialize simpleContent for complexType
+- wsdl: avoid serializing complexType elements with no value and minOccurs = 0 regardless of nillability
+
+2010-04-26, version 0.9.5
+- nusoap_xmlschema: replace regex function calls (ereg, eregi, split) with PCRE calls (preg_match, preg_split) (thanks Pier-Luc Duchaine)
+- wsdl: replace regex function calls (ereg, eregi, split) with PCRE calls (preg_match, preg_split) (thanks Pier-Luc Duchaine)
+- soap_transport_http: replace regex function calls (ereg, eregi, split) with PCRE calls (preg_match, preg_split) (thanks Pier-Luc Duchaine)
+- soap_transport_http: remove call to deprecated function set_magic_quotes_runtime
+- nusoap_server: replace regex function calls (ereg, eregi, split) with PCRE calls (preg_match, preg_split) (thanks Pier-Luc Duchaine)
+- nusoap_server: check that value is an object before calling get_class (thanks Pier-Luc Duchaine)
+- nusoap_parser: replace regex function calls (ereg, eregi, split) with PCRE calls (preg_match, preg_split) (thanks Pier-Luc Duchaine)
+- nusoap_client: replace regex function calls (ereg, eregi, split) with PCRE calls (preg_match, preg_split) (thanks Pier-Luc Duchaine)
+- nusoap_client: do not assign the return value of new by reference (it is deprecated) (thanks Pier-Luc Duchaine)
+- nusoap_base: replace regex function calls (ereg, eregi, split) with PCRE calls (preg_match, preg_split) (thanks Pier-Luc Duchaine)
+- nusoapmime: do not assign the return value of new by reference (it is deprecated)
diff -rNU5 spip-ori/ecrire/nusoap/class.nusoap_base.php spip/ecrire/nusoap/class.nusoap_base.php
--- spip-ori/ecrire/nusoap/class.nusoap_base.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nusoap/class.nusoap_base.php	2013-04-05 11:06:41.153923139 +0200
@@ -0,0 +1,996 @@
+<?php
+
+/*
+$Id: class.nusoap_base.php,v 1.56 2010/04/26 20:15:08 snichol Exp $
+
+NuSOAP - Web Services Toolkit for PHP
+
+Copyright (c) 2002 NuSphere Corporation
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The NuSOAP project home is:
+http://sourceforge.net/projects/nusoap/
+
+The primary support for NuSOAP is the Help forum on the project home page.
+
+If you have any questions or comments, please email:
+
+Dietrich Ayala
+dietrich@ganx4.com
+http://dietrich.ganx4.com/nusoap
+
+NuSphere Corporation
+http://www.nusphere.com
+
+*/
+
+/*
+ *	Some of the standards implmented in whole or part by NuSOAP:
+ *
+ *	SOAP 1.1 (http://www.w3.org/TR/2000/NOTE-SOAP-20000508/)
+ *	WSDL 1.1 (http://www.w3.org/TR/2001/NOTE-wsdl-20010315)
+ *	SOAP Messages With Attachments (http://www.w3.org/TR/SOAP-attachments)
+ *	XML 1.0 (http://www.w3.org/TR/2006/REC-xml-20060816/)
+ *	Namespaces in XML 1.0 (http://www.w3.org/TR/2006/REC-xml-names-20060816/)
+ *	XML Schema 1.0 (http://www.w3.org/TR/xmlschema-0/)
+ *	RFC 2045 Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies
+ *	RFC 2068 Hypertext Transfer Protocol -- HTTP/1.1
+ *	RFC 2617 HTTP Authentication: Basic and Digest Access Authentication
+ */
+
+/* load classes
+
+// necessary classes
+require_once('class.soapclient.php');
+require_once('class.soap_val.php');
+require_once('class.soap_parser.php');
+require_once('class.soap_fault.php');
+
+// transport classes
+require_once('class.soap_transport_http.php');
+
+// optional add-on classes
+require_once('class.xmlschema.php');
+require_once('class.wsdl.php');
+
+// server class
+require_once('class.soap_server.php');*/
+
+// class variable emulation
+// cf. http://www.webkreator.com/php/techniques/php-static-class-variables.html
+$GLOBALS['_transient']['static']['nusoap_base']['globalDebugLevel'] = 9;
+
+/**
+*
+* nusoap_base
+*
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @version  $Id: class.nusoap_base.php,v 1.56 2010/04/26 20:15:08 snichol Exp $
+* @access   public
+*/
+class nusoap_base {
+	/**
+	 * Identification for HTTP headers.
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $title = 'NuSOAP';
+	/**
+	 * Version for HTTP headers.
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $version = '0.9.5';
+	/**
+	 * CVS revision for HTTP headers.
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $revision = '$Revision: 1.56 $';
+    /**
+     * Current error string (manipulated by getError/setError)
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $error_str = '';
+    /**
+     * Current debug string (manipulated by debug/appendDebug/clearDebug/getDebug/getDebugAsXMLComment)
+	 *
+	 * @var string
+	 * @access private
+	 */
+    var $debug_str = '';
+    /**
+	 * toggles automatic encoding of special characters as entities
+	 * (should always be true, I think)
+	 *
+	 * @var boolean
+	 * @access private
+	 */
+	var $charencoding = true;
+	/**
+	 * the debug level for this instance
+	 *
+	 * @var	integer
+	 * @access private
+	 */
+	var $debugLevel;
+
+    /**
+	* set schema version
+	*
+	* @var      string
+	* @access   public
+	*/
+	var $XMLSchemaVersion = 'http://www.w3.org/2001/XMLSchema';
+	
+    /**
+	* charset encoding for outgoing messages
+	*
+	* @var      string
+	* @access   public
+	*/
+    var $soap_defencoding = 'ISO-8859-1';
+	//var $soap_defencoding = 'UTF-8';
+
+	/**
+	* namespaces in an array of prefix => uri
+	*
+	* this is "seeded" by a set of constants, but it may be altered by code
+	*
+	* @var      array
+	* @access   public
+	*/
+	var $namespaces = array(
+		'SOAP-ENV' => 'http://schemas.xmlsoap.org/soap/envelope/',
+		'xsd' => 'http://www.w3.org/2001/XMLSchema',
+		'xsi' => 'http://www.w3.org/2001/XMLSchema-instance',
+		'SOAP-ENC' => 'http://schemas.xmlsoap.org/soap/encoding/'
+		);
+
+	/**
+	* namespaces used in the current context, e.g. during serialization
+	*
+	* @var      array
+	* @access   private
+	*/
+	var $usedNamespaces = array();
+
+	/**
+	* XML Schema types in an array of uri => (array of xml type => php type)
+	* is this legacy yet?
+	* no, this is used by the nusoap_xmlschema class to verify type => namespace mappings.
+	* @var      array
+	* @access   public
+	*/
+	var $typemap = array(
+	'http://www.w3.org/2001/XMLSchema' => array(
+		'string'=>'string','boolean'=>'boolean','float'=>'double','double'=>'double','decimal'=>'double',
+		'duration'=>'','dateTime'=>'string','time'=>'string','date'=>'string','gYearMonth'=>'',
+		'gYear'=>'','gMonthDay'=>'','gDay'=>'','gMonth'=>'','hexBinary'=>'string','base64Binary'=>'string',
+		// abstract "any" types
+		'anyType'=>'string','anySimpleType'=>'string',
+		// derived datatypes
+		'normalizedString'=>'string','token'=>'string','language'=>'','NMTOKEN'=>'','NMTOKENS'=>'','Name'=>'','NCName'=>'','ID'=>'',
+		'IDREF'=>'','IDREFS'=>'','ENTITY'=>'','ENTITIES'=>'','integer'=>'integer','nonPositiveInteger'=>'integer',
+		'negativeInteger'=>'integer','long'=>'integer','int'=>'integer','short'=>'integer','byte'=>'integer','nonNegativeInteger'=>'integer',
+		'unsignedLong'=>'','unsignedInt'=>'','unsignedShort'=>'','unsignedByte'=>'','positiveInteger'=>''),
+	'http://www.w3.org/2000/10/XMLSchema' => array(
+		'i4'=>'','int'=>'integer','boolean'=>'boolean','string'=>'string','double'=>'double',
+		'float'=>'double','dateTime'=>'string',
+		'timeInstant'=>'string','base64Binary'=>'string','base64'=>'string','ur-type'=>'array'),
+	'http://www.w3.org/1999/XMLSchema' => array(
+		'i4'=>'','int'=>'integer','boolean'=>'boolean','string'=>'string','double'=>'double',
+		'float'=>'double','dateTime'=>'string',
+		'timeInstant'=>'string','base64Binary'=>'string','base64'=>'string','ur-type'=>'array'),
+	'http://soapinterop.org/xsd' => array('SOAPStruct'=>'struct'),
+	'http://schemas.xmlsoap.org/soap/encoding/' => array('base64'=>'string','array'=>'array','Array'=>'array'),
+    'http://xml.apache.org/xml-soap' => array('Map')
+	);
+
+	/**
+	* XML entities to convert
+	*
+	* @var      array
+	* @access   public
+	* @deprecated
+	* @see	expandEntities
+	*/
+	var $xmlEntities = array('quot' => '"','amp' => '&',
+		'lt' => '<','gt' => '>','apos' => "'");
+
+	/**
+	* constructor
+	*
+	* @access	public
+	*/
+	function nusoap_base() {
+		$this->debugLevel = $GLOBALS['_transient']['static']['nusoap_base']['globalDebugLevel'];
+	}
+
+	/**
+	* gets the global debug level, which applies to future instances
+	*
+	* @return	integer	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function getGlobalDebugLevel() {
+		return $GLOBALS['_transient']['static']['nusoap_base']['globalDebugLevel'];
+	}
+
+	/**
+	* sets the global debug level, which applies to future instances
+	*
+	* @param	int	$level	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function setGlobalDebugLevel($level) {
+		$GLOBALS['_transient']['static']['nusoap_base']['globalDebugLevel'] = $level;
+	}
+
+	/**
+	* gets the debug level for this instance
+	*
+	* @return	int	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function getDebugLevel() {
+		return $this->debugLevel;
+	}
+
+	/**
+	* sets the debug level for this instance
+	*
+	* @param	int	$level	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function setDebugLevel($level) {
+		$this->debugLevel = $level;
+	}
+
+	/**
+	* adds debug data to the instance debug string with formatting
+	*
+	* @param    string $string debug data
+	* @access   private
+	*/
+	function debug($string){
+		if ($this->debugLevel > 0) {
+			$this->appendDebug($this->getmicrotime().' '.get_class($this).": $string\n");
+		}
+	}
+
+	/**
+	* adds debug data to the instance debug string without formatting
+	*
+	* @param    string $string debug data
+	* @access   public
+	*/
+	function appendDebug($string){
+		if ($this->debugLevel > 0) {
+			// it would be nice to use a memory stream here to use
+			// memory more efficiently
+			$this->debug_str .= $string;
+		}
+	}
+
+	/**
+	* clears the current debug data for this instance
+	*
+	* @access   public
+	*/
+	function clearDebug() {
+		// it would be nice to use a memory stream here to use
+		// memory more efficiently
+		$this->debug_str = '';
+	}
+
+	/**
+	* gets the current debug data for this instance
+	*
+	* @return   debug data
+	* @access   public
+	*/
+	function &getDebug() {
+		// it would be nice to use a memory stream here to use
+		// memory more efficiently
+		return $this->debug_str;
+	}
+
+	/**
+	* gets the current debug data for this instance as an XML comment
+	* this may change the contents of the debug data
+	*
+	* @return   debug data as an XML comment
+	* @access   public
+	*/
+	function &getDebugAsXMLComment() {
+		// it would be nice to use a memory stream here to use
+		// memory more efficiently
+		while (strpos($this->debug_str, '--')) {
+			$this->debug_str = str_replace('--', '- -', $this->debug_str);
+		}
+		$ret = "<!--\n" . $this->debug_str . "\n-->";
+    	return $ret;
+	}
+
+	/**
+	* expands entities, e.g. changes '<' to '&lt;'.
+	*
+	* @param	string	$val	The string in which to expand entities.
+	* @access	private
+	*/
+	function expandEntities($val) {
+		if ($this->charencoding) {
+	    	$val = str_replace('&', '&amp;', $val);
+	    	$val = str_replace("'", '&apos;', $val);
+	    	$val = str_replace('"', '&quot;', $val);
+	    	$val = str_replace('<', '&lt;', $val);
+	    	$val = str_replace('>', '&gt;', $val);
+	    }
+	    return $val;
+	}
+
+	/**
+	* returns error string if present
+	*
+	* @return   mixed error string or false
+	* @access   public
+	*/
+	function getError(){
+		if($this->error_str != ''){
+			return $this->error_str;
+		}
+		return false;
+	}
+
+	/**
+	* sets error string
+	*
+	* @return   boolean $string error string
+	* @access   private
+	*/
+	function setError($str){
+		$this->error_str = $str;
+	}
+
+	/**
+	* detect if array is a simple array or a struct (associative array)
+	*
+	* @param	mixed	$val	The PHP array
+	* @return	string	(arraySimple|arrayStruct)
+	* @access	private
+	*/
+	function isArraySimpleOrStruct($val) {
+        $keyList = array_keys($val);
+		foreach ($keyList as $keyListValue) {
+			if (!is_int($keyListValue)) {
+				return 'arrayStruct';
+			}
+		}
+		return 'arraySimple';
+	}
+
+	/**
+	* serializes PHP values in accordance w/ section 5. Type information is
+	* not serialized if $use == 'literal'.
+	*
+	* @param	mixed	$val	The value to serialize
+	* @param	string	$name	The name (local part) of the XML element
+	* @param	string	$type	The XML schema type (local part) for the element
+	* @param	string	$name_ns	The namespace for the name of the XML element
+	* @param	string	$type_ns	The namespace for the type of the element
+	* @param	array	$attributes	The attributes to serialize as name=>value pairs
+	* @param	string	$use	The WSDL "use" (encoded|literal)
+	* @param	boolean	$soapval	Whether this is called from soapval.
+	* @return	string	The serialized element, possibly with child elements
+    * @access	public
+	*/
+	function serialize_val($val,$name=false,$type=false,$name_ns=false,$type_ns=false,$attributes=false,$use='encoded',$soapval=false) {
+		$this->debug("in serialize_val: name=$name, type=$type, name_ns=$name_ns, type_ns=$type_ns, use=$use, soapval=$soapval");
+		$this->appendDebug('value=' . $this->varDump($val));
+		$this->appendDebug('attributes=' . $this->varDump($attributes));
+		
+    	if (is_object($val) && get_class($val) == 'soapval' && (! $soapval)) {
+    		$this->debug("serialize_val: serialize soapval");
+        	$xml = $val->serialize($use);
+			$this->appendDebug($val->getDebug());
+			$val->clearDebug();
+			$this->debug("serialize_val of soapval returning $xml");
+			return $xml;
+        }
+		// force valid name if necessary
+		if (is_numeric($name)) {
+			$name = '__numeric_' . $name;
+		} elseif (! $name) {
+			$name = 'noname';
+		}
+		// if name has ns, add ns prefix to name
+		$xmlns = '';
+        if($name_ns){
+			$prefix = 'nu'.rand(1000,9999);
+			$name = $prefix.':'.$name;
+			$xmlns .= " xmlns:$prefix=\"$name_ns\"";
+		}
+		// if type is prefixed, create type prefix
+		if($type_ns != '' && $type_ns == $this->namespaces['xsd']){
+			// need to fix this. shouldn't default to xsd if no ns specified
+		    // w/o checking against typemap
+			$type_prefix = 'xsd';
+		} elseif($type_ns){
+			$type_prefix = 'ns'.rand(1000,9999);
+			$xmlns .= " xmlns:$type_prefix=\"$type_ns\"";
+		}
+		// serialize attributes if present
+		$atts = '';
+		if($attributes){
+			foreach($attributes as $k => $v){
+				$atts .= " $k=\"".$this->expandEntities($v).'"';
+			}
+		}
+		// serialize null value
+		if (is_null($val)) {
+    		$this->debug("serialize_val: serialize null");
+			if ($use == 'literal') {
+				// TODO: depends on minOccurs
+				$xml = "<$name$xmlns$atts/>";
+				$this->debug("serialize_val returning $xml");
+	        	return $xml;
+        	} else {
+				if (isset($type) && isset($type_prefix)) {
+					$type_str = " xsi:type=\"$type_prefix:$type\"";
+				} else {
+					$type_str = '';
+				}
+				$xml = "<$name$xmlns$type_str$atts xsi:nil=\"true\"/>";
+				$this->debug("serialize_val returning $xml");
+	        	return $xml;
+        	}
+		}
+        // serialize if an xsd built-in primitive type
+        if($type != '' && isset($this->typemap[$this->XMLSchemaVersion][$type])){
+    		$this->debug("serialize_val: serialize xsd built-in primitive type");
+        	if (is_bool($val)) {
+        		if ($type == 'boolean') {
+	        		$val = $val ? 'true' : 'false';
+	        	} elseif (! $val) {
+	        		$val = 0;
+	        	}
+			} else if (is_string($val)) {
+				$val = $this->expandEntities($val);
+			}
+			if ($use == 'literal') {
+				$xml = "<$name$xmlns$atts>$val</$name>";
+				$this->debug("serialize_val returning $xml");
+	        	return $xml;
+        	} else {
+				$xml = "<$name$xmlns xsi:type=\"xsd:$type\"$atts>$val</$name>";
+				$this->debug("serialize_val returning $xml");
+	        	return $xml;
+        	}
+        }
+		// detect type and serialize
+		$xml = '';
+		switch(true) {
+			case (is_bool($val) || $type == 'boolean'):
+		   		$this->debug("serialize_val: serialize boolean");
+        		if ($type == 'boolean') {
+	        		$val = $val ? 'true' : 'false';
+	        	} elseif (! $val) {
+	        		$val = 0;
+	        	}
+				if ($use == 'literal') {
+					$xml .= "<$name$xmlns$atts>$val</$name>";
+				} else {
+					$xml .= "<$name$xmlns xsi:type=\"xsd:boolean\"$atts>$val</$name>";
+				}
+				break;
+			case (is_int($val) || is_long($val) || $type == 'int'):
+		   		$this->debug("serialize_val: serialize int");
+				if ($use == 'literal') {
+					$xml .= "<$name$xmlns$atts>$val</$name>";
+				} else {
+					$xml .= "<$name$xmlns xsi:type=\"xsd:int\"$atts>$val</$name>";
+				}
+				break;
+			case (is_float($val)|| is_double($val) || $type == 'float'):
+		   		$this->debug("serialize_val: serialize float");
+				if ($use == 'literal') {
+					$xml .= "<$name$xmlns$atts>$val</$name>";
+				} else {
+					$xml .= "<$name$xmlns xsi:type=\"xsd:float\"$atts>$val</$name>";
+				}
+				break;
+			case (is_string($val) || $type == 'string'):
+		   		$this->debug("serialize_val: serialize string");
+				$val = $this->expandEntities($val);
+				if ($use == 'literal') {
+					$xml .= "<$name$xmlns$atts>$val</$name>";
+				} else {
+					$xml .= "<$name$xmlns xsi:type=\"xsd:string\"$atts>$val</$name>";
+				}
+				break;
+			case is_object($val):
+		   		$this->debug("serialize_val: serialize object");
+		    	if (get_class($val) == 'soapval') {
+		    		$this->debug("serialize_val: serialize soapval object");
+		        	$pXml = $val->serialize($use);
+					$this->appendDebug($val->getDebug());
+					$val->clearDebug();
+		        } else {
+					if (! $name) {
+						$name = get_class($val);
+						$this->debug("In serialize_val, used class name $name as element name");
+					} else {
+						$this->debug("In serialize_val, do not override name $name for element name for class " . get_class($val));
+					}
+					foreach(get_object_vars($val) as $k => $v){
+						$pXml = isset($pXml) ? $pXml.$this->serialize_val($v,$k,false,false,false,false,$use) : $this->serialize_val($v,$k,false,false,false,false,$use);
+					}
+				}
+				if(isset($type) && isset($type_prefix)){
+					$type_str = " xsi:type=\"$type_prefix:$type\"";
+				} else {
+					$type_str = '';
+				}
+				if ($use == 'literal') {
+					$xml .= "<$name$xmlns$atts>$pXml</$name>";
+				} else {
+					$xml .= "<$name$xmlns$type_str$atts>$pXml</$name>";
+				}
+				break;
+			break;
+			case (is_array($val) || $type):
+				// detect if struct or array
+				$valueType = $this->isArraySimpleOrStruct($val);
+                if($valueType=='arraySimple' || preg_match('/^ArrayOf/',$type)){
+			   		$this->debug("serialize_val: serialize array");
+					$i = 0;
+					if(is_array($val) && count($val)> 0){
+						foreach($val as $v){
+	                    	if(is_object($v) && get_class($v) ==  'soapval'){
+								$tt_ns = $v->type_ns;
+								$tt = $v->type;
+							} elseif (is_array($v)) {
+								$tt = $this->isArraySimpleOrStruct($v);
+							} else {
+								$tt = gettype($v);
+	                        }
+							$array_types[$tt] = 1;
+							// TODO: for literal, the name should be $name
+							$xml .= $this->serialize_val($v,'item',false,false,false,false,$use);
+							++$i;
+						}
+						if(count($array_types) > 1){
+							$array_typename = 'xsd:anyType';
+						} elseif(isset($tt) && isset($this->typemap[$this->XMLSchemaVersion][$tt])) {
+							if ($tt == 'integer') {
+								$tt = 'int';
+							}
+							$array_typename = 'xsd:'.$tt;
+						} elseif(isset($tt) && $tt == 'arraySimple'){
+							$array_typename = 'SOAP-ENC:Array';
+						} elseif(isset($tt) && $tt == 'arrayStruct'){
+							$array_typename = 'unnamed_struct_use_soapval';
+						} else {
+							// if type is prefixed, create type prefix
+							if ($tt_ns != '' && $tt_ns == $this->namespaces['xsd']){
+								 $array_typename = 'xsd:' . $tt;
+							} elseif ($tt_ns) {
+								$tt_prefix = 'ns' . rand(1000, 9999);
+								$array_typename = "$tt_prefix:$tt";
+								$xmlns .= " xmlns:$tt_prefix=\"$tt_ns\"";
+							} else {
+								$array_typename = $tt;
+							}
+						}
+						$array_type = $i;
+						if ($use == 'literal') {
+							$type_str = '';
+						} else if (isset($type) && isset($type_prefix)) {
+							$type_str = " xsi:type=\"$type_prefix:$type\"";
+						} else {
+							$type_str = " xsi:type=\"SOAP-ENC:Array\" SOAP-ENC:arrayType=\"".$array_typename."[$array_type]\"";
+						}
+					// empty array
+					} else {
+						if ($use == 'literal') {
+							$type_str = '';
+						} else if (isset($type) && isset($type_prefix)) {
+							$type_str = " xsi:type=\"$type_prefix:$type\"";
+						} else {
+							$type_str = " xsi:type=\"SOAP-ENC:Array\" SOAP-ENC:arrayType=\"xsd:anyType[0]\"";
+						}
+					}
+					// TODO: for array in literal, there is no wrapper here
+					$xml = "<$name$xmlns$type_str$atts>".$xml."</$name>";
+				} else {
+					// got a struct
+			   		$this->debug("serialize_val: serialize struct");
+					if(isset($type) && isset($type_prefix)){
+						$type_str = " xsi:type=\"$type_prefix:$type\"";
+					} else {
+						$type_str = '';
+					}
+					if ($use == 'literal') {
+						$xml .= "<$name$xmlns$atts>";
+					} else {
+						$xml .= "<$name$xmlns$type_str$atts>";
+					}
+					foreach($val as $k => $v){
+						// Apache Map
+						if ($type == 'Map' && $type_ns == 'http://xml.apache.org/xml-soap') {
+							$xml .= '<item>';
+							$xml .= $this->serialize_val($k,'key',false,false,false,false,$use);
+							$xml .= $this->serialize_val($v,'value',false,false,false,false,$use);
+							$xml .= '</item>';
+						} else {
+							$xml .= $this->serialize_val($v,$k,false,false,false,false,$use);
+						}
+					}
+					$xml .= "</$name>";
+				}
+				break;
+			default:
+		   		$this->debug("serialize_val: serialize unknown");
+				$xml .= 'not detected, got '.gettype($val).' for '.$val;
+				break;
+		}
+		$this->debug("serialize_val returning $xml");
+		return $xml;
+	}
+
+    /**
+    * serializes a message
+    *
+    * @param string $body the XML of the SOAP body
+    * @param mixed $headers optional string of XML with SOAP header content, or array of soapval objects for SOAP headers, or associative array
+    * @param array $namespaces optional the namespaces used in generating the body and headers
+    * @param string $style optional (rpc|document)
+    * @param string $use optional (encoded|literal)
+    * @param string $encodingStyle optional (usually 'http://schemas.xmlsoap.org/soap/encoding/' for encoded)
+    * @return string the message
+    * @access public
+    */
+    function serializeEnvelope($body,$headers=false,$namespaces=array(),$style='rpc',$use='encoded',$encodingStyle='http://schemas.xmlsoap.org/soap/encoding/'){
+    // TODO: add an option to automatically run utf8_encode on $body and $headers
+    // if $this->soap_defencoding is UTF-8.  Not doing this automatically allows
+    // one to send arbitrary UTF-8 characters, not just characters that map to ISO-8859-1
+
+	$this->debug("In serializeEnvelope length=" . strlen($body) . " body (max 1000 characters)=" . substr($body, 0, 1000) . " style=$style use=$use encodingStyle=$encodingStyle");
+	$this->debug("headers:");
+	$this->appendDebug($this->varDump($headers));
+	$this->debug("namespaces:");
+	$this->appendDebug($this->varDump($namespaces));
+
+	// serialize namespaces
+    $ns_string = '';
+	foreach(array_merge($this->namespaces,$namespaces) as $k => $v){
+		$ns_string .= " xmlns:$k=\"$v\"";
+	}
+	if($encodingStyle) {
+		$ns_string = " SOAP-ENV:encodingStyle=\"$encodingStyle\"$ns_string";
+	}
+
+	// serialize headers
+	if($headers){
+		if (is_array($headers)) {
+			$xml = '';
+			foreach ($headers as $k => $v) {
+				if (is_object($v) && get_class($v) == 'soapval') {
+					$xml .= $this->serialize_val($v, false, false, false, false, false, $use);
+				} else {
+					$xml .= $this->serialize_val($v, $k, false, false, false, false, $use);
+				}
+			}
+			$headers = $xml;
+			$this->debug("In serializeEnvelope, serialized array of headers to $headers");
+		}
+		$headers = "<SOAP-ENV:Header>".$headers."</SOAP-ENV:Header>";
+	}
+	// serialize envelope
+	return
+	'<?xml version="1.0" encoding="'.$this->soap_defencoding .'"?'.">".
+	'<SOAP-ENV:Envelope'.$ns_string.">".
+	$headers.
+	"<SOAP-ENV:Body>".
+		$body.
+	"</SOAP-ENV:Body>".
+	"</SOAP-ENV:Envelope>";
+    }
+
+	/**
+	 * formats a string to be inserted into an HTML stream
+	 *
+	 * @param string $str The string to format
+	 * @return string The formatted string
+	 * @access public
+	 * @deprecated
+	 */
+    function formatDump($str){
+		$str = htmlspecialchars($str);
+		return nl2br($str);
+    }
+
+	/**
+	* contracts (changes namespace to prefix) a qualified name
+	*
+	* @param    string $qname qname
+	* @return	string contracted qname
+	* @access   private
+	*/
+	function contractQname($qname){
+		// get element namespace
+		//$this->xdebug("Contract $qname");
+		if (strrpos($qname, ':')) {
+			// get unqualified name
+			$name = substr($qname, strrpos($qname, ':') + 1);
+			// get ns
+			$ns = substr($qname, 0, strrpos($qname, ':'));
+			$p = $this->getPrefixFromNamespace($ns);
+			if ($p) {
+				return $p . ':' . $name;
+			}
+			return $qname;
+		} else {
+			return $qname;
+		}
+	}
+
+	/**
+	* expands (changes prefix to namespace) a qualified name
+	*
+	* @param    string $qname qname
+	* @return	string expanded qname
+	* @access   private
+	*/
+	function expandQname($qname){
+		// get element prefix
+		if(strpos($qname,':') && !preg_match('/^http:\/\//',$qname)){
+			// get unqualified name
+			$name = substr(strstr($qname,':'),1);
+			// get ns prefix
+			$prefix = substr($qname,0,strpos($qname,':'));
+			if(isset($this->namespaces[$prefix])){
+				return $this->namespaces[$prefix].':'.$name;
+			} else {
+				return $qname;
+			}
+		} else {
+			return $qname;
+		}
+	}
+
+    /**
+    * returns the local part of a prefixed string
+    * returns the original string, if not prefixed
+    *
+    * @param string $str The prefixed string
+    * @return string The local part
+    * @access public
+    */
+	function getLocalPart($str){
+		if($sstr = strrchr($str,':')){
+			// get unqualified name
+			return substr( $sstr, 1 );
+		} else {
+			return $str;
+		}
+	}
+
+	/**
+    * returns the prefix part of a prefixed string
+    * returns false, if not prefixed
+    *
+    * @param string $str The prefixed string
+    * @return mixed The prefix or false if there is no prefix
+    * @access public
+    */
+	function getPrefix($str){
+		if($pos = strrpos($str,':')){
+			// get prefix
+			return substr($str,0,$pos);
+		}
+		return false;
+	}
+
+	/**
+    * pass it a prefix, it returns a namespace
+    *
+    * @param string $prefix The prefix
+    * @return mixed The namespace, false if no namespace has the specified prefix
+    * @access public
+    */
+	function getNamespaceFromPrefix($prefix){
+		if (isset($this->namespaces[$prefix])) {
+			return $this->namespaces[$prefix];
+		}
+		//$this->setError("No namespace registered for prefix '$prefix'");
+		return false;
+	}
+
+	/**
+    * returns the prefix for a given namespace (or prefix)
+    * or false if no prefixes registered for the given namespace
+    *
+    * @param string $ns The namespace
+    * @return mixed The prefix, false if the namespace has no prefixes
+    * @access public
+    */
+	function getPrefixFromNamespace($ns) {
+		foreach ($this->namespaces as $p => $n) {
+			if ($ns == $n || $ns == $p) {
+			    $this->usedNamespaces[$p] = $n;
+				return $p;
+			}
+		}
+		return false;
+	}
+
+	/**
+    * returns the time in ODBC canonical form with microseconds
+    *
+    * @return string The time in ODBC canonical form with microseconds
+    * @access public
+    */
+	function getmicrotime() {
+		if (function_exists('gettimeofday')) {
+			$tod = gettimeofday();
+			$sec = $tod['sec'];
+			$usec = $tod['usec'];
+		} else {
+			$sec = time();
+			$usec = 0;
+		}
+		return strftime('%Y-%m-%d %H:%M:%S', $sec) . '.' . sprintf('%06d', $usec);
+	}
+
+	/**
+	 * Returns a string with the output of var_dump
+	 *
+	 * @param mixed $data The variable to var_dump
+	 * @return string The output of var_dump
+	 * @access public
+	 */
+    function varDump($data) {
+		ob_start();
+		var_dump($data);
+		$ret_val = ob_get_contents();
+		ob_end_clean();
+		return $ret_val;
+	}
+
+	/**
+	* represents the object as a string
+	*
+	* @return	string
+	* @access   public
+	*/
+	function __toString() {
+		return $this->varDump($this);
+	}
+}
+
+// XML Schema Datatype Helper Functions
+
+//xsd:dateTime helpers
+
+/**
+* convert unix timestamp to ISO 8601 compliant date string
+*
+* @param    int $timestamp Unix time stamp
+* @param	boolean $utc Whether the time stamp is UTC or local
+* @return	mixed ISO 8601 date string or false
+* @access   public
+*/
+function timestamp_to_iso8601($timestamp,$utc=true){
+	$datestr = date('Y-m-d\TH:i:sO',$timestamp);
+	$pos = strrpos($datestr, "+");
+	if ($pos === FALSE) {
+		$pos = strrpos($datestr, "-");
+	}
+	if ($pos !== FALSE) {
+		if (strlen($datestr) == $pos + 5) {
+			$datestr = substr($datestr, 0, $pos + 3) . ':' . substr($datestr, -2);
+		}
+	}
+	if($utc){
+		$pattern = '/'.
+		'([0-9]{4})-'.	// centuries & years CCYY-
+		'([0-9]{2})-'.	// months MM-
+		'([0-9]{2})'.	// days DD
+		'T'.			// separator T
+		'([0-9]{2}):'.	// hours hh:
+		'([0-9]{2}):'.	// minutes mm:
+		'([0-9]{2})(\.[0-9]*)?'. // seconds ss.ss...
+		'(Z|[+\-][0-9]{2}:?[0-9]{2})?'. // Z to indicate UTC, -/+HH:MM:SS.SS... for local tz's
+		'/';
+
+		if(preg_match($pattern,$datestr,$regs)){
+			return sprintf('%04d-%02d-%02dT%02d:%02d:%02dZ',$regs[1],$regs[2],$regs[3],$regs[4],$regs[5],$regs[6]);
+		}
+		return false;
+	} else {
+		return $datestr;
+	}
+}
+
+/**
+* convert ISO 8601 compliant date string to unix timestamp
+*
+* @param    string $datestr ISO 8601 compliant date string
+* @return	mixed Unix timestamp (int) or false
+* @access   public
+*/
+function iso8601_to_timestamp($datestr){
+	$pattern = '/'.
+	'([0-9]{4})-'.	// centuries & years CCYY-
+	'([0-9]{2})-'.	// months MM-
+	'([0-9]{2})'.	// days DD
+	'T'.			// separator T
+	'([0-9]{2}):'.	// hours hh:
+	'([0-9]{2}):'.	// minutes mm:
+	'([0-9]{2})(\.[0-9]+)?'. // seconds ss.ss...
+	'(Z|[+\-][0-9]{2}:?[0-9]{2})?'. // Z to indicate UTC, -/+HH:MM:SS.SS... for local tz's
+	'/';
+	if(preg_match($pattern,$datestr,$regs)){
+		// not utc
+		if($regs[8] != 'Z'){
+			$op = substr($regs[8],0,1);
+			$h = substr($regs[8],1,2);
+			$m = substr($regs[8],strlen($regs[8])-2,2);
+			if($op == '-'){
+				$regs[4] = $regs[4] + $h;
+				$regs[5] = $regs[5] + $m;
+			} elseif($op == '+'){
+				$regs[4] = $regs[4] - $h;
+				$regs[5] = $regs[5] - $m;
+			}
+		}
+		return gmmktime($regs[4], $regs[5], $regs[6], $regs[2], $regs[3], $regs[1]);
+//		return strtotime("$regs[1]-$regs[2]-$regs[3] $regs[4]:$regs[5]:$regs[6]Z");
+	} else {
+		return false;
+	}
+}
+
+/**
+* sleeps some number of microseconds
+*
+* @param    string $usec the number of microseconds to sleep
+* @access   public
+* @deprecated
+*/
+function usleepWindows($usec)
+{
+	$start = gettimeofday();
+	
+	do
+	{
+		$stop = gettimeofday();
+		$timePassed = 1000000 * ($stop['sec'] - $start['sec'])
+		+ $stop['usec'] - $start['usec'];
+	}
+	while ($timePassed < $usec);
+}
+
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/ecrire/nusoap/class.soapclient.php spip/ecrire/nusoap/class.soapclient.php
--- spip-ori/ecrire/nusoap/class.soapclient.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nusoap/class.soapclient.php	2013-04-05 11:06:41.153923139 +0200
@@ -0,0 +1,991 @@
+<?php
+
+
+
+
+/**
+*
+* [nu]soapclient higher level class for easy usage.
+*
+* usage:
+*
+* // instantiate client with server info
+* $soapclient = new nusoap_client( string path [ ,mixed wsdl] );
+*
+* // call method, get results
+* echo $soapclient->call( string methodname [ ,array parameters] );
+*
+* // bye bye client
+* unset($soapclient);
+*
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @version  $Id: class.soapclient.php,v 1.69 2010/04/26 20:15:08 snichol Exp $
+* @access   public
+*/
+class nusoap_client extends nusoap_base  {
+
+	var $username = '';				// Username for HTTP authentication
+	var $password = '';				// Password for HTTP authentication
+	var $authtype = '';				// Type of HTTP authentication
+	var $certRequest = array();		// Certificate for HTTP SSL authentication
+	var $requestHeaders = false;	// SOAP headers in request (text)
+	var $responseHeaders = '';		// SOAP headers from response (incomplete namespace resolution) (text)
+	var $responseHeader = NULL;		// SOAP Header from response (parsed)
+	var $document = '';				// SOAP body response portion (incomplete namespace resolution) (text)
+	var $endpoint;
+	var $forceEndpoint = '';		// overrides WSDL endpoint
+    var $proxyhost = '';
+    var $proxyport = '';
+	var $proxyusername = '';
+	var $proxypassword = '';
+	var $portName = '';				// port name to use in WSDL
+    var $xml_encoding = '';			// character set encoding of incoming (response) messages
+	var $http_encoding = false;
+	var $timeout = 0;				// HTTP connection timeout
+	var $response_timeout = 30;		// HTTP response timeout
+	var $endpointType = '';			// soap|wsdl, empty for WSDL initialization error
+	var $persistentConnection = false;
+	var $defaultRpcParams = false;	// This is no longer used
+	var $request = '';				// HTTP request
+	var $response = '';				// HTTP response
+	var $responseData = '';			// SOAP payload of response
+	var $cookies = array();			// Cookies from response or for request
+    var $decode_utf8 = true;		// toggles whether the parser decodes element content w/ utf8_decode()
+	var $operations = array();		// WSDL operations, empty for WSDL initialization error
+	var $curl_options = array();	// User-specified cURL options
+	var $bindingType = '';			// WSDL operation binding type
+	var $use_curl = false;			// whether to always try to use cURL
+
+	/*
+	 * fault related variables
+	 */
+	/**
+	 * @var      fault
+	 * @access   public
+	 */
+	var $fault;
+	/**
+	 * @var      faultcode
+	 * @access   public
+	 */
+	var $faultcode;
+	/**
+	 * @var      faultstring
+	 * @access   public
+	 */
+	var $faultstring;
+	/**
+	 * @var      faultdetail
+	 * @access   public
+	 */
+	var $faultdetail;
+
+	/**
+	* constructor
+	*
+	* @param    mixed $endpoint SOAP server or WSDL URL (string), or wsdl instance (object)
+	* @param    mixed $wsdl optional, set to 'wsdl' or true if using WSDL
+	* @param    string $proxyhost optional
+	* @param    string $proxyport optional
+	* @param	string $proxyusername optional
+	* @param	string $proxypassword optional
+	* @param	integer $timeout set the connection timeout
+	* @param	integer $response_timeout set the response timeout
+	* @param	string $portName optional portName in WSDL document
+	* @access   public
+	*/
+	function nusoap_client($endpoint,$wsdl = false,$proxyhost = false,$proxyport = false,$proxyusername = false, $proxypassword = false, $timeout = 0, $response_timeout = 30, $portName = ''){
+		parent::nusoap_base();
+		$this->endpoint = $endpoint;
+		$this->proxyhost = $proxyhost;
+		$this->proxyport = $proxyport;
+		$this->proxyusername = $proxyusername;
+		$this->proxypassword = $proxypassword;
+		$this->timeout = $timeout;
+		$this->response_timeout = $response_timeout;
+		$this->portName = $portName;
+
+		$this->debug("ctor wsdl=$wsdl timeout=$timeout response_timeout=$response_timeout");
+		$this->appendDebug('endpoint=' . $this->varDump($endpoint));
+
+		// make values
+		if($wsdl){
+			if (is_object($endpoint) && (get_class($endpoint) == 'wsdl')) {
+				$this->wsdl = $endpoint;
+				$this->endpoint = $this->wsdl->wsdl;
+				$this->wsdlFile = $this->endpoint;
+				$this->debug('existing wsdl instance created from ' . $this->endpoint);
+				$this->checkWSDL();
+			} else {
+				$this->wsdlFile = $this->endpoint;
+				$this->wsdl = null;
+				$this->debug('will use lazy evaluation of wsdl from ' . $this->endpoint);
+			}
+			$this->endpointType = 'wsdl';
+		} else {
+			$this->debug("instantiate SOAP with endpoint at $endpoint");
+			$this->endpointType = 'soap';
+		}
+	}
+
+	/**
+	* calls method, returns PHP native type
+	*
+	* @param    string $operation SOAP server URL or path
+	* @param    mixed $params An array, associative or simple, of the parameters
+	*			              for the method call, or a string that is the XML
+	*			              for the call.  For rpc style, this call will
+	*			              wrap the XML in a tag named after the method, as
+	*			              well as the SOAP Envelope and Body.  For document
+	*			              style, this will only wrap with the Envelope and Body.
+	*			              IMPORTANT: when using an array with document style,
+	*			              in which case there
+	*                         is really one parameter, the root of the fragment
+	*                         used in the call, which encloses what programmers
+	*                         normally think of parameters.  A parameter array
+	*                         *must* include the wrapper.
+	* @param	string $namespace optional method namespace (WSDL can override)
+	* @param	string $soapAction optional SOAPAction value (WSDL can override)
+	* @param	mixed $headers optional string of XML with SOAP header content, or array of soapval objects for SOAP headers, or associative array
+	* @param	boolean $rpcParams optional (no longer used)
+	* @param	string	$style optional (rpc|document) the style to use when serializing parameters (WSDL can override)
+	* @param	string	$use optional (encoded|literal) the use when serializing parameters (WSDL can override)
+	* @return	mixed	response from SOAP call, normally an associative array mirroring the structure of the XML response, false for certain fatal errors
+	* @access   public
+	*/
+	function call($operation,$params=array(),$namespace='http://tempuri.org',$soapAction='',$headers=false,$rpcParams=null,$style='rpc',$use='encoded'){
+		$this->operation = $operation;
+		$this->fault = false;
+		$this->setError('');
+		$this->request = '';
+		$this->response = '';
+		$this->responseData = '';
+		$this->faultstring = '';
+		$this->faultcode = '';
+		$this->opData = array();
+		
+		$this->debug("call: operation=$operation, namespace=$namespace, soapAction=$soapAction, rpcParams=$rpcParams, style=$style, use=$use, endpointType=$this->endpointType");
+		$this->appendDebug('params=' . $this->varDump($params));
+		$this->appendDebug('headers=' . $this->varDump($headers));
+		if ($headers) {
+			$this->requestHeaders = $headers;
+		}
+		if ($this->endpointType == 'wsdl' && is_null($this->wsdl)) {
+			$this->loadWSDL();
+			if ($this->getError())
+				return false;
+		}
+		// serialize parameters
+		if($this->endpointType == 'wsdl' && $opData = $this->getOperationData($operation)){
+			// use WSDL for operation
+			$this->opData = $opData;
+			$this->debug("found operation");
+			$this->appendDebug('opData=' . $this->varDump($opData));
+			if (isset($opData['soapAction'])) {
+				$soapAction = $opData['soapAction'];
+			}
+			if (! $this->forceEndpoint) {
+				$this->endpoint = $opData['endpoint'];
+			} else {
+				$this->endpoint = $this->forceEndpoint;
+			}
+			$namespace = isset($opData['input']['namespace']) ? $opData['input']['namespace'] :	$namespace;
+			$style = $opData['style'];
+			$use = $opData['input']['use'];
+			// add ns to ns array
+			if($namespace != '' && !isset($this->wsdl->namespaces[$namespace])){
+				$nsPrefix = 'ns' . rand(1000, 9999);
+				$this->wsdl->namespaces[$nsPrefix] = $namespace;
+			}
+            $nsPrefix = $this->wsdl->getPrefixFromNamespace($namespace);
+			// serialize payload
+			if (is_string($params)) {
+				$this->debug("serializing param string for WSDL operation $operation");
+				$payload = $params;
+			} elseif (is_array($params)) {
+				$this->debug("serializing param array for WSDL operation $operation");
+				$payload = $this->wsdl->serializeRPCParameters($operation,'input',$params,$this->bindingType);
+			} else {
+				$this->debug('params must be array or string');
+				$this->setError('params must be array or string');
+				return false;
+			}
+            $usedNamespaces = $this->wsdl->usedNamespaces;
+			if (isset($opData['input']['encodingStyle'])) {
+				$encodingStyle = $opData['input']['encodingStyle'];
+			} else {
+				$encodingStyle = '';
+			}
+			$this->appendDebug($this->wsdl->getDebug());
+			$this->wsdl->clearDebug();
+			if ($errstr = $this->wsdl->getError()) {
+				$this->debug('got wsdl error: '.$errstr);
+				$this->setError('wsdl error: '.$errstr);
+				return false;
+			}
+		} elseif($this->endpointType == 'wsdl') {
+			// operation not in WSDL
+			$this->appendDebug($this->wsdl->getDebug());
+			$this->wsdl->clearDebug();
+			$this->setError('operation '.$operation.' not present in WSDL.');
+			$this->debug("operation '$operation' not present in WSDL.");
+			return false;
+		} else {
+			// no WSDL
+			//$this->namespaces['ns1'] = $namespace;
+			$nsPrefix = 'ns' . rand(1000, 9999);
+			// serialize 
+			$payload = '';
+			if (is_string($params)) {
+				$this->debug("serializing param string for operation $operation");
+				$payload = $params;
+			} elseif (is_array($params)) {
+				$this->debug("serializing param array for operation $operation");
+				foreach($params as $k => $v){
+					$payload .= $this->serialize_val($v,$k,false,false,false,false,$use);
+				}
+			} else {
+				$this->debug('params must be array or string');
+				$this->setError('params must be array or string');
+				return false;
+			}
+			$usedNamespaces = array();
+			if ($use == 'encoded') {
+				$encodingStyle = 'http://schemas.xmlsoap.org/soap/encoding/';
+			} else {
+				$encodingStyle = '';
+			}
+		}
+		// wrap RPC calls with method element
+		if ($style == 'rpc') {
+			if ($use == 'literal') {
+				$this->debug("wrapping RPC request with literal method element");
+				if ($namespace) {
+					// http://www.ws-i.org/Profiles/BasicProfile-1.1-2004-08-24.html R2735 says rpc/literal accessor elements should not be in a namespace
+					$payload = "<$nsPrefix:$operation xmlns:$nsPrefix=\"$namespace\">" .
+								$payload .
+								"</$nsPrefix:$operation>";
+				} else {
+					$payload = "<$operation>" . $payload . "</$operation>";
+				}
+			} else {
+				$this->debug("wrapping RPC request with encoded method element");
+				if ($namespace) {
+					$payload = "<$nsPrefix:$operation xmlns:$nsPrefix=\"$namespace\">" .
+								$payload .
+								"</$nsPrefix:$operation>";
+				} else {
+					$payload = "<$operation>" .
+								$payload .
+								"</$operation>";
+				}
+			}
+		}
+		// serialize envelope
+		$soapmsg = $this->serializeEnvelope($payload,$this->requestHeaders,$usedNamespaces,$style,$use,$encodingStyle);
+		$this->debug("endpoint=$this->endpoint, soapAction=$soapAction, namespace=$namespace, style=$style, use=$use, encodingStyle=$encodingStyle");
+		$this->debug('SOAP message length=' . strlen($soapmsg) . ' contents (max 1000 bytes)=' . substr($soapmsg, 0, 1000));
+		// send
+		$return = $this->send($this->getHTTPBody($soapmsg),$soapAction,$this->timeout,$this->response_timeout);
+		if($errstr = $this->getError()){
+			$this->debug('Error: '.$errstr);
+			return false;
+		} else {
+			$this->return = $return;
+			$this->debug('sent message successfully and got a(n) '.gettype($return));
+           	$this->appendDebug('return=' . $this->varDump($return));
+			
+			// fault?
+			if(is_array($return) && isset($return['faultcode'])){
+				$this->debug('got fault');
+				$this->setError($return['faultcode'].': '.$return['faultstring']);
+				$this->fault = true;
+				foreach($return as $k => $v){
+					$this->$k = $v;
+					$this->debug("$k = $v<br>");
+				}
+				return $return;
+			} elseif ($style == 'document') {
+				// NOTE: if the response is defined to have multiple parts (i.e. unwrapped),
+				// we are only going to return the first part here...sorry about that
+				return $return;
+			} else {
+				// array of return values
+				if(is_array($return)){
+					// multiple 'out' parameters, which we return wrapped up
+					// in the array
+					if(sizeof($return) > 1){
+						return $return;
+					}
+					// single 'out' parameter (normally the return value)
+					$return = array_shift($return);
+					$this->debug('return shifted value: ');
+					$this->appendDebug($this->varDump($return));
+           			return $return;
+				// nothing returned (ie, echoVoid)
+				} else {
+					return "";
+				}
+			}
+		}
+	}
+
+	/**
+	* check WSDL passed as an instance or pulled from an endpoint
+	*
+	* @access   private
+	*/
+	function checkWSDL() {
+		$this->appendDebug($this->wsdl->getDebug());
+		$this->wsdl->clearDebug();
+		$this->debug('checkWSDL');
+		// catch errors
+		if ($errstr = $this->wsdl->getError()) {
+			$this->appendDebug($this->wsdl->getDebug());
+			$this->wsdl->clearDebug();
+			$this->debug('got wsdl error: '.$errstr);
+			$this->setError('wsdl error: '.$errstr);
+		} elseif ($this->operations = $this->wsdl->getOperations($this->portName, 'soap')) {
+			$this->appendDebug($this->wsdl->getDebug());
+			$this->wsdl->clearDebug();
+			$this->bindingType = 'soap';
+			$this->debug('got '.count($this->operations).' operations from wsdl '.$this->wsdlFile.' for binding type '.$this->bindingType);
+		} elseif ($this->operations = $this->wsdl->getOperations($this->portName, 'soap12')) {
+			$this->appendDebug($this->wsdl->getDebug());
+			$this->wsdl->clearDebug();
+			$this->bindingType = 'soap12';
+			$this->debug('got '.count($this->operations).' operations from wsdl '.$this->wsdlFile.' for binding type '.$this->bindingType);
+			$this->debug('**************** WARNING: SOAP 1.2 BINDING *****************');
+		} else {
+			$this->appendDebug($this->wsdl->getDebug());
+			$this->wsdl->clearDebug();
+			$this->debug('getOperations returned false');
+			$this->setError('no operations defined in the WSDL document!');
+		}
+	}
+
+	/**
+	 * instantiate wsdl object and parse wsdl file
+	 *
+	 * @access	public
+	 */
+	function loadWSDL() {
+		$this->debug('instantiating wsdl class with doc: '.$this->wsdlFile);
+		$this->wsdl = new wsdl('',$this->proxyhost,$this->proxyport,$this->proxyusername,$this->proxypassword,$this->timeout,$this->response_timeout,$this->curl_options,$this->use_curl);
+		$this->wsdl->setCredentials($this->username, $this->password, $this->authtype, $this->certRequest);
+		$this->wsdl->fetchWSDL($this->wsdlFile);
+		$this->checkWSDL();
+	}
+
+	/**
+	* get available data pertaining to an operation
+	*
+	* @param    string $operation operation name
+	* @return	array array of data pertaining to the operation
+	* @access   public
+	*/
+	function getOperationData($operation){
+		if ($this->endpointType == 'wsdl' && is_null($this->wsdl)) {
+			$this->loadWSDL();
+			if ($this->getError())
+				return false;
+		}
+		if(isset($this->operations[$operation])){
+			return $this->operations[$operation];
+		}
+		$this->debug("No data for operation: $operation");
+	}
+
+    /**
+    * send the SOAP message
+    *
+    * Note: if the operation has multiple return values
+    * the return value of this method will be an array
+    * of those values.
+    *
+	* @param    string $msg a SOAPx4 soapmsg object
+	* @param    string $soapaction SOAPAction value
+	* @param    integer $timeout set connection timeout in seconds
+	* @param	integer $response_timeout set response timeout in seconds
+	* @return	mixed native PHP types.
+	* @access   private
+	*/
+	function send($msg, $soapaction = '', $timeout=0, $response_timeout=30) {
+		$this->checkCookies();
+		// detect transport
+		switch(true){
+			// http(s)
+			case preg_match('/^http/',$this->endpoint):
+				$this->debug('transporting via HTTP');
+				if($this->persistentConnection == true && is_object($this->persistentConnection)){
+					$http =& $this->persistentConnection;
+				} else {
+					$http = new soap_transport_http($this->endpoint, $this->curl_options, $this->use_curl);
+					if ($this->persistentConnection) {
+						$http->usePersistentConnection();
+					}
+				}
+				$http->setContentType($this->getHTTPContentType(), $this->getHTTPContentTypeCharset());
+				$http->setSOAPAction($soapaction);
+				if($this->proxyhost && $this->proxyport){
+					$http->setProxy($this->proxyhost,$this->proxyport,$this->proxyusername,$this->proxypassword);
+				}
+                if($this->authtype != '') {
+					$http->setCredentials($this->username, $this->password, $this->authtype, array(), $this->certRequest);
+				}
+				if($this->http_encoding != ''){
+					$http->setEncoding($this->http_encoding);
+				}
+				$this->debug('sending message, length='.strlen($msg));
+				if(preg_match('/^http:/',$this->endpoint)){
+				//if(strpos($this->endpoint,'http:')){
+					$this->responseData = $http->send($msg,$timeout,$response_timeout,$this->cookies);
+				} elseif(preg_match('/^https/',$this->endpoint)){
+				//} elseif(strpos($this->endpoint,'https:')){
+					//if(phpversion() == '4.3.0-dev'){
+						//$response = $http->send($msg,$timeout,$response_timeout);
+                   		//$this->request = $http->outgoing_payload;
+						//$this->response = $http->incoming_payload;
+					//} else
+					$this->responseData = $http->sendHTTPS($msg,$timeout,$response_timeout,$this->cookies);
+				} else {
+					$this->setError('no http/s in endpoint url');
+				}
+				$this->request = $http->outgoing_payload;
+				$this->response = $http->incoming_payload;
+				$this->appendDebug($http->getDebug());
+				$this->UpdateCookies($http->incoming_cookies);
+
+				// save transport object if using persistent connections
+				if ($this->persistentConnection) {
+					$http->clearDebug();
+					if (!is_object($this->persistentConnection)) {
+						$this->persistentConnection = $http;
+					}
+				}
+				
+				if($err = $http->getError()){
+					$this->setError('HTTP Error: '.$err);
+					return false;
+				} elseif($this->getError()){
+					return false;
+				} else {
+					$this->debug('got response, length='. strlen($this->responseData).' type='.$http->incoming_headers['content-type']);
+					return $this->parseResponse($http->incoming_headers, $this->responseData);
+				}
+			break;
+			default:
+				$this->setError('no transport found, or selected transport is not yet supported!');
+			return false;
+			break;
+		}
+	}
+
+	/**
+	* processes SOAP message returned from server
+	*
+	* @param	array	$headers	The HTTP headers
+	* @param	string	$data		unprocessed response data from server
+	* @return	mixed	value of the message, decoded into a PHP type
+	* @access   private
+	*/
+    function parseResponse($headers, $data) {
+		$this->debug('Entering parseResponse() for data of length ' . strlen($data) . ' headers:');
+		$this->appendDebug($this->varDump($headers));
+    	if (!isset($headers['content-type'])) {
+			$this->setError('Response not of type text/xml (no content-type header)');
+			return false;
+    	}
+		if (!strstr($headers['content-type'], 'text/xml')) {
+			$this->setError('Response not of type text/xml: ' . $headers['content-type']);
+			return false;
+		}
+		if (strpos($headers['content-type'], '=')) {
+			$enc = str_replace('"', '', substr(strstr($headers["content-type"], '='), 1));
+			$this->debug('Got response encoding: ' . $enc);
+			if(preg_match('/^(ISO-8859-1|US-ASCII|UTF-8)$/i',$enc)){
+				$this->xml_encoding = strtoupper($enc);
+			} else {
+				$this->xml_encoding = 'US-ASCII';
+			}
+		} else {
+			// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+			$this->xml_encoding = 'ISO-8859-1';
+		}
+		$this->debug('Use encoding: ' . $this->xml_encoding . ' when creating nusoap_parser');
+		$parser = new nusoap_parser($data,$this->xml_encoding,$this->operation,$this->decode_utf8);
+		// add parser debug data to our debug
+		$this->appendDebug($parser->getDebug());
+		// if parse errors
+		if($errstr = $parser->getError()){
+			$this->setError( $errstr);
+			// destroy the parser object
+			unset($parser);
+			return false;
+		} else {
+			// get SOAP headers
+			$this->responseHeaders = $parser->getHeaders();
+			// get SOAP headers
+			$this->responseHeader = $parser->get_soapheader();
+			// get decoded message
+			$return = $parser->get_soapbody();
+            // add document for doclit support
+            $this->document = $parser->document;
+			// destroy the parser object
+			unset($parser);
+			// return decode message
+			return $return;
+		}
+	 }
+
+	/**
+	* sets user-specified cURL options
+	*
+	* @param	mixed $option The cURL option (always integer?)
+	* @param	mixed $value The cURL option value
+	* @access   public
+	*/
+	function setCurlOption($option, $value) {
+		$this->debug("setCurlOption option=$option, value=");
+		$this->appendDebug($this->varDump($value));
+		$this->curl_options[$option] = $value;
+	}
+
+	/**
+	* sets the SOAP endpoint, which can override WSDL
+	*
+	* @param	string $endpoint The endpoint URL to use, or empty string or false to prevent override
+	* @access   public
+	*/
+	function setEndpoint($endpoint) {
+		$this->debug("setEndpoint(\"$endpoint\")");
+		$this->forceEndpoint = $endpoint;
+	}
+
+	/**
+	* set the SOAP headers
+	*
+	* @param	mixed $headers String of XML with SOAP header content, or array of soapval objects for SOAP headers
+	* @access   public
+	*/
+	function setHeaders($headers){
+		$this->debug("setHeaders headers=");
+		$this->appendDebug($this->varDump($headers));
+		$this->requestHeaders = $headers;
+	}
+
+	/**
+	* get the SOAP response headers (namespace resolution incomplete)
+	*
+	* @return	string
+	* @access   public
+	*/
+	function getHeaders(){
+		return $this->responseHeaders;
+	}
+
+	/**
+	* get the SOAP response Header (parsed)
+	*
+	* @return	mixed
+	* @access   public
+	*/
+	function getHeader(){
+		return $this->responseHeader;
+	}
+
+	/**
+	* set proxy info here
+	*
+	* @param    string $proxyhost
+	* @param    string $proxyport
+	* @param	string $proxyusername
+	* @param	string $proxypassword
+	* @access   public
+	*/
+	function setHTTPProxy($proxyhost, $proxyport, $proxyusername = '', $proxypassword = '') {
+		$this->proxyhost = $proxyhost;
+		$this->proxyport = $proxyport;
+		$this->proxyusername = $proxyusername;
+		$this->proxypassword = $proxypassword;
+	}
+
+	/**
+	* if authenticating, set user credentials here
+	*
+	* @param    string $username
+	* @param    string $password
+	* @param	string $authtype (basic|digest|certificate|ntlm)
+	* @param	array $certRequest (keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, verifypeer (optional), verifyhost (optional): see corresponding options in cURL docs)
+	* @access   public
+	*/
+	function setCredentials($username, $password, $authtype = 'basic', $certRequest = array()) {
+		$this->debug("setCredentials username=$username authtype=$authtype certRequest=");
+		$this->appendDebug($this->varDump($certRequest));
+		$this->username = $username;
+		$this->password = $password;
+		$this->authtype = $authtype;
+		$this->certRequest = $certRequest;
+	}
+	
+	/**
+	* use HTTP encoding
+	*
+	* @param    string $enc HTTP encoding
+	* @access   public
+	*/
+	function setHTTPEncoding($enc='gzip, deflate'){
+		$this->debug("setHTTPEncoding(\"$enc\")");
+		$this->http_encoding = $enc;
+	}
+	
+	/**
+	* Set whether to try to use cURL connections if possible
+	*
+	* @param	boolean $use Whether to try to use cURL
+	* @access   public
+	*/
+	function setUseCURL($use) {
+		$this->debug("setUseCURL($use)");
+		$this->use_curl = $use;
+	}
+
+	/**
+	* use HTTP persistent connections if possible
+	*
+	* @access   public
+	*/
+	function useHTTPPersistentConnection(){
+		$this->debug("useHTTPPersistentConnection");
+		$this->persistentConnection = true;
+	}
+	
+	/**
+	* gets the default RPC parameter setting.
+	* If true, default is that call params are like RPC even for document style.
+	* Each call() can override this value.
+	*
+	* This is no longer used.
+	*
+	* @return boolean
+	* @access public
+	* @deprecated
+	*/
+	function getDefaultRpcParams() {
+		return $this->defaultRpcParams;
+	}
+
+	/**
+	* sets the default RPC parameter setting.
+	* If true, default is that call params are like RPC even for document style
+	* Each call() can override this value.
+	*
+	* This is no longer used.
+	*
+	* @param    boolean $rpcParams
+	* @access public
+	* @deprecated
+	*/
+	function setDefaultRpcParams($rpcParams) {
+		$this->defaultRpcParams = $rpcParams;
+	}
+	
+	/**
+	* dynamically creates an instance of a proxy class,
+	* allowing user to directly call methods from wsdl
+	*
+	* @return   object soap_proxy object
+	* @access   public
+	*/
+	function getProxy() {
+		$r = rand();
+		$evalStr = $this->_getProxyClassCode($r);
+		//$this->debug("proxy class: $evalStr");
+		if ($this->getError()) {
+			$this->debug("Error from _getProxyClassCode, so return NULL");
+			return null;
+		}
+		// eval the class
+		eval($evalStr);
+		// instantiate proxy object
+		eval("\$proxy = new nusoap_proxy_$r('');");
+		// transfer current wsdl data to the proxy thereby avoiding parsing the wsdl twice
+		$proxy->endpointType = 'wsdl';
+		$proxy->wsdlFile = $this->wsdlFile;
+		$proxy->wsdl = $this->wsdl;
+		$proxy->operations = $this->operations;
+		$proxy->defaultRpcParams = $this->defaultRpcParams;
+		// transfer other state
+		$proxy->soap_defencoding = $this->soap_defencoding;
+		$proxy->username = $this->username;
+		$proxy->password = $this->password;
+		$proxy->authtype = $this->authtype;
+		$proxy->certRequest = $this->certRequest;
+		$proxy->requestHeaders = $this->requestHeaders;
+		$proxy->endpoint = $this->endpoint;
+		$proxy->forceEndpoint = $this->forceEndpoint;
+		$proxy->proxyhost = $this->proxyhost;
+		$proxy->proxyport = $this->proxyport;
+		$proxy->proxyusername = $this->proxyusername;
+		$proxy->proxypassword = $this->proxypassword;
+		$proxy->http_encoding = $this->http_encoding;
+		$proxy->timeout = $this->timeout;
+		$proxy->response_timeout = $this->response_timeout;
+		$proxy->persistentConnection = &$this->persistentConnection;
+		$proxy->decode_utf8 = $this->decode_utf8;
+		$proxy->curl_options = $this->curl_options;
+		$proxy->bindingType = $this->bindingType;
+		$proxy->use_curl = $this->use_curl;
+		return $proxy;
+	}
+
+	/**
+	* dynamically creates proxy class code
+	*
+	* @return   string PHP/NuSOAP code for the proxy class
+	* @access   private
+	*/
+	function _getProxyClassCode($r) {
+		$this->debug("in getProxy endpointType=$this->endpointType");
+		$this->appendDebug("wsdl=" . $this->varDump($this->wsdl));
+		if ($this->endpointType != 'wsdl') {
+			$evalStr = 'A proxy can only be created for a WSDL client';
+			$this->setError($evalStr);
+			$evalStr = "echo \"$evalStr\";";
+			return $evalStr;
+		}
+		if ($this->endpointType == 'wsdl' && is_null($this->wsdl)) {
+			$this->loadWSDL();
+			if ($this->getError()) {
+				return "echo \"" . $this->getError() . "\";";
+			}
+		}
+		$evalStr = '';
+		foreach ($this->operations as $operation => $opData) {
+			if ($operation != '') {
+				// create param string and param comment string
+				if (sizeof($opData['input']['parts']) > 0) {
+					$paramStr = '';
+					$paramArrayStr = '';
+					$paramCommentStr = '';
+					foreach ($opData['input']['parts'] as $name => $type) {
+						$paramStr .= "\$$name, ";
+						$paramArrayStr .= "'$name' => \$$name, ";
+						$paramCommentStr .= "$type \$$name, ";
+					}
+					$paramStr = substr($paramStr, 0, strlen($paramStr)-2);
+					$paramArrayStr = substr($paramArrayStr, 0, strlen($paramArrayStr)-2);
+					$paramCommentStr = substr($paramCommentStr, 0, strlen($paramCommentStr)-2);
+				} else {
+					$paramStr = '';
+					$paramArrayStr = '';
+					$paramCommentStr = 'void';
+				}
+				$opData['namespace'] = !isset($opData['namespace']) ? 'http://testuri.com' : $opData['namespace'];
+				$evalStr .= "// $paramCommentStr
+	function " . str_replace('.', '__', $operation) . "($paramStr) {
+		\$params = array($paramArrayStr);
+		return \$this->call('$operation', \$params, '".$opData['namespace']."', '".(isset($opData['soapAction']) ? $opData['soapAction'] : '')."');
+	}
+	";
+				unset($paramStr);
+				unset($paramCommentStr);
+			}
+		}
+		$evalStr = 'class nusoap_proxy_'.$r.' extends nusoap_client {
+	'.$evalStr.'
+}';
+		return $evalStr;
+	}
+
+	/**
+	* dynamically creates proxy class code
+	*
+	* @return   string PHP/NuSOAP code for the proxy class
+	* @access   public
+	*/
+	function getProxyClassCode() {
+		$r = rand();
+		return $this->_getProxyClassCode($r);
+	}
+
+	/**
+	* gets the HTTP body for the current request.
+	*
+	* @param string $soapmsg The SOAP payload
+	* @return string The HTTP body, which includes the SOAP payload
+	* @access private
+	*/
+	function getHTTPBody($soapmsg) {
+		return $soapmsg;
+	}
+	
+	/**
+	* gets the HTTP content type for the current request.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type for the current request.
+	* @access private
+	*/
+	function getHTTPContentType() {
+		return 'text/xml';
+	}
+	
+	/**
+	* gets the HTTP content type charset for the current request.
+	* returns false for non-text content types.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type charset for the current request.
+	* @access private
+	*/
+	function getHTTPContentTypeCharset() {
+		return $this->soap_defencoding;
+	}
+
+	/*
+	* whether or not parser should decode utf8 element content
+    *
+    * @return   always returns true
+    * @access   public
+    */
+    function decodeUTF8($bool){
+		$this->decode_utf8 = $bool;
+		return true;
+    }
+
+	/**
+	 * adds a new Cookie into $this->cookies array
+	 *
+	 * @param	string $name Cookie Name
+	 * @param	string $value Cookie Value
+	 * @return	boolean if cookie-set was successful returns true, else false
+	 * @access	public
+	 */
+	function setCookie($name, $value) {
+		if (strlen($name) == 0) {
+			return false;
+		}
+		$this->cookies[] = array('name' => $name, 'value' => $value);
+		return true;
+	}
+
+	/**
+	 * gets all Cookies
+	 *
+	 * @return   array with all internal cookies
+	 * @access   public
+	 */
+	function getCookies() {
+		return $this->cookies;
+	}
+
+	/**
+	 * checks all Cookies and delete those which are expired
+	 *
+	 * @return   boolean always return true
+	 * @access   private
+	 */
+	function checkCookies() {
+		if (sizeof($this->cookies) == 0) {
+			return true;
+		}
+		$this->debug('checkCookie: check ' . sizeof($this->cookies) . ' cookies');
+		$curr_cookies = $this->cookies;
+		$this->cookies = array();
+		foreach ($curr_cookies as $cookie) {
+			if (! is_array($cookie)) {
+				$this->debug('Remove cookie that is not an array');
+				continue;
+			}
+			if ((isset($cookie['expires'])) && (! empty($cookie['expires']))) {
+				if (strtotime($cookie['expires']) > time()) {
+					$this->cookies[] = $cookie;
+				} else {
+					$this->debug('Remove expired cookie ' . $cookie['name']);
+				}
+			} else {
+				$this->cookies[] = $cookie;
+			}
+		}
+		$this->debug('checkCookie: '.sizeof($this->cookies).' cookies left in array');
+		return true;
+	}
+
+	/**
+	 * updates the current cookies with a new set
+	 *
+	 * @param	array $cookies new cookies with which to update current ones
+	 * @return	boolean always return true
+	 * @access	private
+	 */
+	function UpdateCookies($cookies) {
+		if (sizeof($this->cookies) == 0) {
+			// no existing cookies: take whatever is new
+			if (sizeof($cookies) > 0) {
+				$this->debug('Setting new cookie(s)');
+				$this->cookies = $cookies;
+			}
+			return true;
+		}
+		if (sizeof($cookies) == 0) {
+			// no new cookies: keep what we've got
+			return true;
+		}
+		// merge
+		foreach ($cookies as $newCookie) {
+			if (!is_array($newCookie)) {
+				continue;
+			}
+			if ((!isset($newCookie['name'])) || (!isset($newCookie['value']))) {
+				continue;
+			}
+			$newName = $newCookie['name'];
+
+			$found = false;
+			for ($i = 0; $i < count($this->cookies); $i++) {
+				$cookie = $this->cookies[$i];
+				if (!is_array($cookie)) {
+					continue;
+				}
+				if (!isset($cookie['name'])) {
+					continue;
+				}
+				if ($newName != $cookie['name']) {
+					continue;
+				}
+				$newDomain = isset($newCookie['domain']) ? $newCookie['domain'] : 'NODOMAIN';
+				$domain = isset($cookie['domain']) ? $cookie['domain'] : 'NODOMAIN';
+				if ($newDomain != $domain) {
+					continue;
+				}
+				$newPath = isset($newCookie['path']) ? $newCookie['path'] : 'NOPATH';
+				$path = isset($cookie['path']) ? $cookie['path'] : 'NOPATH';
+				if ($newPath != $path) {
+					continue;
+				}
+				$this->cookies[$i] = $newCookie;
+				$found = true;
+				$this->debug('Update cookie ' . $newName . '=' . $newCookie['value']);
+				break;
+			}
+			if (! $found) {
+				$this->debug('Add cookie ' . $newName . '=' . $newCookie['value']);
+				$this->cookies[] = $newCookie;
+			}
+		}
+		return true;
+	}
+}
+
+if (!extension_loaded('soap')) {
+	/**
+	 *	For backwards compatiblity, define soapclient unless the PHP SOAP extension is loaded.
+	 */
+	class soapclient extends nusoap_client {
+	}
+}
+?>
diff -rNU5 spip-ori/ecrire/nusoap/class.soap_fault.php spip/ecrire/nusoap/class.soap_fault.php
--- spip-ori/ecrire/nusoap/class.soap_fault.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nusoap/class.soap_fault.php	2013-04-05 11:06:41.153923139 +0200
@@ -0,0 +1,90 @@
+<?php
+
+
+
+
+/**
+* Contains information for a SOAP fault.
+* Mainly used for returning faults from deployed functions
+* in a server instance.
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @version  $Id: class.soap_fault.php,v 1.14 2007/04/11 15:49:47 snichol Exp $
+* @access public
+*/
+class nusoap_fault extends nusoap_base {
+	/**
+	 * The fault code (client|server)
+	 * @var string
+	 * @access private
+	 */
+	var $faultcode;
+	/**
+	 * The fault actor
+	 * @var string
+	 * @access private
+	 */
+	var $faultactor;
+	/**
+	 * The fault string, a description of the fault
+	 * @var string
+	 * @access private
+	 */
+	var $faultstring;
+	/**
+	 * The fault detail, typically a string or array of string
+	 * @var mixed
+	 * @access private
+	 */
+	var $faultdetail;
+
+	/**
+	* constructor
+    *
+    * @param string $faultcode (SOAP-ENV:Client | SOAP-ENV:Server)
+    * @param string $faultactor only used when msg routed between multiple actors
+    * @param string $faultstring human readable error message
+    * @param mixed $faultdetail detail, typically a string or array of string
+	*/
+	function nusoap_fault($faultcode,$faultactor='',$faultstring='',$faultdetail=''){
+		parent::nusoap_base();
+		$this->faultcode = $faultcode;
+		$this->faultactor = $faultactor;
+		$this->faultstring = $faultstring;
+		$this->faultdetail = $faultdetail;
+	}
+
+	/**
+	* serialize a fault
+	*
+	* @return	string	The serialization of the fault instance.
+	* @access   public
+	*/
+	function serialize(){
+		$ns_string = '';
+		foreach($this->namespaces as $k => $v){
+			$ns_string .= "\n  xmlns:$k=\"$v\"";
+		}
+		$return_msg =
+			'<?xml version="1.0" encoding="'.$this->soap_defencoding.'"?>'.
+			'<SOAP-ENV:Envelope SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"'.$ns_string.">\n".
+				'<SOAP-ENV:Body>'.
+				'<SOAP-ENV:Fault>'.
+					$this->serialize_val($this->faultcode, 'faultcode').
+					$this->serialize_val($this->faultactor, 'faultactor').
+					$this->serialize_val($this->faultstring, 'faultstring').
+					$this->serialize_val($this->faultdetail, 'detail').
+				'</SOAP-ENV:Fault>'.
+				'</SOAP-ENV:Body>'.
+			'</SOAP-ENV:Envelope>';
+		return $return_msg;
+	}
+}
+
+/**
+ * Backward compatibility
+ */
+class soap_fault extends nusoap_fault {
+}
+
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/ecrire/nusoap/class.soap_parser.php spip/ecrire/nusoap/class.soap_parser.php
--- spip-ori/ecrire/nusoap/class.soap_parser.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nusoap/class.soap_parser.php	2013-04-05 11:06:41.153923139 +0200
@@ -0,0 +1,643 @@
+<?php
+
+
+
+
+/**
+*
+* nusoap_parser class parses SOAP XML messages into native PHP values
+*
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @version  $Id: class.soap_parser.php,v 1.42 2010/04/26 20:15:08 snichol Exp $
+* @access   public
+*/
+class nusoap_parser extends nusoap_base {
+
+	var $xml = '';
+	var $xml_encoding = '';
+	var $method = '';
+	var $root_struct = '';
+	var $root_struct_name = '';
+	var $root_struct_namespace = '';
+	var $root_header = '';
+    var $document = '';			// incoming SOAP body (text)
+	// determines where in the message we are (envelope,header,body,method)
+	var $status = '';
+	var $position = 0;
+	var $depth = 0;
+	var $default_namespace = '';
+	var $namespaces = array();
+	var $message = array();
+    var $parent = '';
+	var $fault = false;
+	var $fault_code = '';
+	var $fault_str = '';
+	var $fault_detail = '';
+	var $depth_array = array();
+	var $debug_flag = true;
+	var $soapresponse = NULL;	// parsed SOAP Body
+	var $soapheader = NULL;		// parsed SOAP Header
+	var $responseHeaders = '';	// incoming SOAP headers (text)
+	var $body_position = 0;
+	// for multiref parsing:
+	// array of id => pos
+	var $ids = array();
+	// array of id => hrefs => pos
+	var $multirefs = array();
+	// toggle for auto-decoding element content
+	var $decode_utf8 = true;
+
+	/**
+	* constructor that actually does the parsing
+	*
+	* @param    string $xml SOAP message
+	* @param    string $encoding character encoding scheme of message
+	* @param    string $method method for which XML is parsed (unused?)
+	* @param    string $decode_utf8 whether to decode UTF-8 to ISO-8859-1
+	* @access   public
+	*/
+	function nusoap_parser($xml,$encoding='UTF-8',$method='',$decode_utf8=true){
+		parent::nusoap_base();
+		$this->xml = $xml;
+		$this->xml_encoding = $encoding;
+		$this->method = $method;
+		$this->decode_utf8 = $decode_utf8;
+
+		// Check whether content has been read.
+		if(!empty($xml)){
+			// Check XML encoding
+			$pos_xml = strpos($xml, '<?xml');
+			if ($pos_xml !== FALSE) {
+				$xml_decl = substr($xml, $pos_xml, strpos($xml, '?>', $pos_xml + 2) - $pos_xml + 1);
+				if (preg_match("/encoding=[\"']([^\"']*)[\"']/", $xml_decl, $res)) {
+					$xml_encoding = $res[1];
+					if (strtoupper($xml_encoding) != $encoding) {
+						$err = "Charset from HTTP Content-Type '" . $encoding . "' does not match encoding from XML declaration '" . $xml_encoding . "'";
+						$this->debug($err);
+						if ($encoding != 'ISO-8859-1' || strtoupper($xml_encoding) != 'UTF-8') {
+							$this->setError($err);
+							return;
+						}
+						// when HTTP says ISO-8859-1 (the default) and XML says UTF-8 (the typical), assume the other endpoint is just sloppy and proceed
+					} else {
+						$this->debug('Charset from HTTP Content-Type matches encoding from XML declaration');
+					}
+				} else {
+					$this->debug('No encoding specified in XML declaration');
+				}
+			} else {
+				$this->debug('No XML declaration');
+			}
+			$this->debug('Entering nusoap_parser(), length='.strlen($xml).', encoding='.$encoding);
+			// Create an XML parser - why not xml_parser_create_ns?
+			$this->parser = xml_parser_create($this->xml_encoding);
+			// Set the options for parsing the XML data.
+			//xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);
+			xml_parser_set_option($this->parser, XML_OPTION_CASE_FOLDING, 0);
+			xml_parser_set_option($this->parser, XML_OPTION_TARGET_ENCODING, $this->xml_encoding);
+			// Set the object for the parser.
+			xml_set_object($this->parser, $this);
+			// Set the element handlers for the parser.
+			xml_set_element_handler($this->parser, 'start_element','end_element');
+			xml_set_character_data_handler($this->parser,'character_data');
+
+			// Parse the XML file.
+			if(!xml_parse($this->parser,$xml,true)){
+			    // Display an error message.
+			    $err = sprintf('XML error parsing SOAP payload on line %d: %s',
+			    xml_get_current_line_number($this->parser),
+			    xml_error_string(xml_get_error_code($this->parser)));
+				$this->debug($err);
+				$this->debug("XML payload:\n" . $xml);
+				$this->setError($err);
+			} else {
+				$this->debug('in nusoap_parser ctor, message:');
+				$this->appendDebug($this->varDump($this->message));
+				$this->debug('parsed successfully, found root struct: '.$this->root_struct.' of name '.$this->root_struct_name);
+				// get final value
+				$this->soapresponse = $this->message[$this->root_struct]['result'];
+				// get header value
+				if($this->root_header != '' && isset($this->message[$this->root_header]['result'])){
+					$this->soapheader = $this->message[$this->root_header]['result'];
+				}
+				// resolve hrefs/ids
+				if(sizeof($this->multirefs) > 0){
+					foreach($this->multirefs as $id => $hrefs){
+						$this->debug('resolving multirefs for id: '.$id);
+						$idVal = $this->buildVal($this->ids[$id]);
+						if (is_array($idVal) && isset($idVal['!id'])) {
+							unset($idVal['!id']);
+						}
+						foreach($hrefs as $refPos => $ref){
+							$this->debug('resolving href at pos '.$refPos);
+							$this->multirefs[$id][$refPos] = $idVal;
+						}
+					}
+				}
+			}
+			xml_parser_free($this->parser);
+		} else {
+			$this->debug('xml was empty, didn\'t parse!');
+			$this->setError('xml was empty, didn\'t parse!');
+		}
+	}
+
+	/**
+	* start-element handler
+	*
+	* @param    resource $parser XML parser object
+	* @param    string $name element name
+	* @param    array $attrs associative array of attributes
+	* @access   private
+	*/
+	function start_element($parser, $name, $attrs) {
+		// position in a total number of elements, starting from 0
+		// update class level pos
+		$pos = $this->position++;
+		// and set mine
+		$this->message[$pos] = array('pos' => $pos,'children'=>'','cdata'=>'');
+		// depth = how many levels removed from root?
+		// set mine as current global depth and increment global depth value
+		$this->message[$pos]['depth'] = $this->depth++;
+
+		// else add self as child to whoever the current parent is
+		if($pos != 0){
+			$this->message[$this->parent]['children'] .= '|'.$pos;
+		}
+		// set my parent
+		$this->message[$pos]['parent'] = $this->parent;
+		// set self as current parent
+		$this->parent = $pos;
+		// set self as current value for this depth
+		$this->depth_array[$this->depth] = $pos;
+		// get element prefix
+		if(strpos($name,':')){
+			// get ns prefix
+			$prefix = substr($name,0,strpos($name,':'));
+			// get unqualified name
+			$name = substr(strstr($name,':'),1);
+		}
+		// set status
+		if ($name == 'Envelope' && $this->status == '') {
+			$this->status = 'envelope';
+		} elseif ($name == 'Header' && $this->status == 'envelope') {
+			$this->root_header = $pos;
+			$this->status = 'header';
+		} elseif ($name == 'Body' && $this->status == 'envelope'){
+			$this->status = 'body';
+			$this->body_position = $pos;
+		// set method
+		} elseif($this->status == 'body' && $pos == ($this->body_position+1)) {
+			$this->status = 'method';
+			$this->root_struct_name = $name;
+			$this->root_struct = $pos;
+			$this->message[$pos]['type'] = 'struct';
+			$this->debug("found root struct $this->root_struct_name, pos $this->root_struct");
+		}
+		// set my status
+		$this->message[$pos]['status'] = $this->status;
+		// set name
+		$this->message[$pos]['name'] = htmlspecialchars($name);
+		// set attrs
+		$this->message[$pos]['attrs'] = $attrs;
+
+		// loop through atts, logging ns and type declarations
+        $attstr = '';
+		foreach($attrs as $key => $value){
+        	$key_prefix = $this->getPrefix($key);
+			$key_localpart = $this->getLocalPart($key);
+			// if ns declarations, add to class level array of valid namespaces
+            if($key_prefix == 'xmlns'){
+				if(preg_match('/^http:\/\/www.w3.org\/[0-9]{4}\/XMLSchema$/',$value)){
+					$this->XMLSchemaVersion = $value;
+					$this->namespaces['xsd'] = $this->XMLSchemaVersion;
+					$this->namespaces['xsi'] = $this->XMLSchemaVersion.'-instance';
+				}
+                $this->namespaces[$key_localpart] = $value;
+				// set method namespace
+				if($name == $this->root_struct_name){
+					$this->methodNamespace = $value;
+				}
+			// if it's a type declaration, set type
+        } elseif($key_localpart == 'type'){
+        		if (isset($this->message[$pos]['type']) && $this->message[$pos]['type'] == 'array') {
+        			// do nothing: already processed arrayType
+        		} else {
+	            	$value_prefix = $this->getPrefix($value);
+	                $value_localpart = $this->getLocalPart($value);
+					$this->message[$pos]['type'] = $value_localpart;
+					$this->message[$pos]['typePrefix'] = $value_prefix;
+	                if(isset($this->namespaces[$value_prefix])){
+	                	$this->message[$pos]['type_namespace'] = $this->namespaces[$value_prefix];
+	                } else if(isset($attrs['xmlns:'.$value_prefix])) {
+						$this->message[$pos]['type_namespace'] = $attrs['xmlns:'.$value_prefix];
+	                }
+					// should do something here with the namespace of specified type?
+				}
+			} elseif($key_localpart == 'arrayType'){
+				$this->message[$pos]['type'] = 'array';
+				/* do arrayType ereg here
+				[1]    arrayTypeValue    ::=    atype asize
+				[2]    atype    ::=    QName rank*
+				[3]    rank    ::=    '[' (',')* ']'
+				[4]    asize    ::=    '[' length~ ']'
+				[5]    length    ::=    nextDimension* Digit+
+				[6]    nextDimension    ::=    Digit+ ','
+				*/
+				$expr = '/([A-Za-z0-9_]+):([A-Za-z]+[A-Za-z0-9_]+)\[([0-9]+),?([0-9]*)\]/';
+				if(preg_match($expr,$value,$regs)){
+					$this->message[$pos]['typePrefix'] = $regs[1];
+					$this->message[$pos]['arrayTypePrefix'] = $regs[1];
+	                if (isset($this->namespaces[$regs[1]])) {
+	                	$this->message[$pos]['arrayTypeNamespace'] = $this->namespaces[$regs[1]];
+	                } else if (isset($attrs['xmlns:'.$regs[1]])) {
+						$this->message[$pos]['arrayTypeNamespace'] = $attrs['xmlns:'.$regs[1]];
+	                }
+					$this->message[$pos]['arrayType'] = $regs[2];
+					$this->message[$pos]['arraySize'] = $regs[3];
+					$this->message[$pos]['arrayCols'] = $regs[4];
+				}
+			// specifies nil value (or not)
+			} elseif ($key_localpart == 'nil'){
+				$this->message[$pos]['nil'] = ($value == 'true' || $value == '1');
+			// some other attribute
+			} elseif ($key != 'href' && $key != 'xmlns' && $key_localpart != 'encodingStyle' && $key_localpart != 'root') {
+				$this->message[$pos]['xattrs']['!' . $key] = $value;
+			}
+
+			if ($key == 'xmlns') {
+				$this->default_namespace = $value;
+			}
+			// log id
+			if($key == 'id'){
+				$this->ids[$value] = $pos;
+			}
+			// root
+			if($key_localpart == 'root' && $value == 1){
+				$this->status = 'method';
+				$this->root_struct_name = $name;
+				$this->root_struct = $pos;
+				$this->debug("found root struct $this->root_struct_name, pos $pos");
+			}
+            // for doclit
+            $attstr .= " $key=\"$value\"";
+		}
+        // get namespace - must be done after namespace atts are processed
+		if(isset($prefix)){
+			$this->message[$pos]['namespace'] = $this->namespaces[$prefix];
+			$this->default_namespace = $this->namespaces[$prefix];
+		} else {
+			$this->message[$pos]['namespace'] = $this->default_namespace;
+		}
+        if($this->status == 'header'){
+        	if ($this->root_header != $pos) {
+	        	$this->responseHeaders .= "<" . (isset($prefix) ? $prefix . ':' : '') . "$name$attstr>";
+	        }
+        } elseif($this->root_struct_name != ''){
+        	$this->document .= "<" . (isset($prefix) ? $prefix . ':' : '') . "$name$attstr>";
+        }
+	}
+
+	/**
+	* end-element handler
+	*
+	* @param    resource $parser XML parser object
+	* @param    string $name element name
+	* @access   private
+	*/
+	function end_element($parser, $name) {
+		// position of current element is equal to the last value left in depth_array for my depth
+		$pos = $this->depth_array[$this->depth--];
+
+        // get element prefix
+		if(strpos($name,':')){
+			// get ns prefix
+			$prefix = substr($name,0,strpos($name,':'));
+			// get unqualified name
+			$name = substr(strstr($name,':'),1);
+		}
+		
+		// build to native type
+		if(isset($this->body_position) && $pos > $this->body_position){
+			// deal w/ multirefs
+			if(isset($this->message[$pos]['attrs']['href'])){
+				// get id
+				$id = substr($this->message[$pos]['attrs']['href'],1);
+				// add placeholder to href array
+				$this->multirefs[$id][$pos] = 'placeholder';
+				// add set a reference to it as the result value
+				$this->message[$pos]['result'] =& $this->multirefs[$id][$pos];
+            // build complexType values
+			} elseif($this->message[$pos]['children'] != ''){
+				// if result has already been generated (struct/array)
+				if(!isset($this->message[$pos]['result'])){
+					$this->message[$pos]['result'] = $this->buildVal($pos);
+				}
+			// build complexType values of attributes and possibly simpleContent
+			} elseif (isset($this->message[$pos]['xattrs'])) {
+				if (isset($this->message[$pos]['nil']) && $this->message[$pos]['nil']) {
+					$this->message[$pos]['xattrs']['!'] = null;
+				} elseif (isset($this->message[$pos]['cdata']) && trim($this->message[$pos]['cdata']) != '') {
+	            	if (isset($this->message[$pos]['type'])) {
+						$this->message[$pos]['xattrs']['!'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$pos]['type'], isset($this->message[$pos]['type_namespace']) ? $this->message[$pos]['type_namespace'] : '');
+					} else {
+						$parent = $this->message[$pos]['parent'];
+						if (isset($this->message[$parent]['type']) && ($this->message[$parent]['type'] == 'array') && isset($this->message[$parent]['arrayType'])) {
+							$this->message[$pos]['xattrs']['!'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$parent]['arrayType'], isset($this->message[$parent]['arrayTypeNamespace']) ? $this->message[$parent]['arrayTypeNamespace'] : '');
+						} else {
+							$this->message[$pos]['xattrs']['!'] = $this->message[$pos]['cdata'];
+						}
+					}
+				}
+				$this->message[$pos]['result'] = $this->message[$pos]['xattrs'];
+			// set value of simpleType (or nil complexType)
+			} else {
+            	//$this->debug('adding data for scalar value '.$this->message[$pos]['name'].' of value '.$this->message[$pos]['cdata']);
+				if (isset($this->message[$pos]['nil']) && $this->message[$pos]['nil']) {
+					$this->message[$pos]['xattrs']['!'] = null;
+				} elseif (isset($this->message[$pos]['type'])) {
+					$this->message[$pos]['result'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$pos]['type'], isset($this->message[$pos]['type_namespace']) ? $this->message[$pos]['type_namespace'] : '');
+				} else {
+					$parent = $this->message[$pos]['parent'];
+					if (isset($this->message[$parent]['type']) && ($this->message[$parent]['type'] == 'array') && isset($this->message[$parent]['arrayType'])) {
+						$this->message[$pos]['result'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$parent]['arrayType'], isset($this->message[$parent]['arrayTypeNamespace']) ? $this->message[$parent]['arrayTypeNamespace'] : '');
+					} else {
+						$this->message[$pos]['result'] = $this->message[$pos]['cdata'];
+					}
+				}
+
+				/* add value to parent's result, if parent is struct/array
+				$parent = $this->message[$pos]['parent'];
+				if($this->message[$parent]['type'] != 'map'){
+					if(strtolower($this->message[$parent]['type']) == 'array'){
+						$this->message[$parent]['result'][] = $this->message[$pos]['result'];
+					} else {
+						$this->message[$parent]['result'][$this->message[$pos]['name']] = $this->message[$pos]['result'];
+					}
+				}
+				*/
+			}
+		}
+		
+        // for doclit
+        if($this->status == 'header'){
+        	if ($this->root_header != $pos) {
+	        	$this->responseHeaders .= "</" . (isset($prefix) ? $prefix . ':' : '') . "$name>";
+	        }
+        } elseif($pos >= $this->root_struct){
+        	$this->document .= "</" . (isset($prefix) ? $prefix . ':' : '') . "$name>";
+        }
+		// switch status
+		if ($pos == $this->root_struct){
+			$this->status = 'body';
+			$this->root_struct_namespace = $this->message[$pos]['namespace'];
+		} elseif ($pos == $this->root_header) {
+			$this->status = 'envelope';
+		} elseif ($name == 'Body' && $this->status == 'body') {
+			$this->status = 'envelope';
+		} elseif ($name == 'Header' && $this->status == 'header') { // will never happen
+			$this->status = 'envelope';
+		} elseif ($name == 'Envelope' && $this->status == 'envelope') {
+			$this->status = '';
+		}
+		// set parent back to my parent
+		$this->parent = $this->message[$pos]['parent'];
+	}
+
+	/**
+	* element content handler
+	*
+	* @param    resource $parser XML parser object
+	* @param    string $data element content
+	* @access   private
+	*/
+	function character_data($parser, $data){
+		$pos = $this->depth_array[$this->depth];
+		if ($this->xml_encoding=='UTF-8'){
+			// TODO: add an option to disable this for folks who want
+			// raw UTF-8 that, e.g., might not map to iso-8859-1
+			// TODO: this can also be handled with xml_parser_set_option($this->parser, XML_OPTION_TARGET_ENCODING, "ISO-8859-1");
+			if($this->decode_utf8){
+				$data = utf8_decode($data);
+			}
+		}
+        $this->message[$pos]['cdata'] .= $data;
+        // for doclit
+        if($this->status == 'header'){
+        	$this->responseHeaders .= $data;
+        } else {
+        	$this->document .= $data;
+        }
+	}
+
+	/**
+	* get the parsed message (SOAP Body)
+	*
+	* @return	mixed
+	* @access   public
+	* @deprecated	use get_soapbody instead
+	*/
+	function get_response(){
+		return $this->soapresponse;
+	}
+
+	/**
+	* get the parsed SOAP Body (NULL if there was none)
+	*
+	* @return	mixed
+	* @access   public
+	*/
+	function get_soapbody(){
+		return $this->soapresponse;
+	}
+
+	/**
+	* get the parsed SOAP Header (NULL if there was none)
+	*
+	* @return	mixed
+	* @access   public
+	*/
+	function get_soapheader(){
+		return $this->soapheader;
+	}
+
+	/**
+	* get the unparsed SOAP Header
+	*
+	* @return	string XML or empty if no Header
+	* @access   public
+	*/
+	function getHeaders(){
+	    return $this->responseHeaders;
+	}
+
+	/**
+	* decodes simple types into PHP variables
+	*
+	* @param    string $value value to decode
+	* @param    string $type XML type to decode
+	* @param    string $typens XML type namespace to decode
+	* @return	mixed PHP value
+	* @access   private
+	*/
+	function decodeSimple($value, $type, $typens) {
+		// TODO: use the namespace!
+		if ((!isset($type)) || $type == 'string' || $type == 'long' || $type == 'unsignedLong') {
+			return (string) $value;
+		}
+		if ($type == 'int' || $type == 'integer' || $type == 'short' || $type == 'byte') {
+			return (int) $value;
+		}
+		if ($type == 'float' || $type == 'double' || $type == 'decimal') {
+			return (double) $value;
+		}
+		if ($type == 'boolean') {
+			if (strtolower($value) == 'false' || strtolower($value) == 'f') {
+				return false;
+			}
+			return (boolean) $value;
+		}
+		if ($type == 'base64' || $type == 'base64Binary') {
+			$this->debug('Decode base64 value');
+			return base64_decode($value);
+		}
+		// obscure numeric types
+		if ($type == 'nonPositiveInteger' || $type == 'negativeInteger'
+			|| $type == 'nonNegativeInteger' || $type == 'positiveInteger'
+			|| $type == 'unsignedInt'
+			|| $type == 'unsignedShort' || $type == 'unsignedByte') {
+			return (int) $value;
+		}
+		// bogus: parser treats array with no elements as a simple type
+		if ($type == 'array') {
+			return array();
+		}
+		// everything else
+		return (string) $value;
+	}
+
+	/**
+	* builds response structures for compound values (arrays/structs)
+	* and scalars
+	*
+	* @param    integer $pos position in node tree
+	* @return	mixed	PHP value
+	* @access   private
+	*/
+	function buildVal($pos){
+		if(!isset($this->message[$pos]['type'])){
+			$this->message[$pos]['type'] = '';
+		}
+		$this->debug('in buildVal() for '.$this->message[$pos]['name']."(pos $pos) of type ".$this->message[$pos]['type']);
+		// if there are children...
+		if($this->message[$pos]['children'] != ''){
+			$this->debug('in buildVal, there are children');
+			$children = explode('|',$this->message[$pos]['children']);
+			array_shift($children); // knock off empty
+			// md array
+			if(isset($this->message[$pos]['arrayCols']) && $this->message[$pos]['arrayCols'] != ''){
+            	$r=0; // rowcount
+            	$c=0; // colcount
+            	foreach($children as $child_pos){
+					$this->debug("in buildVal, got an MD array element: $r, $c");
+					$params[$r][] = $this->message[$child_pos]['result'];
+				    $c++;
+				    if($c == $this->message[$pos]['arrayCols']){
+				    	$c = 0;
+						$r++;
+				    }
+                }
+            // array
+			} elseif($this->message[$pos]['type'] == 'array' || $this->message[$pos]['type'] == 'Array'){
+                $this->debug('in buildVal, adding array '.$this->message[$pos]['name']);
+                foreach($children as $child_pos){
+                	$params[] = &$this->message[$child_pos]['result'];
+                }
+            // apache Map type: java hashtable
+            } elseif($this->message[$pos]['type'] == 'Map' && $this->message[$pos]['type_namespace'] == 'http://xml.apache.org/xml-soap'){
+                $this->debug('in buildVal, Java Map '.$this->message[$pos]['name']);
+                foreach($children as $child_pos){
+                	$kv = explode("|",$this->message[$child_pos]['children']);
+                   	$params[$this->message[$kv[1]]['result']] = &$this->message[$kv[2]]['result'];
+                }
+            // generic compound type
+            //} elseif($this->message[$pos]['type'] == 'SOAPStruct' || $this->message[$pos]['type'] == 'struct') {
+		    } else {
+	    		// Apache Vector type: treat as an array
+                $this->debug('in buildVal, adding Java Vector or generic compound type '.$this->message[$pos]['name']);
+				if ($this->message[$pos]['type'] == 'Vector' && $this->message[$pos]['type_namespace'] == 'http://xml.apache.org/xml-soap') {
+					$notstruct = 1;
+				} else {
+					$notstruct = 0;
+	            }
+            	//
+            	foreach($children as $child_pos){
+            		if($notstruct){
+            			$params[] = &$this->message[$child_pos]['result'];
+            		} else {
+            			if (isset($params[$this->message[$child_pos]['name']])) {
+            				// de-serialize repeated element name into an array
+            				if ((!is_array($params[$this->message[$child_pos]['name']])) || (!isset($params[$this->message[$child_pos]['name']][0]))) {
+            					$params[$this->message[$child_pos]['name']] = array($params[$this->message[$child_pos]['name']]);
+            				}
+            				$params[$this->message[$child_pos]['name']][] = &$this->message[$child_pos]['result'];
+            			} else {
+					    	$params[$this->message[$child_pos]['name']] = &$this->message[$child_pos]['result'];
+					    }
+                	}
+                }
+			}
+			if (isset($this->message[$pos]['xattrs'])) {
+                $this->debug('in buildVal, handling attributes');
+				foreach ($this->message[$pos]['xattrs'] as $n => $v) {
+					$params[$n] = $v;
+				}
+			}
+			// handle simpleContent
+			if (isset($this->message[$pos]['cdata']) && trim($this->message[$pos]['cdata']) != '') {
+                $this->debug('in buildVal, handling simpleContent');
+            	if (isset($this->message[$pos]['type'])) {
+					$params['!'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$pos]['type'], isset($this->message[$pos]['type_namespace']) ? $this->message[$pos]['type_namespace'] : '');
+				} else {
+					$parent = $this->message[$pos]['parent'];
+					if (isset($this->message[$parent]['type']) && ($this->message[$parent]['type'] == 'array') && isset($this->message[$parent]['arrayType'])) {
+						$params['!'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$parent]['arrayType'], isset($this->message[$parent]['arrayTypeNamespace']) ? $this->message[$parent]['arrayTypeNamespace'] : '');
+					} else {
+						$params['!'] = $this->message[$pos]['cdata'];
+					}
+				}
+			}
+			$ret = is_array($params) ? $params : array();
+			$this->debug('in buildVal, return:');
+			$this->appendDebug($this->varDump($ret));
+			return $ret;
+		} else {
+        	$this->debug('in buildVal, no children, building scalar');
+			$cdata = isset($this->message[$pos]['cdata']) ? $this->message[$pos]['cdata'] : '';
+        	if (isset($this->message[$pos]['type'])) {
+				$ret = $this->decodeSimple($cdata, $this->message[$pos]['type'], isset($this->message[$pos]['type_namespace']) ? $this->message[$pos]['type_namespace'] : '');
+				$this->debug("in buildVal, return: $ret");
+				return $ret;
+			}
+			$parent = $this->message[$pos]['parent'];
+			if (isset($this->message[$parent]['type']) && ($this->message[$parent]['type'] == 'array') && isset($this->message[$parent]['arrayType'])) {
+				$ret = $this->decodeSimple($cdata, $this->message[$parent]['arrayType'], isset($this->message[$parent]['arrayTypeNamespace']) ? $this->message[$parent]['arrayTypeNamespace'] : '');
+				$this->debug("in buildVal, return: $ret");
+				return $ret;
+			}
+           	$ret = $this->message[$pos]['cdata'];
+			$this->debug("in buildVal, return: $ret");
+           	return $ret;
+		}
+	}
+}
+
+/**
+ * Backward compatibility
+ */
+class soap_parser extends nusoap_parser {
+}
+
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/ecrire/nusoap/class.soap_server.php spip/ecrire/nusoap/class.soap_server.php
--- spip-ori/ecrire/nusoap/class.soap_server.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nusoap/class.soap_server.php	2013-04-05 11:06:41.153923139 +0200
@@ -0,0 +1,1127 @@
+<?php
+
+
+
+
+/**
+*
+* nusoap_server allows the user to create a SOAP server
+* that is capable of receiving messages and returning responses
+*
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @version  $Id: class.soap_server.php,v 1.63 2010/04/26 20:15:08 snichol Exp $
+* @access   public
+*/
+class nusoap_server extends nusoap_base {
+	/**
+	 * HTTP headers of request
+	 * @var array
+	 * @access private
+	 */
+	var $headers = array();
+	/**
+	 * HTTP request
+	 * @var string
+	 * @access private
+	 */
+	var $request = '';
+	/**
+	 * SOAP headers from request (incomplete namespace resolution; special characters not escaped) (text)
+	 * @var string
+	 * @access public
+	 */
+	var $requestHeaders = '';
+	/**
+	 * SOAP Headers from request (parsed)
+	 * @var mixed
+	 * @access public
+	 */
+	var $requestHeader = NULL;
+	/**
+	 * SOAP body request portion (incomplete namespace resolution; special characters not escaped) (text)
+	 * @var string
+	 * @access public
+	 */
+	var $document = '';
+	/**
+	 * SOAP payload for request (text)
+	 * @var string
+	 * @access public
+	 */
+	var $requestSOAP = '';
+	/**
+	 * requested method namespace URI
+	 * @var string
+	 * @access private
+	 */
+	var $methodURI = '';
+	/**
+	 * name of method requested
+	 * @var string
+	 * @access private
+	 */
+	var $methodname = '';
+	/**
+	 * method parameters from request
+	 * @var array
+	 * @access private
+	 */
+	var $methodparams = array();
+	/**
+	 * SOAP Action from request
+	 * @var string
+	 * @access private
+	 */
+	var $SOAPAction = '';
+	/**
+	 * character set encoding of incoming (request) messages
+	 * @var string
+	 * @access public
+	 */
+	var $xml_encoding = '';
+	/**
+	 * toggles whether the parser decodes element content w/ utf8_decode()
+	 * @var boolean
+	 * @access public
+	 */
+    var $decode_utf8 = true;
+
+	/**
+	 * HTTP headers of response
+	 * @var array
+	 * @access public
+	 */
+	var $outgoing_headers = array();
+	/**
+	 * HTTP response
+	 * @var string
+	 * @access private
+	 */
+	var $response = '';
+	/**
+	 * SOAP headers for response (text or array of soapval or associative array)
+	 * @var mixed
+	 * @access public
+	 */
+	var $responseHeaders = '';
+	/**
+	 * SOAP payload for response (text)
+	 * @var string
+	 * @access private
+	 */
+	var $responseSOAP = '';
+	/**
+	 * method return value to place in response
+	 * @var mixed
+	 * @access private
+	 */
+	var $methodreturn = false;
+	/**
+	 * whether $methodreturn is a string of literal XML
+	 * @var boolean
+	 * @access public
+	 */
+	var $methodreturnisliteralxml = false;
+	/**
+	 * SOAP fault for response (or false)
+	 * @var mixed
+	 * @access private
+	 */
+	var $fault = false;
+	/**
+	 * text indication of result (for debugging)
+	 * @var string
+	 * @access private
+	 */
+	var $result = 'successful';
+
+	/**
+	 * assoc array of operations => opData; operations are added by the register()
+	 * method or by parsing an external WSDL definition
+	 * @var array
+	 * @access private
+	 */
+	var $operations = array();
+	/**
+	 * wsdl instance (if one)
+	 * @var mixed
+	 * @access private
+	 */
+	var $wsdl = false;
+	/**
+	 * URL for WSDL (if one)
+	 * @var mixed
+	 * @access private
+	 */
+	var $externalWSDLURL = false;
+	/**
+	 * whether to append debug to response as XML comment
+	 * @var boolean
+	 * @access public
+	 */
+	var $debug_flag = false;
+
+
+	/**
+	* constructor
+    * the optional parameter is a path to a WSDL file that you'd like to bind the server instance to.
+	*
+    * @param mixed $wsdl file path or URL (string), or wsdl instance (object)
+	* @access   public
+	*/
+	function nusoap_server($wsdl=false){
+		parent::nusoap_base();
+		// turn on debugging?
+		global $debug;
+		global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER)) {
+			$this->debug("_SERVER is defined:");
+			$this->appendDebug($this->varDump($_SERVER));
+		} elseif (isset($HTTP_SERVER_VARS)) {
+			$this->debug("HTTP_SERVER_VARS is defined:");
+			$this->appendDebug($this->varDump($HTTP_SERVER_VARS));
+		} else {
+			$this->debug("Neither _SERVER nor HTTP_SERVER_VARS is defined.");
+		}
+
+		if (isset($debug)) {
+			$this->debug("In nusoap_server, set debug_flag=$debug based on global flag");
+			$this->debug_flag = $debug;
+		} elseif (isset($_SERVER['QUERY_STRING'])) {
+			$qs = explode('&', $_SERVER['QUERY_STRING']);
+			foreach ($qs as $v) {
+				if (substr($v, 0, 6) == 'debug=') {
+					$this->debug("In nusoap_server, set debug_flag=" . substr($v, 6) . " based on query string #1");
+					$this->debug_flag = substr($v, 6);
+				}
+			}
+		} elseif (isset($HTTP_SERVER_VARS['QUERY_STRING'])) {
+			$qs = explode('&', $HTTP_SERVER_VARS['QUERY_STRING']);
+			foreach ($qs as $v) {
+				if (substr($v, 0, 6) == 'debug=') {
+					$this->debug("In nusoap_server, set debug_flag=" . substr($v, 6) . " based on query string #2");
+					$this->debug_flag = substr($v, 6);
+				}
+			}
+		}
+
+		// wsdl
+		if($wsdl){
+			$this->debug("In nusoap_server, WSDL is specified");
+			if (is_object($wsdl) && (get_class($wsdl) == 'wsdl')) {
+				$this->wsdl = $wsdl;
+				$this->externalWSDLURL = $this->wsdl->wsdl;
+				$this->debug('Use existing wsdl instance from ' . $this->externalWSDLURL);
+			} else {
+				$this->debug('Create wsdl from ' . $wsdl);
+				$this->wsdl = new wsdl($wsdl);
+				$this->externalWSDLURL = $wsdl;
+			}
+			$this->appendDebug($this->wsdl->getDebug());
+			$this->wsdl->clearDebug();
+			if($err = $this->wsdl->getError()){
+				die('WSDL ERROR: '.$err);
+			}
+		}
+	}
+
+	/**
+	* processes request and returns response
+	*
+	* @param    string $data usually is the value of $HTTP_RAW_POST_DATA
+	* @access   public
+	*/
+	function service($data){
+		global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER['REQUEST_METHOD'])) {
+			$rm = $_SERVER['REQUEST_METHOD'];
+		} elseif (isset($HTTP_SERVER_VARS['REQUEST_METHOD'])) {
+			$rm = $HTTP_SERVER_VARS['REQUEST_METHOD'];
+		} else {
+			$rm = '';
+		}
+
+		if (isset($_SERVER['QUERY_STRING'])) {
+			$qs = $_SERVER['QUERY_STRING'];
+		} elseif (isset($HTTP_SERVER_VARS['QUERY_STRING'])) {
+			$qs = $HTTP_SERVER_VARS['QUERY_STRING'];
+		} else {
+			$qs = '';
+		}
+		$this->debug("In service, request method=$rm query string=$qs strlen(\$data)=" . strlen($data));
+
+		if ($rm == 'POST') {
+			$this->debug("In service, invoke the request");
+			$this->parse_request($data);
+			if (! $this->fault) {
+				$this->invoke_method();
+			}
+			if (! $this->fault) {
+				$this->serialize_return();
+			}
+			$this->send_response();
+		} elseif (preg_match('/wsdl/', $qs) ){
+			$this->debug("In service, this is a request for WSDL");
+			if ($this->externalWSDLURL){
+              if (strpos($this->externalWSDLURL, "http://") !== false) { // assume URL
+				$this->debug("In service, re-direct for WSDL");
+				header('Location: '.$this->externalWSDLURL);
+              } else { // assume file
+				$this->debug("In service, use file passthru for WSDL");
+                header("Content-Type: text/xml\r\n");
+				$pos = strpos($this->externalWSDLURL, "file://");
+				if ($pos === false) {
+					$filename = $this->externalWSDLURL;
+				} else {
+					$filename = substr($this->externalWSDLURL, $pos + 7);
+				}
+                $fp = fopen($this->externalWSDLURL, 'r');
+                fpassthru($fp);
+              }
+			} elseif ($this->wsdl) {
+				$this->debug("In service, serialize WSDL");
+				header("Content-Type: text/xml; charset=ISO-8859-1\r\n");
+				print $this->wsdl->serialize($this->debug_flag);
+				if ($this->debug_flag) {
+					$this->debug('wsdl:');
+					$this->appendDebug($this->varDump($this->wsdl));
+					print $this->getDebugAsXMLComment();
+				}
+			} else {
+				$this->debug("In service, there is no WSDL");
+				header("Content-Type: text/html; charset=ISO-8859-1\r\n");
+				print "This service does not provide WSDL";
+			}
+		} elseif ($this->wsdl) {
+			$this->debug("In service, return Web description");
+			print $this->wsdl->webDescription();
+		} else {
+			$this->debug("In service, no Web description");
+			header("Content-Type: text/html; charset=ISO-8859-1\r\n");
+			print "This service does not provide a Web description";
+		}
+	}
+
+	/**
+	* parses HTTP request headers.
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* headers
+	* request
+	* xml_encoding
+	* SOAPAction
+	*
+	* @access   private
+	*/
+	function parse_http_headers() {
+		global $HTTP_SERVER_VARS;
+
+		$this->request = '';
+		$this->SOAPAction = '';
+		if(function_exists('getallheaders')){
+			$this->debug("In parse_http_headers, use getallheaders");
+			$headers = getallheaders();
+			foreach($headers as $k=>$v){
+				$k = strtolower($k);
+				$this->headers[$k] = $v;
+				$this->request .= "$k: $v\r\n";
+				$this->debug("$k: $v");
+			}
+			// get SOAPAction header
+			if(isset($this->headers['soapaction'])){
+				$this->SOAPAction = str_replace('"','',$this->headers['soapaction']);
+			}
+			// get the character encoding of the incoming request
+			if(isset($this->headers['content-type']) && strpos($this->headers['content-type'],'=')){
+				$enc = str_replace('"','',substr(strstr($this->headers["content-type"],'='),1));
+				if(preg_match('/^(ISO-8859-1|US-ASCII|UTF-8)$/i',$enc)){
+					$this->xml_encoding = strtoupper($enc);
+				} else {
+					$this->xml_encoding = 'US-ASCII';
+				}
+			} else {
+				// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+				$this->xml_encoding = 'ISO-8859-1';
+			}
+		} elseif(isset($_SERVER) && is_array($_SERVER)){
+			$this->debug("In parse_http_headers, use _SERVER");
+			foreach ($_SERVER as $k => $v) {
+				if (substr($k, 0, 5) == 'HTTP_') {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', substr($k, 5))));
+				} else {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', $k)));
+				}
+				if ($k == 'soapaction') {
+					// get SOAPAction header
+					$k = 'SOAPAction';
+					$v = str_replace('"', '', $v);
+					$v = str_replace('\\', '', $v);
+					$this->SOAPAction = $v;
+				} else if ($k == 'content-type') {
+					// get the character encoding of the incoming request
+					if (strpos($v, '=')) {
+						$enc = substr(strstr($v, '='), 1);
+						$enc = str_replace('"', '', $enc);
+						$enc = str_replace('\\', '', $enc);
+						if (preg_match('/^(ISO-8859-1|US-ASCII|UTF-8)$/i',$enc)) {
+							$this->xml_encoding = strtoupper($enc);
+						} else {
+							$this->xml_encoding = 'US-ASCII';
+						}
+					} else {
+						// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+						$this->xml_encoding = 'ISO-8859-1';
+					}
+				}
+				$this->headers[$k] = $v;
+				$this->request .= "$k: $v\r\n";
+				$this->debug("$k: $v");
+			}
+		} elseif (is_array($HTTP_SERVER_VARS)) {
+			$this->debug("In parse_http_headers, use HTTP_SERVER_VARS");
+			foreach ($HTTP_SERVER_VARS as $k => $v) {
+				if (substr($k, 0, 5) == 'HTTP_') {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', substr($k, 5)))); 	                                         $k = strtolower(substr($k, 5));
+				} else {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', $k))); 	                                         $k = strtolower($k);
+				}
+				if ($k == 'soapaction') {
+					// get SOAPAction header
+					$k = 'SOAPAction';
+					$v = str_replace('"', '', $v);
+					$v = str_replace('\\', '', $v);
+					$this->SOAPAction = $v;
+				} else if ($k == 'content-type') {
+					// get the character encoding of the incoming request
+					if (strpos($v, '=')) {
+						$enc = substr(strstr($v, '='), 1);
+						$enc = str_replace('"', '', $enc);
+						$enc = str_replace('\\', '', $enc);
+						if (preg_match('/^(ISO-8859-1|US-ASCII|UTF-8)$/i',$enc)) {
+							$this->xml_encoding = strtoupper($enc);
+						} else {
+							$this->xml_encoding = 'US-ASCII';
+						}
+					} else {
+						// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+						$this->xml_encoding = 'ISO-8859-1';
+					}
+				}
+				$this->headers[$k] = $v;
+				$this->request .= "$k: $v\r\n";
+				$this->debug("$k: $v");
+			}
+		} else {
+			$this->debug("In parse_http_headers, HTTP headers not accessible");
+			$this->setError("HTTP headers not accessible");
+		}
+	}
+
+	/**
+	* parses a request
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* headers
+	* request
+	* xml_encoding
+	* SOAPAction
+	* request
+	* requestSOAP
+	* methodURI
+	* methodname
+	* methodparams
+	* requestHeaders
+	* document
+	*
+	* This sets the fault field on error
+	*
+	* @param    string $data XML string
+	* @access   private
+	*/
+	function parse_request($data='') {
+		$this->debug('entering parse_request()');
+		$this->parse_http_headers();
+		$this->debug('got character encoding: '.$this->xml_encoding);
+		// uncompress if necessary
+		if (isset($this->headers['content-encoding']) && $this->headers['content-encoding'] != '') {
+			$this->debug('got content encoding: ' . $this->headers['content-encoding']);
+			if ($this->headers['content-encoding'] == 'deflate' || $this->headers['content-encoding'] == 'gzip') {
+		    	// if decoding works, use it. else assume data wasn't gzencoded
+				if (function_exists('gzuncompress')) {
+					if ($this->headers['content-encoding'] == 'deflate' && $degzdata = @gzuncompress($data)) {
+						$data = $degzdata;
+					} elseif ($this->headers['content-encoding'] == 'gzip' && $degzdata = gzinflate(substr($data, 10))) {
+						$data = $degzdata;
+					} else {
+						$this->fault('SOAP-ENV:Client', 'Errors occurred when trying to decode the data');
+						return;
+					}
+				} else {
+					$this->fault('SOAP-ENV:Client', 'This Server does not support compressed data');
+					return;
+				}
+			}
+		}
+		$this->request .= "\r\n".$data;
+		$data = $this->parseRequest($this->headers, $data);
+		$this->requestSOAP = $data;
+		$this->debug('leaving parse_request');
+	}
+
+	/**
+	* invokes a PHP function for the requested SOAP method
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* methodreturn
+	*
+	* Note that the PHP function that is called may also set the following
+	* fields to affect the response sent to the client
+	*
+	* responseHeaders
+	* outgoing_headers
+	*
+	* This sets the fault field on error
+	*
+	* @access   private
+	*/
+	function invoke_method() {
+		$this->debug('in invoke_method, methodname=' . $this->methodname . ' methodURI=' . $this->methodURI . ' SOAPAction=' . $this->SOAPAction);
+
+		//
+		// if you are debugging in this area of the code, your service uses a class to implement methods,
+		// you use SOAP RPC, and the client is .NET, please be aware of the following...
+		// when the .NET wsdl.exe utility generates a proxy, it will remove the '.' or '..' from the
+		// method name.  that is fine for naming the .NET methods.  it is not fine for properly constructing
+		// the XML request and reading the XML response.  you need to add the RequestElementName and
+		// ResponseElementName to the System.Web.Services.Protocols.SoapRpcMethodAttribute that wsdl.exe
+		// generates for the method.  these parameters are used to specify the correct XML element names
+		// for .NET to use, i.e. the names with the '.' in them.
+		//
+		$orig_methodname = $this->methodname;
+		if ($this->wsdl) {
+			if ($this->opData = $this->wsdl->getOperationData($this->methodname)) {
+				$this->debug('in invoke_method, found WSDL operation=' . $this->methodname);
+				$this->appendDebug('opData=' . $this->varDump($this->opData));
+			} elseif ($this->opData = $this->wsdl->getOperationDataForSoapAction($this->SOAPAction)) {
+				// Note: hopefully this case will only be used for doc/lit, since rpc services should have wrapper element
+				$this->debug('in invoke_method, found WSDL soapAction=' . $this->SOAPAction . ' for operation=' . $this->opData['name']);
+				$this->appendDebug('opData=' . $this->varDump($this->opData));
+				$this->methodname = $this->opData['name'];
+			} else {
+				$this->debug('in invoke_method, no WSDL for operation=' . $this->methodname);
+				$this->fault('SOAP-ENV:Client', "Operation '" . $this->methodname . "' is not defined in the WSDL for this service");
+				return;
+			}
+		} else {
+			$this->debug('in invoke_method, no WSDL to validate method');
+		}
+
+		// if a . is present in $this->methodname, we see if there is a class in scope,
+		// which could be referred to. We will also distinguish between two deliminators,
+		// to allow methods to be called a the class or an instance
+		if (strpos($this->methodname, '..') > 0) {
+			$delim = '..';
+		} else if (strpos($this->methodname, '.') > 0) {
+			$delim = '.';
+		} else {
+			$delim = '';
+		}
+		$this->debug("in invoke_method, delim=$delim");
+
+		$class = '';
+		$method = '';
+		if (strlen($delim) > 0 && substr_count($this->methodname, $delim) == 1) {
+			$try_class = substr($this->methodname, 0, strpos($this->methodname, $delim));
+			if (class_exists($try_class)) {
+				// get the class and method name
+				$class = $try_class;
+				$method = substr($this->methodname, strpos($this->methodname, $delim) + strlen($delim));
+				$this->debug("in invoke_method, class=$class method=$method delim=$delim");
+			} else {
+				$this->debug("in invoke_method, class=$try_class not found");
+			}
+		} else {
+			$try_class = '';
+			$this->debug("in invoke_method, no class to try");
+		}
+
+		// does method exist?
+		if ($class == '') {
+			if (!function_exists($this->methodname)) {
+				$this->debug("in invoke_method, function '$this->methodname' not found!");
+				$this->result = 'fault: method not found';
+				$this->fault('SOAP-ENV:Client',"method '$this->methodname'('$orig_methodname') not defined in service('$try_class' '$delim')");
+				return;
+			}
+		} else {
+			$method_to_compare = (substr(phpversion(), 0, 2) == '4.') ? strtolower($method) : $method;
+			if (!in_array($method_to_compare, get_class_methods($class))) {
+				$this->debug("in invoke_method, method '$this->methodname' not found in class '$class'!");
+				$this->result = 'fault: method not found';
+				$this->fault('SOAP-ENV:Client',"method '$this->methodname'/'$method_to_compare'('$orig_methodname') not defined in service/'$class'('$try_class' '$delim')");
+				return;
+			}
+		}
+
+		// evaluate message, getting back parameters
+		// verify that request parameters match the method's signature
+		if(! $this->verify_method($this->methodname,$this->methodparams)){
+			// debug
+			$this->debug('ERROR: request not verified against method signature');
+			$this->result = 'fault: request failed validation against method signature';
+			// return fault
+			$this->fault('SOAP-ENV:Client',"Operation '$this->methodname' not defined in service.");
+			return;
+		}
+
+		// if there are parameters to pass
+		$this->debug('in invoke_method, params:');
+		$this->appendDebug($this->varDump($this->methodparams));
+		$this->debug("in invoke_method, calling '$this->methodname'");
+		if (!function_exists('call_user_func_array')) {
+			if ($class == '') {
+				$this->debug('in invoke_method, calling function using eval()');
+				$funcCall = "\$this->methodreturn = $this->methodname(";
+			} else {
+				if ($delim == '..') {
+					$this->debug('in invoke_method, calling class method using eval()');
+					$funcCall = "\$this->methodreturn = ".$class."::".$method."(";
+				} else {
+					$this->debug('in invoke_method, calling instance method using eval()');
+					// generate unique instance name
+					$instname = "\$inst_".time();
+					$funcCall = $instname." = new ".$class."(); ";
+					$funcCall .= "\$this->methodreturn = ".$instname."->".$method."(";
+				}
+			}
+			if ($this->methodparams) {
+				foreach ($this->methodparams as $param) {
+					if (is_array($param) || is_object($param)) {
+						$this->fault('SOAP-ENV:Client', 'NuSOAP does not handle complexType parameters correctly when using eval; call_user_func_array must be available');
+						return;
+					}
+					$funcCall .= "\"$param\",";
+				}
+				$funcCall = substr($funcCall, 0, -1);
+			}
+			$funcCall .= ');';
+			$this->debug('in invoke_method, function call: '.$funcCall);
+			@eval($funcCall);
+		} else {
+			if ($class == '') {
+				$this->debug('in invoke_method, calling function using call_user_func_array()');
+				$call_arg = "$this->methodname";	// straight assignment changes $this->methodname to lower case after call_user_func_array()
+			} elseif ($delim == '..') {
+				$this->debug('in invoke_method, calling class method using call_user_func_array()');
+				$call_arg = array ($class, $method);
+			} else {
+				$this->debug('in invoke_method, calling instance method using call_user_func_array()');
+				$instance = new $class ();
+				$call_arg = array(&$instance, $method);
+			}
+			if (is_array($this->methodparams)) {
+				$this->methodreturn = call_user_func_array($call_arg, array_values($this->methodparams));
+			} else {
+				$this->methodreturn = call_user_func_array($call_arg, array());
+			}
+		}
+        $this->debug('in invoke_method, methodreturn:');
+        $this->appendDebug($this->varDump($this->methodreturn));
+		$this->debug("in invoke_method, called method $this->methodname, received data of type ".gettype($this->methodreturn));
+	}
+
+	/**
+	* serializes the return value from a PHP function into a full SOAP Envelope
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* responseSOAP
+	*
+	* This sets the fault field on error
+	*
+	* @access   private
+	*/
+	function serialize_return() {
+		$this->debug('Entering serialize_return methodname: ' . $this->methodname . ' methodURI: ' . $this->methodURI);
+		// if fault
+		if (isset($this->methodreturn) && is_object($this->methodreturn) && ((get_class($this->methodreturn) == 'soap_fault') || (get_class($this->methodreturn) == 'nusoap_fault'))) {
+			$this->debug('got a fault object from method');
+			$this->fault = $this->methodreturn;
+			return;
+		} elseif ($this->methodreturnisliteralxml) {
+			$return_val = $this->methodreturn;
+		// returned value(s)
+		} else {
+			$this->debug('got a(n) '.gettype($this->methodreturn).' from method');
+			$this->debug('serializing return value');
+			if($this->wsdl){
+				if (sizeof($this->opData['output']['parts']) > 1) {
+					$this->debug('more than one output part, so use the method return unchanged');
+			    	$opParams = $this->methodreturn;
+			    } elseif (sizeof($this->opData['output']['parts']) == 1) {
+					$this->debug('exactly one output part, so wrap the method return in a simple array');
+					// TODO: verify that it is not already wrapped!
+			    	//foreach ($this->opData['output']['parts'] as $name => $type) {
+					//	$this->debug('wrap in element named ' . $name);
+			    	//}
+			    	$opParams = array($this->methodreturn);
+			    }
+			    $return_val = $this->wsdl->serializeRPCParameters($this->methodname,'output',$opParams);
+			    $this->appendDebug($this->wsdl->getDebug());
+			    $this->wsdl->clearDebug();
+				if($errstr = $this->wsdl->getError()){
+					$this->debug('got wsdl error: '.$errstr);
+					$this->fault('SOAP-ENV:Server', 'unable to serialize result');
+					return;
+				}
+			} else {
+				if (isset($this->methodreturn)) {
+					$return_val = $this->serialize_val($this->methodreturn, 'return');
+				} else {
+					$return_val = '';
+					$this->debug('in absence of WSDL, assume void return for backward compatibility');
+				}
+			}
+		}
+		$this->debug('return value:');
+		$this->appendDebug($this->varDump($return_val));
+
+		$this->debug('serializing response');
+		if ($this->wsdl) {
+			$this->debug('have WSDL for serialization: style is ' . $this->opData['style']);
+			if ($this->opData['style'] == 'rpc') {
+				$this->debug('style is rpc for serialization: use is ' . $this->opData['output']['use']);
+				if ($this->opData['output']['use'] == 'literal') {
+					// http://www.ws-i.org/Profiles/BasicProfile-1.1-2004-08-24.html R2735 says rpc/literal accessor elements should not be in a namespace
+					if ($this->methodURI) {
+						$payload = '<ns1:'.$this->methodname.'Response xmlns:ns1="'.$this->methodURI.'">'.$return_val.'</ns1:'.$this->methodname."Response>";
+					} else {
+						$payload = '<'.$this->methodname.'Response>'.$return_val.'</'.$this->methodname.'Response>';
+					}
+				} else {
+					if ($this->methodURI) {
+						$payload = '<ns1:'.$this->methodname.'Response xmlns:ns1="'.$this->methodURI.'">'.$return_val.'</ns1:'.$this->methodname."Response>";
+					} else {
+						$payload = '<'.$this->methodname.'Response>'.$return_val.'</'.$this->methodname.'Response>';
+					}
+				}
+			} else {
+				$this->debug('style is not rpc for serialization: assume document');
+				$payload = $return_val;
+			}
+		} else {
+			$this->debug('do not have WSDL for serialization: assume rpc/encoded');
+			$payload = '<ns1:'.$this->methodname.'Response xmlns:ns1="'.$this->methodURI.'">'.$return_val.'</ns1:'.$this->methodname."Response>";
+		}
+		$this->result = 'successful';
+		if($this->wsdl){
+			//if($this->debug_flag){
+            	$this->appendDebug($this->wsdl->getDebug());
+            //	}
+			if (isset($this->opData['output']['encodingStyle'])) {
+				$encodingStyle = $this->opData['output']['encodingStyle'];
+			} else {
+				$encodingStyle = '';
+			}
+			// Added: In case we use a WSDL, return a serialized env. WITH the usedNamespaces.
+			$this->responseSOAP = $this->serializeEnvelope($payload,$this->responseHeaders,$this->wsdl->usedNamespaces,$this->opData['style'],$this->opData['output']['use'],$encodingStyle);
+		} else {
+			$this->responseSOAP = $this->serializeEnvelope($payload,$this->responseHeaders);
+		}
+		$this->debug("Leaving serialize_return");
+	}
+
+	/**
+	* sends an HTTP response
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* outgoing_headers
+	* response
+	*
+	* @access   private
+	*/
+	function send_response() {
+		$this->debug('Enter send_response');
+		if ($this->fault) {
+			$payload = $this->fault->serialize();
+			$this->outgoing_headers[] = "HTTP/1.0 500 Internal Server Error";
+			$this->outgoing_headers[] = "Status: 500 Internal Server Error";
+		} else {
+			$payload = $this->responseSOAP;
+			// Some combinations of PHP+Web server allow the Status
+			// to come through as a header.  Since OK is the default
+			// just do nothing.
+			// $this->outgoing_headers[] = "HTTP/1.0 200 OK";
+			// $this->outgoing_headers[] = "Status: 200 OK";
+		}
+        // add debug data if in debug mode
+		if(isset($this->debug_flag) && $this->debug_flag){
+        	$payload .= $this->getDebugAsXMLComment();
+        }
+		$this->outgoing_headers[] = "Server: $this->title Server v$this->version";
+		preg_match('/\$Revisio' . 'n: ([^ ]+)/', $this->revision, $rev);
+		$this->outgoing_headers[] = "X-SOAP-Server: $this->title/$this->version (".$rev[1].")";
+		// Let the Web server decide about this
+		//$this->outgoing_headers[] = "Connection: Close\r\n";
+		$payload = $this->getHTTPBody($payload);
+		$type = $this->getHTTPContentType();
+		$charset = $this->getHTTPContentTypeCharset();
+		$this->outgoing_headers[] = "Content-Type: $type" . ($charset ? '; charset=' . $charset : '');
+		//begin code to compress payload - by John
+		// NOTE: there is no way to know whether the Web server will also compress
+		// this data.
+		if (strlen($payload) > 1024 && isset($this->headers) && isset($this->headers['accept-encoding'])) {	
+			if (strstr($this->headers['accept-encoding'], 'gzip')) {
+				if (function_exists('gzencode')) {
+					if (isset($this->debug_flag) && $this->debug_flag) {
+						$payload .= "<!-- Content being gzipped -->";
+					}
+					$this->outgoing_headers[] = "Content-Encoding: gzip";
+					$payload = gzencode($payload);
+				} else {
+					if (isset($this->debug_flag) && $this->debug_flag) {
+						$payload .= "<!-- Content will not be gzipped: no gzencode -->";
+					}
+				}
+			} elseif (strstr($this->headers['accept-encoding'], 'deflate')) {
+				// Note: MSIE requires gzdeflate output (no Zlib header and checksum),
+				// instead of gzcompress output,
+				// which conflicts with HTTP 1.1 spec (http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.5)
+				if (function_exists('gzdeflate')) {
+					if (isset($this->debug_flag) && $this->debug_flag) {
+						$payload .= "<!-- Content being deflated -->";
+					}
+					$this->outgoing_headers[] = "Content-Encoding: deflate";
+					$payload = gzdeflate($payload);
+				} else {
+					if (isset($this->debug_flag) && $this->debug_flag) {
+						$payload .= "<!-- Content will not be deflated: no gzcompress -->";
+					}
+				}
+			}
+		}
+		//end code
+		$this->outgoing_headers[] = "Content-Length: ".strlen($payload);
+		reset($this->outgoing_headers);
+		foreach($this->outgoing_headers as $hdr){
+			header($hdr, false);
+		}
+		print $payload;
+		$this->response = join("\r\n",$this->outgoing_headers)."\r\n\r\n".$payload;
+	}
+
+	/**
+	* takes the value that was created by parsing the request
+	* and compares to the method's signature, if available.
+	*
+	* @param	string	$operation	The operation to be invoked
+	* @param	array	$request	The array of parameter values
+	* @return	boolean	Whether the operation was found
+	* @access   private
+	*/
+	function verify_method($operation,$request){
+		if(isset($this->wsdl) && is_object($this->wsdl)){
+			if($this->wsdl->getOperationData($operation)){
+				return true;
+			}
+	    } elseif(isset($this->operations[$operation])){
+			return true;
+		}
+		return false;
+	}
+
+	/**
+	* processes SOAP message received from client
+	*
+	* @param	array	$headers	The HTTP headers
+	* @param	string	$data		unprocessed request data from client
+	* @return	mixed	value of the message, decoded into a PHP type
+	* @access   private
+	*/
+    function parseRequest($headers, $data) {
+		$this->debug('Entering parseRequest() for data of length ' . strlen($data) . ' headers:');
+		$this->appendDebug($this->varDump($headers));
+    	if (!isset($headers['content-type'])) {
+			$this->setError('Request not of type text/xml (no content-type header)');
+			return false;
+    	}
+		if (!strstr($headers['content-type'], 'text/xml')) {
+			$this->setError('Request not of type text/xml');
+			return false;
+		}
+		if (strpos($headers['content-type'], '=')) {
+			$enc = str_replace('"', '', substr(strstr($headers["content-type"], '='), 1));
+			$this->debug('Got response encoding: ' . $enc);
+			if(preg_match('/^(ISO-8859-1|US-ASCII|UTF-8)$/i',$enc)){
+				$this->xml_encoding = strtoupper($enc);
+			} else {
+				$this->xml_encoding = 'US-ASCII';
+			}
+		} else {
+			// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+			$this->xml_encoding = 'ISO-8859-1';
+		}
+		$this->debug('Use encoding: ' . $this->xml_encoding . ' when creating nusoap_parser');
+		// parse response, get soap parser obj
+		$parser = new nusoap_parser($data,$this->xml_encoding,'',$this->decode_utf8);
+		// parser debug
+		$this->debug("parser debug: \n".$parser->getDebug());
+		// if fault occurred during message parsing
+		if($err = $parser->getError()){
+			$this->result = 'fault: error in msg parsing: '.$err;
+			$this->fault('SOAP-ENV:Client',"error in msg parsing:\n".$err);
+		// else successfully parsed request into soapval object
+		} else {
+			// get/set methodname
+			$this->methodURI = $parser->root_struct_namespace;
+			$this->methodname = $parser->root_struct_name;
+			$this->debug('methodname: '.$this->methodname.' methodURI: '.$this->methodURI);
+			$this->debug('calling parser->get_soapbody()');
+			$this->methodparams = $parser->get_soapbody();
+			// get SOAP headers
+			$this->requestHeaders = $parser->getHeaders();
+			// get SOAP Header
+			$this->requestHeader = $parser->get_soapheader();
+            // add document for doclit support
+            $this->document = $parser->document;
+		}
+	 }
+
+	/**
+	* gets the HTTP body for the current response.
+	*
+	* @param string $soapmsg The SOAP payload
+	* @return string The HTTP body, which includes the SOAP payload
+	* @access private
+	*/
+	function getHTTPBody($soapmsg) {
+		return $soapmsg;
+	}
+	
+	/**
+	* gets the HTTP content type for the current response.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type for the current response.
+	* @access private
+	*/
+	function getHTTPContentType() {
+		return 'text/xml';
+	}
+	
+	/**
+	* gets the HTTP content type charset for the current response.
+	* returns false for non-text content types.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type charset for the current response.
+	* @access private
+	*/
+	function getHTTPContentTypeCharset() {
+		return $this->soap_defencoding;
+	}
+
+	/**
+	* add a method to the dispatch map (this has been replaced by the register method)
+	*
+	* @param    string $methodname
+	* @param    string $in array of input values
+	* @param    string $out array of output values
+	* @access   public
+	* @deprecated
+	*/
+	function add_to_map($methodname,$in,$out){
+			$this->operations[$methodname] = array('name' => $methodname,'in' => $in,'out' => $out);
+	}
+
+	/**
+	* register a service function with the server
+	*
+	* @param    string $name the name of the PHP function, class.method or class..method
+	* @param    array $in assoc array of input values: key = param name, value = param type
+	* @param    array $out assoc array of output values: key = param name, value = param type
+	* @param	mixed $namespace the element namespace for the method or false
+	* @param	mixed $soapaction the soapaction for the method or false
+	* @param	mixed $style optional (rpc|document) or false Note: when 'document' is specified, parameter and return wrappers are created for you automatically
+	* @param	mixed $use optional (encoded|literal) or false
+	* @param	string $documentation optional Description to include in WSDL
+	* @param	string $encodingStyle optional (usually 'http://schemas.xmlsoap.org/soap/encoding/' for encoded)
+	* @access   public
+	*/
+	function register($name,$in=array(),$out=array(),$namespace=false,$soapaction=false,$style=false,$use=false,$documentation='',$encodingStyle=''){
+		global $HTTP_SERVER_VARS;
+
+		if($this->externalWSDLURL){
+			die('You cannot bind to an external WSDL file, and register methods outside of it! Please choose either WSDL or no WSDL.');
+		}
+		if (! $name) {
+			die('You must specify a name when you register an operation');
+		}
+		if (!is_array($in)) {
+			die('You must provide an array for operation inputs');
+		}
+		if (!is_array($out)) {
+			die('You must provide an array for operation outputs');
+		}
+		if(false == $namespace) {
+		}
+		if(false == $soapaction) {
+			if (isset($_SERVER)) {
+				$SERVER_NAME = $_SERVER['SERVER_NAME'];
+				$SCRIPT_NAME = isset($_SERVER['PHP_SELF']) ? $_SERVER['PHP_SELF'] : $_SERVER['SCRIPT_NAME'];
+				$HTTPS = isset($_SERVER['HTTPS']) ? $_SERVER['HTTPS'] : (isset($HTTP_SERVER_VARS['HTTPS']) ? $HTTP_SERVER_VARS['HTTPS'] : 'off');
+			} elseif (isset($HTTP_SERVER_VARS)) {
+				$SERVER_NAME = $HTTP_SERVER_VARS['SERVER_NAME'];
+				$SCRIPT_NAME = isset($HTTP_SERVER_VARS['PHP_SELF']) ? $HTTP_SERVER_VARS['PHP_SELF'] : $HTTP_SERVER_VARS['SCRIPT_NAME'];
+				$HTTPS = isset($HTTP_SERVER_VARS['HTTPS']) ? $HTTP_SERVER_VARS['HTTPS'] : 'off';
+			} else {
+				$this->setError("Neither _SERVER nor HTTP_SERVER_VARS is available");
+			}
+        	if ($HTTPS == '1' || $HTTPS == 'on') {
+        		$SCHEME = 'https';
+        	} else {
+        		$SCHEME = 'http';
+        	}
+			$soapaction = "$SCHEME://$SERVER_NAME$SCRIPT_NAME/$name";
+		}
+		if(false == $style) {
+			$style = "rpc";
+		}
+		if(false == $use) {
+			$use = "encoded";
+		}
+		if ($use == 'encoded' && $encodingStyle == '') {
+			$encodingStyle = 'http://schemas.xmlsoap.org/soap/encoding/';
+		}
+
+		$this->operations[$name] = array(
+	    'name' => $name,
+	    'in' => $in,
+	    'out' => $out,
+	    'namespace' => $namespace,
+	    'soapaction' => $soapaction,
+	    'style' => $style);
+        if($this->wsdl){
+        	$this->wsdl->addOperation($name,$in,$out,$namespace,$soapaction,$style,$use,$documentation,$encodingStyle);
+	    }
+		return true;
+	}
+
+	/**
+	* Specify a fault to be returned to the client.
+	* This also acts as a flag to the server that a fault has occured.
+	*
+	* @param	string $faultcode
+	* @param	string $faultstring
+	* @param	string $faultactor
+	* @param	string $faultdetail
+	* @access   public
+	*/
+	function fault($faultcode,$faultstring,$faultactor='',$faultdetail=''){
+		if ($faultdetail == '' && $this->debug_flag) {
+			$faultdetail = $this->getDebug();
+		}
+		$this->fault = new nusoap_fault($faultcode,$faultactor,$faultstring,$faultdetail);
+		$this->fault->soap_defencoding = $this->soap_defencoding;
+	}
+
+    /**
+    * Sets up wsdl object.
+    * Acts as a flag to enable internal WSDL generation
+    *
+    * @param string $serviceName, name of the service
+    * @param mixed $namespace optional 'tns' service namespace or false
+    * @param mixed $endpoint optional URL of service endpoint or false
+    * @param string $style optional (rpc|document) WSDL style (also specified by operation)
+    * @param string $transport optional SOAP transport
+    * @param mixed $schemaTargetNamespace optional 'types' targetNamespace for service schema or false
+    */
+    function configureWSDL($serviceName,$namespace = false,$endpoint = false,$style='rpc', $transport = 'http://schemas.xmlsoap.org/soap/http', $schemaTargetNamespace = false)
+    {
+    	global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER)) {
+			$SERVER_NAME = $_SERVER['SERVER_NAME'];
+			$SERVER_PORT = $_SERVER['SERVER_PORT'];
+			$SCRIPT_NAME = isset($_SERVER['PHP_SELF']) ? $_SERVER['PHP_SELF'] : $_SERVER['SCRIPT_NAME'];
+			$HTTPS = isset($_SERVER['HTTPS']) ? $_SERVER['HTTPS'] : (isset($HTTP_SERVER_VARS['HTTPS']) ? $HTTP_SERVER_VARS['HTTPS'] : 'off');
+		} elseif (isset($HTTP_SERVER_VARS)) {
+			$SERVER_NAME = $HTTP_SERVER_VARS['SERVER_NAME'];
+			$SERVER_PORT = $HTTP_SERVER_VARS['SERVER_PORT'];
+			$SCRIPT_NAME = isset($HTTP_SERVER_VARS['PHP_SELF']) ? $HTTP_SERVER_VARS['PHP_SELF'] : $HTTP_SERVER_VARS['SCRIPT_NAME'];
+			$HTTPS = isset($HTTP_SERVER_VARS['HTTPS']) ? $HTTP_SERVER_VARS['HTTPS'] : 'off';
+		} else {
+			$this->setError("Neither _SERVER nor HTTP_SERVER_VARS is available");
+		}
+		// If server name has port number attached then strip it (else port number gets duplicated in WSDL output) (occurred using lighttpd and FastCGI)
+		$colon = strpos($SERVER_NAME,":");
+		if ($colon) {
+		    $SERVER_NAME = substr($SERVER_NAME, 0, $colon);
+		}
+		if ($SERVER_PORT == 80) {
+			$SERVER_PORT = '';
+		} else {
+			$SERVER_PORT = ':' . $SERVER_PORT;
+		}
+        if(false == $namespace) {
+            $namespace = "http://$SERVER_NAME/soap/$serviceName";
+        }
+        
+        if(false == $endpoint) {
+        	if ($HTTPS == '1' || $HTTPS == 'on') {
+        		$SCHEME = 'https';
+        	} else {
+        		$SCHEME = 'http';
+        	}
+            $endpoint = "$SCHEME://$SERVER_NAME$SERVER_PORT$SCRIPT_NAME";
+        }
+        
+        if(false == $schemaTargetNamespace) {
+            $schemaTargetNamespace = $namespace;
+        }
+        
+		$this->wsdl = new wsdl;
+		$this->wsdl->serviceName = $serviceName;
+        $this->wsdl->endpoint = $endpoint;
+		$this->wsdl->namespaces['tns'] = $namespace;
+		$this->wsdl->namespaces['soap'] = 'http://schemas.xmlsoap.org/wsdl/soap/';
+		$this->wsdl->namespaces['wsdl'] = 'http://schemas.xmlsoap.org/wsdl/';
+		if ($schemaTargetNamespace != $namespace) {
+			$this->wsdl->namespaces['types'] = $schemaTargetNamespace;
+		}
+        $this->wsdl->schemas[$schemaTargetNamespace][0] = new nusoap_xmlschema('', '', $this->wsdl->namespaces);
+        if ($style == 'document') {
+	        $this->wsdl->schemas[$schemaTargetNamespace][0]->schemaInfo['elementFormDefault'] = 'qualified';
+        }
+        $this->wsdl->schemas[$schemaTargetNamespace][0]->schemaTargetNamespace = $schemaTargetNamespace;
+        $this->wsdl->schemas[$schemaTargetNamespace][0]->imports['http://schemas.xmlsoap.org/soap/encoding/'][0] = array('location' => '', 'loaded' => true);
+        $this->wsdl->schemas[$schemaTargetNamespace][0]->imports['http://schemas.xmlsoap.org/wsdl/'][0] = array('location' => '', 'loaded' => true);
+        $this->wsdl->bindings[$serviceName.'Binding'] = array(
+        	'name'=>$serviceName.'Binding',
+            'style'=>$style,
+            'transport'=>$transport,
+            'portType'=>$serviceName.'PortType');
+        $this->wsdl->ports[$serviceName.'Port'] = array(
+        	'binding'=>$serviceName.'Binding',
+            'location'=>$endpoint,
+            'bindingType'=>'http://schemas.xmlsoap.org/wsdl/soap/');
+    }
+}
+
+/**
+ * Backward compatibility
+ */
+class soap_server extends nusoap_server {
+}
+
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/ecrire/nusoap/class.soap_transport_http.php spip/ecrire/nusoap/class.soap_transport_http.php
--- spip-ori/ecrire/nusoap/class.soap_transport_http.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nusoap/class.soap_transport_http.php	2013-04-05 11:06:41.157923139 +0200
@@ -0,0 +1,1307 @@
+<?php
+
+
+
+
+/**
+* transport class for sending/receiving data via HTTP and HTTPS
+* NOTE: PHP must be compiled with the CURL extension for HTTPS support
+*
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @version  $Id: class.soap_transport_http.php,v 1.68 2010/04/26 20:15:08 snichol Exp $
+* @access public
+*/
+class soap_transport_http extends nusoap_base {
+
+	var $url = '';
+	var $uri = '';
+	var $digest_uri = '';
+	var $scheme = '';
+	var $host = '';
+	var $port = '';
+	var $path = '';
+	var $request_method = 'POST';
+	var $protocol_version = '1.0';
+	var $encoding = '';
+	var $outgoing_headers = array();
+	var $incoming_headers = array();
+	var $incoming_cookies = array();
+	var $outgoing_payload = '';
+	var $incoming_payload = '';
+	var $response_status_line;	// HTTP response status line
+	var $useSOAPAction = true;
+	var $persistentConnection = false;
+	var $ch = false;	// cURL handle
+	var $ch_options = array();	// cURL custom options
+	var $use_curl = false;		// force cURL use
+	var $proxy = null;			// proxy information (associative array)
+	var $username = '';
+	var $password = '';
+	var $authtype = '';
+	var $digestRequest = array();
+	var $certRequest = array();	// keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, certpassword (optional), verifypeer (optional), verifyhost (optional)
+								// cainfofile: certificate authority file, e.g. '$pathToPemFiles/rootca.pem'
+								// sslcertfile: SSL certificate file, e.g. '$pathToPemFiles/mycert.pem'
+								// sslkeyfile: SSL key file, e.g. '$pathToPemFiles/mykey.pem'
+								// passphrase: SSL key password/passphrase
+								// certpassword: SSL certificate password
+								// verifypeer: default is 1
+								// verifyhost: default is 1
+
+	/**
+	* constructor
+	*
+	* @param string $url The URL to which to connect
+	* @param array $curl_options User-specified cURL options
+	* @param boolean $use_curl Whether to try to force cURL use
+	* @access public
+	*/
+	function soap_transport_http($url, $curl_options = NULL, $use_curl = false){
+		parent::nusoap_base();
+		$this->debug("ctor url=$url use_curl=$use_curl curl_options:");
+		$this->appendDebug($this->varDump($curl_options));
+		$this->setURL($url);
+		if (is_array($curl_options)) {
+			$this->ch_options = $curl_options;
+		}
+		$this->use_curl = $use_curl;
+		preg_match('/\$Revisio' . 'n: ([^ ]+)/', $this->revision, $rev);
+		$this->setHeader('User-Agent', $this->title.'/'.$this->version.' ('.$rev[1].')');
+	}
+
+	/**
+	* sets a cURL option
+	*
+	* @param	mixed $option The cURL option (always integer?)
+	* @param	mixed $value The cURL option value
+	* @access   private
+	*/
+	function setCurlOption($option, $value) {
+		$this->debug("setCurlOption option=$option, value=");
+		$this->appendDebug($this->varDump($value));
+		curl_setopt($this->ch, $option, $value);
+	}
+
+	/**
+	* sets an HTTP header
+	*
+	* @param string $name The name of the header
+	* @param string $value The value of the header
+	* @access private
+	*/
+	function setHeader($name, $value) {
+		$this->outgoing_headers[$name] = $value;
+		$this->debug("set header $name: $value");
+	}
+
+	/**
+	* unsets an HTTP header
+	*
+	* @param string $name The name of the header
+	* @access private
+	*/
+	function unsetHeader($name) {
+		if (isset($this->outgoing_headers[$name])) {
+			$this->debug("unset header $name");
+			unset($this->outgoing_headers[$name]);
+		}
+	}
+
+	/**
+	* sets the URL to which to connect
+	*
+	* @param string $url The URL to which to connect
+	* @access private
+	*/
+	function setURL($url) {
+		$this->url = $url;
+
+		$u = parse_url($url);
+		foreach($u as $k => $v){
+			$this->debug("parsed URL $k = $v");
+			$this->$k = $v;
+		}
+		
+		// add any GET params to path
+		if(isset($u['query']) && $u['query'] != ''){
+            $this->path .= '?' . $u['query'];
+		}
+		
+		// set default port
+		if(!isset($u['port'])){
+			if($u['scheme'] == 'https'){
+				$this->port = 443;
+			} else {
+				$this->port = 80;
+			}
+		}
+		
+		$this->uri = $this->path;
+		$this->digest_uri = $this->uri;
+		
+		// build headers
+		if (!isset($u['port'])) {
+			$this->setHeader('Host', $this->host);
+		} else {
+			$this->setHeader('Host', $this->host.':'.$this->port);
+		}
+
+		if (isset($u['user']) && $u['user'] != '') {
+			$this->setCredentials(urldecode($u['user']), isset($u['pass']) ? urldecode($u['pass']) : '');
+		}
+	}
+
+	/**
+	* gets the I/O method to use
+	*
+	* @return	string	I/O method to use (socket|curl|unknown)
+	* @access	private
+	*/
+	function io_method() {
+		if ($this->use_curl || ($this->scheme == 'https') || ($this->scheme == 'http' && $this->authtype == 'ntlm') || ($this->scheme == 'http' && is_array($this->proxy) && $this->proxy['authtype'] == 'ntlm'))
+			return 'curl';
+		if (($this->scheme == 'http' || $this->scheme == 'ssl') && $this->authtype != 'ntlm' && (!is_array($this->proxy) || $this->proxy['authtype'] != 'ntlm'))
+			return 'socket';
+		return 'unknown';
+	}
+
+	/**
+	* establish an HTTP connection
+	*
+	* @param    integer $timeout set connection timeout in seconds
+	* @param	integer $response_timeout set response timeout in seconds
+	* @return	boolean true if connected, false if not
+	* @access   private
+	*/
+	function connect($connection_timeout=0,$response_timeout=30){
+	  	// For PHP 4.3 with OpenSSL, change https scheme to ssl, then treat like
+	  	// "regular" socket.
+	  	// TODO: disabled for now because OpenSSL must be *compiled* in (not just
+	  	//       loaded), and until PHP5 stream_get_wrappers is not available.
+//	  	if ($this->scheme == 'https') {
+//		  	if (version_compare(phpversion(), '4.3.0') >= 0) {
+//		  		if (extension_loaded('openssl')) {
+//		  			$this->scheme = 'ssl';
+//		  			$this->debug('Using SSL over OpenSSL');
+//		  		}
+//		  	}
+//		}
+		$this->debug("connect connection_timeout $connection_timeout, response_timeout $response_timeout, scheme $this->scheme, host $this->host, port $this->port");
+	  if ($this->io_method() == 'socket') {
+		if (!is_array($this->proxy)) {
+			$host = $this->host;
+			$port = $this->port;
+		} else {
+			$host = $this->proxy['host'];
+			$port = $this->proxy['port'];
+		}
+
+		// use persistent connection
+		if($this->persistentConnection && isset($this->fp) && is_resource($this->fp)){
+			if (!feof($this->fp)) {
+				$this->debug('Re-use persistent connection');
+				return true;
+			}
+			fclose($this->fp);
+			$this->debug('Closed persistent connection at EOF');
+		}
+
+		// munge host if using OpenSSL
+		if ($this->scheme == 'ssl') {
+			$host = 'ssl://' . $host;
+		}
+		$this->debug('calling fsockopen with host ' . $host . ' connection_timeout ' . $connection_timeout);
+
+		// open socket
+		if($connection_timeout > 0){
+			$this->fp = @fsockopen( $host, $this->port, $this->errno, $this->error_str, $connection_timeout);
+		} else {
+			$this->fp = @fsockopen( $host, $this->port, $this->errno, $this->error_str);
+		}
+		
+		// test pointer
+		if(!$this->fp) {
+			$msg = 'Couldn\'t open socket connection to server ' . $this->url;
+			if ($this->errno) {
+				$msg .= ', Error ('.$this->errno.'): '.$this->error_str;
+			} else {
+				$msg .= ' prior to connect().  This is often a problem looking up the host name.';
+			}
+			$this->debug($msg);
+			$this->setError($msg);
+			return false;
+		}
+		
+		// set response timeout
+		$this->debug('set response timeout to ' . $response_timeout);
+		socket_set_timeout( $this->fp, $response_timeout);
+
+		$this->debug('socket connected');
+		return true;
+	  } else if ($this->io_method() == 'curl') {
+		if (!extension_loaded('curl')) {
+//			$this->setError('cURL Extension, or OpenSSL extension w/ PHP version >= 4.3 is required for HTTPS');
+			$this->setError('The PHP cURL Extension is required for HTTPS or NLTM.  You will need to re-build or update your PHP to include cURL or change php.ini to load the PHP cURL extension.');
+			return false;
+		}
+		// Avoid warnings when PHP does not have these options
+		if (defined('CURLOPT_CONNECTIONTIMEOUT'))
+			$CURLOPT_CONNECTIONTIMEOUT = CURLOPT_CONNECTIONTIMEOUT;
+		else
+			$CURLOPT_CONNECTIONTIMEOUT = 78;
+		if (defined('CURLOPT_HTTPAUTH'))
+			$CURLOPT_HTTPAUTH = CURLOPT_HTTPAUTH;
+		else
+			$CURLOPT_HTTPAUTH = 107;
+		if (defined('CURLOPT_PROXYAUTH'))
+			$CURLOPT_PROXYAUTH = CURLOPT_PROXYAUTH;
+		else
+			$CURLOPT_PROXYAUTH = 111;
+		if (defined('CURLAUTH_BASIC'))
+			$CURLAUTH_BASIC = CURLAUTH_BASIC;
+		else
+			$CURLAUTH_BASIC = 1;
+		if (defined('CURLAUTH_DIGEST'))
+			$CURLAUTH_DIGEST = CURLAUTH_DIGEST;
+		else
+			$CURLAUTH_DIGEST = 2;
+		if (defined('CURLAUTH_NTLM'))
+			$CURLAUTH_NTLM = CURLAUTH_NTLM;
+		else
+			$CURLAUTH_NTLM = 8;
+
+		$this->debug('connect using cURL');
+		// init CURL
+		$this->ch = curl_init();
+		// set url
+		$hostURL = ($this->port != '') ? "$this->scheme://$this->host:$this->port" : "$this->scheme://$this->host";
+		// add path
+		$hostURL .= $this->path;
+		$this->setCurlOption(CURLOPT_URL, $hostURL);
+		// follow location headers (re-directs)
+		if (ini_get('safe_mode') || ini_get('open_basedir')) {
+			$this->debug('safe_mode or open_basedir set, so do not set CURLOPT_FOLLOWLOCATION');
+			$this->debug('safe_mode = ');
+			$this->appendDebug($this->varDump(ini_get('safe_mode')));
+			$this->debug('open_basedir = ');
+			$this->appendDebug($this->varDump(ini_get('open_basedir')));
+		} else {
+			$this->setCurlOption(CURLOPT_FOLLOWLOCATION, 1);
+		}
+		// ask for headers in the response output
+		$this->setCurlOption(CURLOPT_HEADER, 1);
+		// ask for the response output as the return value
+		$this->setCurlOption(CURLOPT_RETURNTRANSFER, 1);
+		// encode
+		// We manage this ourselves through headers and encoding
+//		if(function_exists('gzuncompress')){
+//			$this->setCurlOption(CURLOPT_ENCODING, 'deflate');
+//		}
+		// persistent connection
+		if ($this->persistentConnection) {
+			// I believe the following comment is now bogus, having applied to
+			// the code when it used CURLOPT_CUSTOMREQUEST to send the request.
+			// The way we send data, we cannot use persistent connections, since
+			// there will be some "junk" at the end of our request.
+			//$this->setCurlOption(CURL_HTTP_VERSION_1_1, true);
+			$this->persistentConnection = false;
+			$this->setHeader('Connection', 'close');
+		}
+		// set timeouts
+		if ($connection_timeout != 0) {
+			$this->setCurlOption($CURLOPT_CONNECTIONTIMEOUT, $connection_timeout);
+		}
+		if ($response_timeout != 0) {
+			$this->setCurlOption(CURLOPT_TIMEOUT, $response_timeout);
+		}
+
+		if ($this->scheme == 'https') {
+			$this->debug('set cURL SSL verify options');
+			// recent versions of cURL turn on peer/host checking by default,
+			// while PHP binaries are not compiled with a default location for the
+			// CA cert bundle, so disable peer/host checking.
+			//$this->setCurlOption(CURLOPT_CAINFO, 'f:\php-4.3.2-win32\extensions\curl-ca-bundle.crt');		
+			$this->setCurlOption(CURLOPT_SSL_VERIFYPEER, 0);
+			$this->setCurlOption(CURLOPT_SSL_VERIFYHOST, 0);
+	
+			// support client certificates (thanks Tobias Boes, Doug Anarino, Eryan Ariobowo)
+			if ($this->authtype == 'certificate') {
+				$this->debug('set cURL certificate options');
+				if (isset($this->certRequest['cainfofile'])) {
+					$this->setCurlOption(CURLOPT_CAINFO, $this->certRequest['cainfofile']);
+				}
+				if (isset($this->certRequest['verifypeer'])) {
+					$this->setCurlOption(CURLOPT_SSL_VERIFYPEER, $this->certRequest['verifypeer']);
+				} else {
+					$this->setCurlOption(CURLOPT_SSL_VERIFYPEER, 1);
+				}
+				if (isset($this->certRequest['verifyhost'])) {
+					$this->setCurlOption(CURLOPT_SSL_VERIFYHOST, $this->certRequest['verifyhost']);
+				} else {
+					$this->setCurlOption(CURLOPT_SSL_VERIFYHOST, 1);
+				}
+				if (isset($this->certRequest['sslcertfile'])) {
+					$this->setCurlOption(CURLOPT_SSLCERT, $this->certRequest['sslcertfile']);
+				}
+				if (isset($this->certRequest['sslkeyfile'])) {
+					$this->setCurlOption(CURLOPT_SSLKEY, $this->certRequest['sslkeyfile']);
+				}
+				if (isset($this->certRequest['passphrase'])) {
+					$this->setCurlOption(CURLOPT_SSLKEYPASSWD, $this->certRequest['passphrase']);
+				}
+				if (isset($this->certRequest['certpassword'])) {
+					$this->setCurlOption(CURLOPT_SSLCERTPASSWD, $this->certRequest['certpassword']);
+				}
+			}
+		}
+		if ($this->authtype && ($this->authtype != 'certificate')) {
+			if ($this->username) {
+				$this->debug('set cURL username/password');
+				$this->setCurlOption(CURLOPT_USERPWD, "$this->username:$this->password");
+			}
+			if ($this->authtype == 'basic') {
+				$this->debug('set cURL for Basic authentication');
+				$this->setCurlOption($CURLOPT_HTTPAUTH, $CURLAUTH_BASIC);
+			}
+			if ($this->authtype == 'digest') {
+				$this->debug('set cURL for digest authentication');
+				$this->setCurlOption($CURLOPT_HTTPAUTH, $CURLAUTH_DIGEST);
+			}
+			if ($this->authtype == 'ntlm') {
+				$this->debug('set cURL for NTLM authentication');
+				$this->setCurlOption($CURLOPT_HTTPAUTH, $CURLAUTH_NTLM);
+			}
+		}
+		if (is_array($this->proxy)) {
+			$this->debug('set cURL proxy options');
+			if ($this->proxy['port'] != '') {
+				$this->setCurlOption(CURLOPT_PROXY, $this->proxy['host'].':'.$this->proxy['port']);
+			} else {
+				$this->setCurlOption(CURLOPT_PROXY, $this->proxy['host']);
+			}
+			if ($this->proxy['username'] || $this->proxy['password']) {
+				$this->debug('set cURL proxy authentication options');
+				$this->setCurlOption(CURLOPT_PROXYUSERPWD, $this->proxy['username'].':'.$this->proxy['password']);
+				if ($this->proxy['authtype'] == 'basic') {
+					$this->setCurlOption($CURLOPT_PROXYAUTH, $CURLAUTH_BASIC);
+				}
+				if ($this->proxy['authtype'] == 'ntlm') {
+					$this->setCurlOption($CURLOPT_PROXYAUTH, $CURLAUTH_NTLM);
+				}
+			}
+		}
+		$this->debug('cURL connection set up');
+		return true;
+	  } else {
+		$this->setError('Unknown scheme ' . $this->scheme);
+		$this->debug('Unknown scheme ' . $this->scheme);
+		return false;
+	  }
+	}
+
+	/**
+	* sends the SOAP request and gets the SOAP response via HTTP[S]
+	*
+	* @param    string $data message data
+	* @param    integer $timeout set connection timeout in seconds
+	* @param	integer $response_timeout set response timeout in seconds
+	* @param	array $cookies cookies to send
+	* @return	string data
+	* @access   public
+	*/
+	function send($data, $timeout=0, $response_timeout=30, $cookies=NULL) {
+		
+		$this->debug('entered send() with data of length: '.strlen($data));
+
+		$this->tryagain = true;
+		$tries = 0;
+		while ($this->tryagain) {
+			$this->tryagain = false;
+			if ($tries++ < 2) {
+				// make connnection
+				if (!$this->connect($timeout, $response_timeout)){
+					return false;
+				}
+				
+				// send request
+				if (!$this->sendRequest($data, $cookies)){
+					return false;
+				}
+				
+				// get response
+				$respdata = $this->getResponse();
+			} else {
+				$this->setError("Too many tries to get an OK response ($this->response_status_line)");
+			}
+		}		
+		$this->debug('end of send()');
+		return $respdata;
+	}
+
+
+	/**
+	* sends the SOAP request and gets the SOAP response via HTTPS using CURL
+	*
+	* @param    string $data message data
+	* @param    integer $timeout set connection timeout in seconds
+	* @param	integer $response_timeout set response timeout in seconds
+	* @param	array $cookies cookies to send
+	* @return	string data
+	* @access   public
+	* @deprecated
+	*/
+	function sendHTTPS($data, $timeout=0, $response_timeout=30, $cookies) {
+		return $this->send($data, $timeout, $response_timeout, $cookies);
+	}
+	
+	/**
+	* if authenticating, set user credentials here
+	*
+	* @param    string $username
+	* @param    string $password
+	* @param	string $authtype (basic|digest|certificate|ntlm)
+	* @param	array $digestRequest (keys must be nonce, nc, realm, qop)
+	* @param	array $certRequest (keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, certpassword (optional), verifypeer (optional), verifyhost (optional): see corresponding options in cURL docs)
+	* @access   public
+	*/
+	function setCredentials($username, $password, $authtype = 'basic', $digestRequest = array(), $certRequest = array()) {
+		$this->debug("setCredentials username=$username authtype=$authtype digestRequest=");
+		$this->appendDebug($this->varDump($digestRequest));
+		$this->debug("certRequest=");
+		$this->appendDebug($this->varDump($certRequest));
+		// cf. RFC 2617
+		if ($authtype == 'basic') {
+			$this->setHeader('Authorization', 'Basic '.base64_encode(str_replace(':','',$username).':'.$password));
+		} elseif ($authtype == 'digest') {
+			if (isset($digestRequest['nonce'])) {
+				$digestRequest['nc'] = isset($digestRequest['nc']) ? $digestRequest['nc']++ : 1;
+				
+				// calculate the Digest hashes (calculate code based on digest implementation found at: http://www.rassoc.com/gregr/weblog/stories/2002/07/09/webServicesSecurityHttpDigestAuthenticationWithoutActiveDirectory.html)
+	
+				// A1 = unq(username-value) ":" unq(realm-value) ":" passwd
+				$A1 = $username. ':' . (isset($digestRequest['realm']) ? $digestRequest['realm'] : '') . ':' . $password;
+	
+				// H(A1) = MD5(A1)
+				$HA1 = md5($A1);
+	
+				// A2 = Method ":" digest-uri-value
+				$A2 = $this->request_method . ':' . $this->digest_uri;
+	
+				// H(A2)
+				$HA2 =  md5($A2);
+	
+				// KD(secret, data) = H(concat(secret, ":", data))
+				// if qop == auth:
+				// request-digest  = <"> < KD ( H(A1),     unq(nonce-value)
+				//                              ":" nc-value
+				//                              ":" unq(cnonce-value)
+				//                              ":" unq(qop-value)
+				//                              ":" H(A2)
+				//                            ) <">
+				// if qop is missing,
+				// request-digest  = <"> < KD ( H(A1), unq(nonce-value) ":" H(A2) ) > <">
+	
+				$unhashedDigest = '';
+				$nonce = isset($digestRequest['nonce']) ? $digestRequest['nonce'] : '';
+				$cnonce = $nonce;
+				if ($digestRequest['qop'] != '') {
+					$unhashedDigest = $HA1 . ':' . $nonce . ':' . sprintf("%08d", $digestRequest['nc']) . ':' . $cnonce . ':' . $digestRequest['qop'] . ':' . $HA2;
+				} else {
+					$unhashedDigest = $HA1 . ':' . $nonce . ':' . $HA2;
+				}
+	
+				$hashedDigest = md5($unhashedDigest);
+	
+				$opaque = '';	
+				if (isset($digestRequest['opaque'])) {
+					$opaque = ', opaque="' . $digestRequest['opaque'] . '"';
+				}
+
+				$this->setHeader('Authorization', 'Digest username="' . $username . '", realm="' . $digestRequest['realm'] . '", nonce="' . $nonce . '", uri="' . $this->digest_uri . $opaque . '", cnonce="' . $cnonce . '", nc=' . sprintf("%08x", $digestRequest['nc']) . ', qop="' . $digestRequest['qop'] . '", response="' . $hashedDigest . '"');
+			}
+		} elseif ($authtype == 'certificate') {
+			$this->certRequest = $certRequest;
+			$this->debug('Authorization header not set for certificate');
+		} elseif ($authtype == 'ntlm') {
+			// do nothing
+			$this->debug('Authorization header not set for ntlm');
+		}
+		$this->username = $username;
+		$this->password = $password;
+		$this->authtype = $authtype;
+		$this->digestRequest = $digestRequest;
+	}
+	
+	/**
+	* set the soapaction value
+	*
+	* @param    string $soapaction
+	* @access   public
+	*/
+	function setSOAPAction($soapaction) {
+		$this->setHeader('SOAPAction', '"' . $soapaction . '"');
+	}
+	
+	/**
+	* use http encoding
+	*
+	* @param    string $enc encoding style. supported values: gzip, deflate, or both
+	* @access   public
+	*/
+	function setEncoding($enc='gzip, deflate') {
+		if (function_exists('gzdeflate')) {
+			$this->protocol_version = '1.1';
+			$this->setHeader('Accept-Encoding', $enc);
+			if (!isset($this->outgoing_headers['Connection'])) {
+				$this->setHeader('Connection', 'close');
+				$this->persistentConnection = false;
+			}
+			// deprecated as of PHP 5.3.0
+			//set_magic_quotes_runtime(0);
+			$this->encoding = $enc;
+		}
+	}
+	
+	/**
+	* set proxy info here
+	*
+	* @param    string $proxyhost use an empty string to remove proxy
+	* @param    string $proxyport
+	* @param	string $proxyusername
+	* @param	string $proxypassword
+	* @param	string $proxyauthtype (basic|ntlm)
+	* @access   public
+	*/
+	function setProxy($proxyhost, $proxyport, $proxyusername = '', $proxypassword = '', $proxyauthtype = 'basic') {
+		if ($proxyhost) {
+			$this->proxy = array(
+				'host' => $proxyhost,
+				'port' => $proxyport,
+				'username' => $proxyusername,
+				'password' => $proxypassword,
+				'authtype' => $proxyauthtype
+			);
+			if ($proxyusername != '' && $proxypassword != '' && $proxyauthtype = 'basic') {
+				$this->setHeader('Proxy-Authorization', ' Basic '.base64_encode($proxyusername.':'.$proxypassword));
+			}
+		} else {
+			$this->debug('remove proxy');
+			$proxy = null;
+			unsetHeader('Proxy-Authorization');
+		}
+	}
+	
+
+	/**
+	 * Test if the given string starts with a header that is to be skipped.
+	 * Skippable headers result from chunked transfer and proxy requests.
+	 *
+	 * @param	string $data The string to check.
+	 * @returns	boolean	Whether a skippable header was found.
+	 * @access	private
+	 */
+	function isSkippableCurlHeader(&$data) {
+		$skipHeaders = array(	'HTTP/1.1 100',
+								'HTTP/1.0 301',
+								'HTTP/1.1 301',
+								'HTTP/1.0 302',
+								'HTTP/1.1 302',
+								'HTTP/1.0 401',
+								'HTTP/1.1 401',
+								'HTTP/1.0 200 Connection established');
+		foreach ($skipHeaders as $hd) {
+			$prefix = substr($data, 0, strlen($hd));
+			if ($prefix == $hd) return true;
+		}
+
+		return false;
+	}
+
+	/**
+	* decode a string that is encoded w/ "chunked' transfer encoding
+ 	* as defined in RFC2068 19.4.6
+	*
+	* @param    string $buffer
+	* @param    string $lb
+	* @returns	string
+	* @access   public
+	* @deprecated
+	*/
+	function decodeChunked($buffer, $lb){
+		// length := 0
+		$length = 0;
+		$new = '';
+		
+		// read chunk-size, chunk-extension (if any) and CRLF
+		// get the position of the linebreak
+		$chunkend = strpos($buffer, $lb);
+		if ($chunkend == FALSE) {
+			$this->debug('no linebreak found in decodeChunked');
+			return $new;
+		}
+		$temp = substr($buffer,0,$chunkend);
+		$chunk_size = hexdec( trim($temp) );
+		$chunkstart = $chunkend + strlen($lb);
+		// while (chunk-size > 0) {
+		while ($chunk_size > 0) {
+			$this->debug("chunkstart: $chunkstart chunk_size: $chunk_size");
+			$chunkend = strpos( $buffer, $lb, $chunkstart + $chunk_size);
+		  	
+			// Just in case we got a broken connection
+		  	if ($chunkend == FALSE) {
+		  	    $chunk = substr($buffer,$chunkstart);
+				// append chunk-data to entity-body
+		    	$new .= $chunk;
+		  	    $length += strlen($chunk);
+		  	    break;
+			}
+			
+		  	// read chunk-data and CRLF
+		  	$chunk = substr($buffer,$chunkstart,$chunkend-$chunkstart);
+		  	// append chunk-data to entity-body
+		  	$new .= $chunk;
+		  	// length := length + chunk-size
+		  	$length += strlen($chunk);
+		  	// read chunk-size and CRLF
+		  	$chunkstart = $chunkend + strlen($lb);
+			
+		  	$chunkend = strpos($buffer, $lb, $chunkstart) + strlen($lb);
+			if ($chunkend == FALSE) {
+				break; //Just in case we got a broken connection
+			}
+			$temp = substr($buffer,$chunkstart,$chunkend-$chunkstart);
+			$chunk_size = hexdec( trim($temp) );
+			$chunkstart = $chunkend;
+		}
+		return $new;
+	}
+	
+	/**
+	 * Writes the payload, including HTTP headers, to $this->outgoing_payload.
+	 *
+	 * @param	string $data HTTP body
+	 * @param	string $cookie_str data for HTTP Cookie header
+	 * @return	void
+	 * @access	private
+	 */
+	function buildPayload($data, $cookie_str = '') {
+		// Note: for cURL connections, $this->outgoing_payload is ignored,
+		// as is the Content-Length header, but these are still created as
+		// debugging guides.
+
+		// add content-length header
+		if ($this->request_method != 'GET') {
+			$this->setHeader('Content-Length', strlen($data));
+		}
+
+		// start building outgoing payload:
+		if ($this->proxy) {
+			$uri = $this->url;
+		} else {
+			$uri = $this->uri;
+		}
+		$req = "$this->request_method $uri HTTP/$this->protocol_version";
+		$this->debug("HTTP request: $req");
+		$this->outgoing_payload = "$req\r\n";
+
+		// loop thru headers, serializing
+		foreach($this->outgoing_headers as $k => $v){
+			$hdr = $k.': '.$v;
+			$this->debug("HTTP header: $hdr");
+			$this->outgoing_payload .= "$hdr\r\n";
+		}
+
+		// add any cookies
+		if ($cookie_str != '') {
+			$hdr = 'Cookie: '.$cookie_str;
+			$this->debug("HTTP header: $hdr");
+			$this->outgoing_payload .= "$hdr\r\n";
+		}
+
+		// header/body separator
+		$this->outgoing_payload .= "\r\n";
+		
+		// add data
+		$this->outgoing_payload .= $data;
+	}
+
+	/**
+	* sends the SOAP request via HTTP[S]
+	*
+	* @param    string $data message data
+	* @param	array $cookies cookies to send
+	* @return	boolean	true if OK, false if problem
+	* @access   private
+	*/
+	function sendRequest($data, $cookies = NULL) {
+		// build cookie string
+		$cookie_str = $this->getCookiesForRequest($cookies, (($this->scheme == 'ssl') || ($this->scheme == 'https')));
+
+		// build payload
+		$this->buildPayload($data, $cookie_str);
+
+	  if ($this->io_method() == 'socket') {
+		// send payload
+		if(!fputs($this->fp, $this->outgoing_payload, strlen($this->outgoing_payload))) {
+			$this->setError('couldn\'t write message data to socket');
+			$this->debug('couldn\'t write message data to socket');
+			return false;
+		}
+		$this->debug('wrote data to socket, length = ' . strlen($this->outgoing_payload));
+		return true;
+	  } else if ($this->io_method() == 'curl') {
+		// set payload
+		// cURL does say this should only be the verb, and in fact it
+		// turns out that the URI and HTTP version are appended to this, which
+		// some servers refuse to work with (so we no longer use this method!)
+		//$this->setCurlOption(CURLOPT_CUSTOMREQUEST, $this->outgoing_payload);
+		$curl_headers = array();
+		foreach($this->outgoing_headers as $k => $v){
+			if ($k == 'Connection' || $k == 'Content-Length' || $k == 'Host' || $k == 'Authorization' || $k == 'Proxy-Authorization') {
+				$this->debug("Skip cURL header $k: $v");
+			} else {
+				$curl_headers[] = "$k: $v";
+			}
+		}
+		if ($cookie_str != '') {
+			$curl_headers[] = 'Cookie: ' . $cookie_str;
+		}
+		$this->setCurlOption(CURLOPT_HTTPHEADER, $curl_headers);
+		$this->debug('set cURL HTTP headers');
+		if ($this->request_method == "POST") {
+	  		$this->setCurlOption(CURLOPT_POST, 1);
+	  		$this->setCurlOption(CURLOPT_POSTFIELDS, $data);
+			$this->debug('set cURL POST data');
+	  	} else {
+	  	}
+		// insert custom user-set cURL options
+		foreach ($this->ch_options as $key => $val) {
+			$this->setCurlOption($key, $val);
+		}
+
+		$this->debug('set cURL payload');
+		return true;
+	  }
+	}
+
+	/**
+	* gets the SOAP response via HTTP[S]
+	*
+	* @return	string the response (also sets member variables like incoming_payload)
+	* @access   private
+	*/
+	function getResponse(){
+		$this->incoming_payload = '';
+	    
+	  if ($this->io_method() == 'socket') {
+	    // loop until headers have been retrieved
+	    $data = '';
+	    while (!isset($lb)){
+
+			// We might EOF during header read.
+			if(feof($this->fp)) {
+				$this->incoming_payload = $data;
+				$this->debug('found no headers before EOF after length ' . strlen($data));
+				$this->debug("received before EOF:\n" . $data);
+				$this->setError('server failed to send headers');
+				return false;
+			}
+
+			$tmp = fgets($this->fp, 256);
+			$tmplen = strlen($tmp);
+			$this->debug("read line of $tmplen bytes: " . trim($tmp));
+
+			if ($tmplen == 0) {
+				$this->incoming_payload = $data;
+				$this->debug('socket read of headers timed out after length ' . strlen($data));
+				$this->debug("read before timeout: " . $data);
+				$this->setError('socket read of headers timed out');
+				return false;
+			}
+
+			$data .= $tmp;
+			$pos = strpos($data,"\r\n\r\n");
+			if($pos > 1){
+				$lb = "\r\n";
+			} else {
+				$pos = strpos($data,"\n\n");
+				if($pos > 1){
+					$lb = "\n";
+				}
+			}
+			// remove 100 headers
+			if (isset($lb) && preg_match('/^HTTP\/1.1 100/',$data)) {
+				unset($lb);
+				$data = '';
+			}//
+		}
+		// store header data
+		$this->incoming_payload .= $data;
+		$this->debug('found end of headers after length ' . strlen($data));
+		// process headers
+		$header_data = trim(substr($data,0,$pos));
+		$header_array = explode($lb,$header_data);
+		$this->incoming_headers = array();
+		$this->incoming_cookies = array();
+		foreach($header_array as $header_line){
+			$arr = explode(':',$header_line, 2);
+			if(count($arr) > 1){
+				$header_name = strtolower(trim($arr[0]));
+				$this->incoming_headers[$header_name] = trim($arr[1]);
+				if ($header_name == 'set-cookie') {
+					// TODO: allow multiple cookies from parseCookie
+					$cookie = $this->parseCookie(trim($arr[1]));
+					if ($cookie) {
+						$this->incoming_cookies[] = $cookie;
+						$this->debug('found cookie: ' . $cookie['name'] . ' = ' . $cookie['value']);
+					} else {
+						$this->debug('did not find cookie in ' . trim($arr[1]));
+					}
+    			}
+			} else if (isset($header_name)) {
+				// append continuation line to previous header
+				$this->incoming_headers[$header_name] .= $lb . ' ' . $header_line;
+			}
+		}
+		
+		// loop until msg has been received
+		if (isset($this->incoming_headers['transfer-encoding']) && strtolower($this->incoming_headers['transfer-encoding']) == 'chunked') {
+			$content_length =  2147483647;	// ignore any content-length header
+			$chunked = true;
+			$this->debug("want to read chunked content");
+		} elseif (isset($this->incoming_headers['content-length'])) {
+			$content_length = $this->incoming_headers['content-length'];
+			$chunked = false;
+			$this->debug("want to read content of length $content_length");
+		} else {
+			$content_length =  2147483647;
+			$chunked = false;
+			$this->debug("want to read content to EOF");
+		}
+		$data = '';
+		do {
+			if ($chunked) {
+				$tmp = fgets($this->fp, 256);
+				$tmplen = strlen($tmp);
+				$this->debug("read chunk line of $tmplen bytes");
+				if ($tmplen == 0) {
+					$this->incoming_payload = $data;
+					$this->debug('socket read of chunk length timed out after length ' . strlen($data));
+					$this->debug("read before timeout:\n" . $data);
+					$this->setError('socket read of chunk length timed out');
+					return false;
+				}
+				$content_length = hexdec(trim($tmp));
+				$this->debug("chunk length $content_length");
+			}
+			$strlen = 0;
+		    while (($strlen < $content_length) && (!feof($this->fp))) {
+		    	$readlen = min(8192, $content_length - $strlen);
+				$tmp = fread($this->fp, $readlen);
+				$tmplen = strlen($tmp);
+				$this->debug("read buffer of $tmplen bytes");
+				if (($tmplen == 0) && (!feof($this->fp))) {
+					$this->incoming_payload = $data;
+					$this->debug('socket read of body timed out after length ' . strlen($data));
+					$this->debug("read before timeout:\n" . $data);
+					$this->setError('socket read of body timed out');
+					return false;
+				}
+				$strlen += $tmplen;
+				$data .= $tmp;
+			}
+			if ($chunked && ($content_length > 0)) {
+				$tmp = fgets($this->fp, 256);
+				$tmplen = strlen($tmp);
+				$this->debug("read chunk terminator of $tmplen bytes");
+				if ($tmplen == 0) {
+					$this->incoming_payload = $data;
+					$this->debug('socket read of chunk terminator timed out after length ' . strlen($data));
+					$this->debug("read before timeout:\n" . $data);
+					$this->setError('socket read of chunk terminator timed out');
+					return false;
+				}
+			}
+		} while ($chunked && ($content_length > 0) && (!feof($this->fp)));
+		if (feof($this->fp)) {
+			$this->debug('read to EOF');
+		}
+		$this->debug('read body of length ' . strlen($data));
+		$this->incoming_payload .= $data;
+		$this->debug('received a total of '.strlen($this->incoming_payload).' bytes of data from server');
+		
+		// close filepointer
+		if(
+			(isset($this->incoming_headers['connection']) && strtolower($this->incoming_headers['connection']) == 'close') || 
+			(! $this->persistentConnection) || feof($this->fp)){
+			fclose($this->fp);
+			$this->fp = false;
+			$this->debug('closed socket');
+		}
+		
+		// connection was closed unexpectedly
+		if($this->incoming_payload == ''){
+			$this->setError('no response from server');
+			return false;
+		}
+		
+		// decode transfer-encoding
+//		if(isset($this->incoming_headers['transfer-encoding']) && strtolower($this->incoming_headers['transfer-encoding']) == 'chunked'){
+//			if(!$data = $this->decodeChunked($data, $lb)){
+//				$this->setError('Decoding of chunked data failed');
+//				return false;
+//			}
+			//print "<pre>\nde-chunked:\n---------------\n$data\n\n---------------\n</pre>";
+			// set decoded payload
+//			$this->incoming_payload = $header_data.$lb.$lb.$data;
+//		}
+	
+	  } else if ($this->io_method() == 'curl') {
+		// send and receive
+		$this->debug('send and receive with cURL');
+		$this->incoming_payload = curl_exec($this->ch);
+		$data = $this->incoming_payload;
+
+        $cErr = curl_error($this->ch);
+		if ($cErr != '') {
+        	$err = 'cURL ERROR: '.curl_errno($this->ch).': '.$cErr.'<br>';
+        	// TODO: there is a PHP bug that can cause this to SEGV for CURLINFO_CONTENT_TYPE
+			foreach(curl_getinfo($this->ch) as $k => $v){
+				$err .= "$k: $v<br>";
+			}
+			$this->debug($err);
+			$this->setError($err);
+			curl_close($this->ch);
+	    	return false;
+		} else {
+			//echo '<pre>';
+			//var_dump(curl_getinfo($this->ch));
+			//echo '</pre>';
+		}
+		// close curl
+		$this->debug('No cURL error, closing cURL');
+		curl_close($this->ch);
+		
+		// try removing skippable headers
+		$savedata = $data;
+		while ($this->isSkippableCurlHeader($data)) {
+			$this->debug("Found HTTP header to skip");
+			if ($pos = strpos($data,"\r\n\r\n")) {
+				$data = ltrim(substr($data,$pos));
+			} elseif($pos = strpos($data,"\n\n") ) {
+				$data = ltrim(substr($data,$pos));
+			}
+		}
+
+		if ($data == '') {
+			// have nothing left; just remove 100 header(s)
+			$data = $savedata;
+			while (preg_match('/^HTTP\/1.1 100/',$data)) {
+				if ($pos = strpos($data,"\r\n\r\n")) {
+					$data = ltrim(substr($data,$pos));
+				} elseif($pos = strpos($data,"\n\n") ) {
+					$data = ltrim(substr($data,$pos));
+				}
+			}
+		}
+		
+		// separate content from HTTP headers
+		if ($pos = strpos($data,"\r\n\r\n")) {
+			$lb = "\r\n";
+		} elseif( $pos = strpos($data,"\n\n")) {
+			$lb = "\n";
+		} else {
+			$this->debug('no proper separation of headers and document');
+			$this->setError('no proper separation of headers and document');
+			return false;
+		}
+		$header_data = trim(substr($data,0,$pos));
+		$header_array = explode($lb,$header_data);
+		$data = ltrim(substr($data,$pos));
+		$this->debug('found proper separation of headers and document');
+		$this->debug('cleaned data, stringlen: '.strlen($data));
+		// clean headers
+		foreach ($header_array as $header_line) {
+			$arr = explode(':',$header_line,2);
+			if(count($arr) > 1){
+				$header_name = strtolower(trim($arr[0]));
+				$this->incoming_headers[$header_name] = trim($arr[1]);
+				if ($header_name == 'set-cookie') {
+					// TODO: allow multiple cookies from parseCookie
+					$cookie = $this->parseCookie(trim($arr[1]));
+					if ($cookie) {
+						$this->incoming_cookies[] = $cookie;
+						$this->debug('found cookie: ' . $cookie['name'] . ' = ' . $cookie['value']);
+					} else {
+						$this->debug('did not find cookie in ' . trim($arr[1]));
+					}
+    			}
+			} else if (isset($header_name)) {
+				// append continuation line to previous header
+				$this->incoming_headers[$header_name] .= $lb . ' ' . $header_line;
+			}
+		}
+	  }
+
+		$this->response_status_line = $header_array[0];
+		$arr = explode(' ', $this->response_status_line, 3);
+		$http_version = $arr[0];
+		$http_status = intval($arr[1]);
+		$http_reason = count($arr) > 2 ? $arr[2] : '';
+
+ 		// see if we need to resend the request with http digest authentication
+ 		if (isset($this->incoming_headers['location']) && ($http_status == 301 || $http_status == 302)) {
+ 			$this->debug("Got $http_status $http_reason with Location: " . $this->incoming_headers['location']);
+ 			$this->setURL($this->incoming_headers['location']);
+			$this->tryagain = true;
+			return false;
+		}
+
+ 		// see if we need to resend the request with http digest authentication
+ 		if (isset($this->incoming_headers['www-authenticate']) && $http_status == 401) {
+ 			$this->debug("Got 401 $http_reason with WWW-Authenticate: " . $this->incoming_headers['www-authenticate']);
+ 			if (strstr($this->incoming_headers['www-authenticate'], "Digest ")) {
+ 				$this->debug('Server wants digest authentication');
+ 				// remove "Digest " from our elements
+ 				$digestString = str_replace('Digest ', '', $this->incoming_headers['www-authenticate']);
+ 				
+ 				// parse elements into array
+ 				$digestElements = explode(',', $digestString);
+ 				foreach ($digestElements as $val) {
+ 					$tempElement = explode('=', trim($val), 2);
+ 					$digestRequest[$tempElement[0]] = str_replace("\"", '', $tempElement[1]);
+ 				}
+
+				// should have (at least) qop, realm, nonce
+ 				if (isset($digestRequest['nonce'])) {
+ 					$this->setCredentials($this->username, $this->password, 'digest', $digestRequest);
+ 					$this->tryagain = true;
+ 					return false;
+ 				}
+ 			}
+			$this->debug('HTTP authentication failed');
+			$this->setError('HTTP authentication failed');
+			return false;
+ 		}
+		
+		if (
+			($http_status >= 300 && $http_status <= 307) ||
+			($http_status >= 400 && $http_status <= 417) ||
+			($http_status >= 501 && $http_status <= 505)
+		   ) {
+			$this->setError("Unsupported HTTP response status $http_status $http_reason (soapclient->response has contents of the response)");
+			return false;
+		}
+
+		// decode content-encoding
+		if(isset($this->incoming_headers['content-encoding']) && $this->incoming_headers['content-encoding'] != ''){
+			if(strtolower($this->incoming_headers['content-encoding']) == 'deflate' || strtolower($this->incoming_headers['content-encoding']) == 'gzip'){
+    			// if decoding works, use it. else assume data wasn't gzencoded
+    			if(function_exists('gzinflate')){
+					//$timer->setMarker('starting decoding of gzip/deflated content');
+					// IIS 5 requires gzinflate instead of gzuncompress (similar to IE 5 and gzdeflate v. gzcompress)
+					// this means there are no Zlib headers, although there should be
+					$this->debug('The gzinflate function exists');
+					$datalen = strlen($data);
+					if ($this->incoming_headers['content-encoding'] == 'deflate') {
+						if ($degzdata = @gzinflate($data)) {
+	    					$data = $degzdata;
+	    					$this->debug('The payload has been inflated to ' . strlen($data) . ' bytes');
+	    					if (strlen($data) < $datalen) {
+	    						// test for the case that the payload has been compressed twice
+		    					$this->debug('The inflated payload is smaller than the gzipped one; try again');
+								if ($degzdata = @gzinflate($data)) {
+			    					$data = $degzdata;
+			    					$this->debug('The payload has been inflated again to ' . strlen($data) . ' bytes');
+								}
+	    					}
+	    				} else {
+	    					$this->debug('Error using gzinflate to inflate the payload');
+	    					$this->setError('Error using gzinflate to inflate the payload');
+	    				}
+					} elseif ($this->incoming_headers['content-encoding'] == 'gzip') {
+						if ($degzdata = @gzinflate(substr($data, 10))) {	// do our best
+							$data = $degzdata;
+	    					$this->debug('The payload has been un-gzipped to ' . strlen($data) . ' bytes');
+	    					if (strlen($data) < $datalen) {
+	    						// test for the case that the payload has been compressed twice
+		    					$this->debug('The un-gzipped payload is smaller than the gzipped one; try again');
+								if ($degzdata = @gzinflate(substr($data, 10))) {
+			    					$data = $degzdata;
+			    					$this->debug('The payload has been un-gzipped again to ' . strlen($data) . ' bytes');
+								}
+	    					}
+	    				} else {
+	    					$this->debug('Error using gzinflate to un-gzip the payload');
+							$this->setError('Error using gzinflate to un-gzip the payload');
+	    				}
+					}
+					//$timer->setMarker('finished decoding of gzip/deflated content');
+					//print "<xmp>\nde-inflated:\n---------------\n$data\n-------------\n</xmp>";
+					// set decoded payload
+					$this->incoming_payload = $header_data.$lb.$lb.$data;
+    			} else {
+					$this->debug('The server sent compressed data. Your php install must have the Zlib extension compiled in to support this.');
+					$this->setError('The server sent compressed data. Your php install must have the Zlib extension compiled in to support this.');
+				}
+			} else {
+				$this->debug('Unsupported Content-Encoding ' . $this->incoming_headers['content-encoding']);
+				$this->setError('Unsupported Content-Encoding ' . $this->incoming_headers['content-encoding']);
+			}
+		} else {
+			$this->debug('No Content-Encoding header');
+		}
+		
+		if(strlen($data) == 0){
+			$this->debug('no data after headers!');
+			$this->setError('no data present after HTTP headers');
+			return false;
+		}
+		
+		return $data;
+	}
+
+	/**
+	 * sets the content-type for the SOAP message to be sent
+	 *
+	 * @param	string $type the content type, MIME style
+	 * @param	mixed $charset character set used for encoding (or false)
+	 * @access	public
+	 */
+	function setContentType($type, $charset = false) {
+		$this->setHeader('Content-Type', $type . ($charset ? '; charset=' . $charset : ''));
+	}
+
+	/**
+	 * specifies that an HTTP persistent connection should be used
+	 *
+	 * @return	boolean whether the request was honored by this method.
+	 * @access	public
+	 */
+	function usePersistentConnection(){
+		if (isset($this->outgoing_headers['Accept-Encoding'])) {
+			return false;
+		}
+		$this->protocol_version = '1.1';
+		$this->persistentConnection = true;
+		$this->setHeader('Connection', 'Keep-Alive');
+		return true;
+	}
+
+	/**
+	 * parse an incoming Cookie into it's parts
+	 *
+	 * @param	string $cookie_str content of cookie
+	 * @return	array with data of that cookie
+	 * @access	private
+	 */
+	/*
+	 * TODO: allow a Set-Cookie string to be parsed into multiple cookies
+	 */
+	function parseCookie($cookie_str) {
+		$cookie_str = str_replace('; ', ';', $cookie_str) . ';';
+		$data = preg_split('/;/', $cookie_str);
+		$value_str = $data[0];
+
+		$cookie_param = 'domain=';
+		$start = strpos($cookie_str, $cookie_param);
+		if ($start > 0) {
+			$domain = substr($cookie_str, $start + strlen($cookie_param));
+			$domain = substr($domain, 0, strpos($domain, ';'));
+		} else {
+			$domain = '';
+		}
+
+		$cookie_param = 'expires=';
+		$start = strpos($cookie_str, $cookie_param);
+		if ($start > 0) {
+			$expires = substr($cookie_str, $start + strlen($cookie_param));
+			$expires = substr($expires, 0, strpos($expires, ';'));
+		} else {
+			$expires = '';
+		}
+
+		$cookie_param = 'path=';
+		$start = strpos($cookie_str, $cookie_param);
+		if ( $start > 0 ) {
+			$path = substr($cookie_str, $start + strlen($cookie_param));
+			$path = substr($path, 0, strpos($path, ';'));
+		} else {
+			$path = '/';
+		}
+						
+		$cookie_param = ';secure;';
+		if (strpos($cookie_str, $cookie_param) !== FALSE) {
+			$secure = true;
+		} else {
+			$secure = false;
+		}
+
+		$sep_pos = strpos($value_str, '=');
+
+		if ($sep_pos) {
+			$name = substr($value_str, 0, $sep_pos);
+			$value = substr($value_str, $sep_pos + 1);
+			$cookie= array(	'name' => $name,
+			                'value' => $value,
+							'domain' => $domain,
+							'path' => $path,
+							'expires' => $expires,
+							'secure' => $secure
+							);		
+			return $cookie;
+		}
+		return false;
+	}
+  
+	/**
+	 * sort out cookies for the current request
+	 *
+	 * @param	array $cookies array with all cookies
+	 * @param	boolean $secure is the send-content secure or not?
+	 * @return	string for Cookie-HTTP-Header
+	 * @access	private
+	 */
+	function getCookiesForRequest($cookies, $secure=false) {
+		$cookie_str = '';
+		if ((! is_null($cookies)) && (is_array($cookies))) {
+			foreach ($cookies as $cookie) {
+				if (! is_array($cookie)) {
+					continue;
+				}
+	    		$this->debug("check cookie for validity: ".$cookie['name'].'='.$cookie['value']);
+				if ((isset($cookie['expires'])) && (! empty($cookie['expires']))) {
+					if (strtotime($cookie['expires']) <= time()) {
+						$this->debug('cookie has expired');
+						continue;
+					}
+				}
+				if ((isset($cookie['domain'])) && (! empty($cookie['domain']))) {
+					$domain = preg_quote($cookie['domain']);
+					if (! preg_match("'.*$domain$'i", $this->host)) {
+						$this->debug('cookie has different domain');
+						continue;
+					}
+				}
+				if ((isset($cookie['path'])) && (! empty($cookie['path']))) {
+					$path = preg_quote($cookie['path']);
+					if (! preg_match("'^$path.*'i", $this->path)) {
+						$this->debug('cookie is for a different path');
+						continue;
+					}
+				}
+				if ((! $secure) && (isset($cookie['secure'])) && ($cookie['secure'])) {
+					$this->debug('cookie is secure, transport is not');
+					continue;
+				}
+				$cookie_str .= $cookie['name'] . '=' . $cookie['value'] . '; ';
+	    		$this->debug('add cookie to Cookie-String: ' . $cookie['name'] . '=' . $cookie['value']);
+			}
+		}
+		return $cookie_str;
+  }
+}
+
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/ecrire/nusoap/class.soap_val.php spip/ecrire/nusoap/class.soap_val.php
--- spip-ori/ecrire/nusoap/class.soap_val.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nusoap/class.soap_val.php	2013-04-05 11:06:41.157923139 +0200
@@ -0,0 +1,107 @@
+<?php
+
+
+
+
+/**
+* For creating serializable abstractions of native PHP types.  This class
+* allows element name/namespace, XSD type, and XML attributes to be
+* associated with a value.  This is extremely useful when WSDL is not
+* used, but is also useful when WSDL is used with polymorphic types, including
+* xsd:anyType and user-defined types.
+*
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @version  $Id: class.soap_val.php,v 1.11 2007/04/06 13:56:32 snichol Exp $
+* @access   public
+*/
+class soapval extends nusoap_base {
+	/**
+	 * The XML element name
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $name;
+	/**
+	 * The XML type name (string or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $type;
+	/**
+	 * The PHP value
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $value;
+	/**
+	 * The XML element namespace (string or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $element_ns;
+	/**
+	 * The XML type namespace (string or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $type_ns;
+	/**
+	 * The XML element attributes (array or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $attributes;
+
+	/**
+	* constructor
+	*
+	* @param    string $name optional name
+	* @param    mixed $type optional type name
+	* @param	mixed $value optional value
+	* @param	mixed $element_ns optional namespace of value
+	* @param	mixed $type_ns optional namespace of type
+	* @param	mixed $attributes associative array of attributes to add to element serialization
+	* @access   public
+	*/
+  	function soapval($name='soapval',$type=false,$value=-1,$element_ns=false,$type_ns=false,$attributes=false) {
+		parent::nusoap_base();
+		$this->name = $name;
+		$this->type = $type;
+		$this->value = $value;
+		$this->element_ns = $element_ns;
+		$this->type_ns = $type_ns;
+		$this->attributes = $attributes;
+    }
+
+	/**
+	* return serialized value
+	*
+	* @param	string $use The WSDL use value (encoded|literal)
+	* @return	string XML data
+	* @access   public
+	*/
+	function serialize($use='encoded') {
+		return $this->serialize_val($this->value, $this->name, $this->type, $this->element_ns, $this->type_ns, $this->attributes, $use, true);
+    }
+
+	/**
+	* decodes a soapval object into a PHP native type
+	*
+	* @return	mixed
+	* @access   public
+	*/
+	function decode(){
+		return $this->value;
+	}
+}
+
+
+
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/ecrire/nusoap/class.wsdlcache.php spip/ecrire/nusoap/class.wsdlcache.php
--- spip-ori/ecrire/nusoap/class.wsdlcache.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nusoap/class.wsdlcache.php	2013-04-05 11:06:41.157923139 +0200
@@ -0,0 +1,209 @@
+<?php
+/*
+The NuSOAP project home is:
+http://sourceforge.net/projects/nusoap/
+
+The primary support for NuSOAP is the mailing list:
+nusoap-general@lists.sourceforge.net
+*/
+
+/**
+* caches instances of the wsdl class
+* 
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @author	Ingo Fischer <ingo@apollon.de>
+* @version  $Id: class.wsdlcache.php,v 1.7 2007/04/17 16:34:03 snichol Exp $
+* @access public 
+*/
+class nusoap_wsdlcache {
+	/**
+	 *	@var resource
+	 *	@access private
+	 */
+	var $fplock;
+	/**
+	 *	@var integer
+	 *	@access private
+	 */
+	var $cache_lifetime;
+	/**
+	 *	@var string
+	 *	@access private
+	 */
+	var $cache_dir;
+	/**
+	 *	@var string
+	 *	@access public
+	 */
+	var $debug_str = '';
+
+	/**
+	* constructor
+	*
+	* @param string $cache_dir directory for cache-files
+	* @param integer $cache_lifetime lifetime for caching-files in seconds or 0 for unlimited
+	* @access public
+	*/
+	function nusoap_wsdlcache($cache_dir='.', $cache_lifetime=0) {
+		$this->fplock = array();
+		$this->cache_dir = $cache_dir != '' ? $cache_dir : '.';
+		$this->cache_lifetime = $cache_lifetime;
+	}
+
+	/**
+	* creates the filename used to cache a wsdl instance
+	*
+	* @param string $wsdl The URL of the wsdl instance
+	* @return string The filename used to cache the instance
+	* @access private
+	*/
+	function createFilename($wsdl) {
+		return $this->cache_dir.'/wsdlcache-' . md5($wsdl);
+	}
+
+	/**
+	* adds debug data to the class level debug string
+	*
+	* @param    string $string debug data
+	* @access   private
+	*/
+	function debug($string){
+		$this->debug_str .= get_class($this).": $string\n";
+	}
+
+	/**
+	* gets a wsdl instance from the cache
+	*
+	* @param string $wsdl The URL of the wsdl instance
+	* @return object wsdl The cached wsdl instance, null if the instance is not in the cache
+	* @access public
+	*/
+	function get($wsdl) {
+		$filename = $this->createFilename($wsdl);
+		if ($this->obtainMutex($filename, "r")) {
+			// check for expired WSDL that must be removed from the cache
+ 			if ($this->cache_lifetime > 0) {
+				if (file_exists($filename) && (time() - filemtime($filename) > $this->cache_lifetime)) {
+					unlink($filename);
+					$this->debug("Expired $wsdl ($filename) from cache");
+					$this->releaseMutex($filename);
+					return null;
+  				}
+			}
+			// see what there is to return
+			if (!file_exists($filename)) {
+				$this->debug("$wsdl ($filename) not in cache (1)");
+				$this->releaseMutex($filename);
+				return null;
+			}
+			$fp = @fopen($filename, "r");
+			if ($fp) {
+				$s = implode("", @file($filename));
+				fclose($fp);
+				$this->debug("Got $wsdl ($filename) from cache");
+			} else {
+				$s = null;
+				$this->debug("$wsdl ($filename) not in cache (2)");
+			}
+			$this->releaseMutex($filename);
+			return (!is_null($s)) ? unserialize($s) : null;
+		} else {
+			$this->debug("Unable to obtain mutex for $filename in get");
+		}
+		return null;
+	}
+
+	/**
+	* obtains the local mutex
+	*
+	* @param string $filename The Filename of the Cache to lock
+	* @param string $mode The open-mode ("r" or "w") or the file - affects lock-mode
+	* @return boolean Lock successfully obtained ?!
+	* @access private
+	*/
+	function obtainMutex($filename, $mode) {
+		if (isset($this->fplock[md5($filename)])) {
+			$this->debug("Lock for $filename already exists");
+			return false;
+		}
+		$this->fplock[md5($filename)] = fopen($filename.".lock", "w");
+		if ($mode == "r") {
+			return flock($this->fplock[md5($filename)], LOCK_SH);
+		} else {
+			return flock($this->fplock[md5($filename)], LOCK_EX);
+		}
+	}
+
+	/**
+	* adds a wsdl instance to the cache
+	*
+	* @param object wsdl $wsdl_instance The wsdl instance to add
+	* @return boolean WSDL successfully cached
+	* @access public
+	*/
+	function put($wsdl_instance) {
+		$filename = $this->createFilename($wsdl_instance->wsdl);
+		$s = serialize($wsdl_instance);
+		if ($this->obtainMutex($filename, "w")) {
+			$fp = fopen($filename, "w");
+			if (! $fp) {
+				$this->debug("Cannot write $wsdl_instance->wsdl ($filename) in cache");
+				$this->releaseMutex($filename);
+				return false;
+			}
+			fputs($fp, $s);
+			fclose($fp);
+			$this->debug("Put $wsdl_instance->wsdl ($filename) in cache");
+			$this->releaseMutex($filename);
+			return true;
+		} else {
+			$this->debug("Unable to obtain mutex for $filename in put");
+		}
+		return false;
+	}
+
+	/**
+	* releases the local mutex
+	*
+	* @param string $filename The Filename of the Cache to lock
+	* @return boolean Lock successfully released
+	* @access private
+	*/
+	function releaseMutex($filename) {
+		$ret = flock($this->fplock[md5($filename)], LOCK_UN);
+		fclose($this->fplock[md5($filename)]);
+		unset($this->fplock[md5($filename)]);
+		if (! $ret) {
+			$this->debug("Not able to release lock for $filename");
+		}
+		return $ret;
+	}
+
+	/**
+	* removes a wsdl instance from the cache
+	*
+	* @param string $wsdl The URL of the wsdl instance
+	* @return boolean Whether there was an instance to remove
+	* @access public
+	*/
+	function remove($wsdl) {
+		$filename = $this->createFilename($wsdl);
+		if (!file_exists($filename)) {
+			$this->debug("$wsdl ($filename) not in cache to be removed");
+			return false;
+		}
+		// ignore errors obtaining mutex
+		$this->obtainMutex($filename, "w");
+		$ret = unlink($filename);
+		$this->debug("Removed ($ret) $wsdl ($filename) from cache");
+		$this->releaseMutex($filename);
+		return $ret;
+	}
+}
+
+/**
+ * For backward compatibility
+ */
+class wsdlcache extends nusoap_wsdlcache {
+}
+?>
diff -rNU5 spip-ori/ecrire/nusoap/class.wsdl.php spip/ecrire/nusoap/class.wsdl.php
--- spip-ori/ecrire/nusoap/class.wsdl.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nusoap/class.wsdl.php	2013-04-05 11:06:41.157923139 +0200
@@ -0,0 +1,1938 @@
+<?php
+
+
+
+
+/**
+* parses a WSDL file, allows access to it's data, other utility methods.
+* also builds WSDL structures programmatically.
+* 
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @version  $Id: class.wsdl.php,v 1.76 2010/04/26 20:15:08 snichol Exp $
+* @access public 
+*/
+class wsdl extends nusoap_base {
+	// URL or filename of the root of this WSDL
+    var $wsdl; 
+    // define internal arrays of bindings, ports, operations, messages, etc.
+    var $schemas = array();
+    var $currentSchema;
+    var $message = array();
+    var $complexTypes = array();
+    var $messages = array();
+    var $currentMessage;
+    var $currentOperation;
+    var $portTypes = array();
+    var $currentPortType;
+    var $bindings = array();
+    var $currentBinding;
+    var $ports = array();
+    var $currentPort;
+    var $opData = array();
+    var $status = '';
+    var $documentation = false;
+    var $endpoint = ''; 
+    // array of wsdl docs to import
+    var $import = array(); 
+    // parser vars
+    var $parser;
+    var $position = 0;
+    var $depth = 0;
+    var $depth_array = array();
+	// for getting wsdl
+	var $proxyhost = '';
+    var $proxyport = '';
+	var $proxyusername = '';
+	var $proxypassword = '';
+	var $timeout = 0;
+	var $response_timeout = 30;
+	var $curl_options = array();	// User-specified cURL options
+	var $use_curl = false;			// whether to always try to use cURL
+	// for HTTP authentication
+	var $username = '';				// Username for HTTP authentication
+	var $password = '';				// Password for HTTP authentication
+	var $authtype = '';				// Type of HTTP authentication
+	var $certRequest = array();		// Certificate for HTTP SSL authentication
+
+    /**
+     * constructor
+     * 
+     * @param string $wsdl WSDL document URL
+	 * @param string $proxyhost
+	 * @param string $proxyport
+	 * @param string $proxyusername
+	 * @param string $proxypassword
+	 * @param integer $timeout set the connection timeout
+	 * @param integer $response_timeout set the response timeout
+	 * @param array $curl_options user-specified cURL options
+	 * @param boolean $use_curl try to use cURL
+     * @access public 
+     */
+    function wsdl($wsdl = '',$proxyhost=false,$proxyport=false,$proxyusername=false,$proxypassword=false,$timeout=0,$response_timeout=30,$curl_options=null,$use_curl=false){
+		parent::nusoap_base();
+		$this->debug("ctor wsdl=$wsdl timeout=$timeout response_timeout=$response_timeout");
+        $this->proxyhost = $proxyhost;
+        $this->proxyport = $proxyport;
+		$this->proxyusername = $proxyusername;
+		$this->proxypassword = $proxypassword;
+		$this->timeout = $timeout;
+		$this->response_timeout = $response_timeout;
+		if (is_array($curl_options))
+			$this->curl_options = $curl_options;
+		$this->use_curl = $use_curl;
+		$this->fetchWSDL($wsdl);
+    }
+
+	/**
+	 * fetches the WSDL document and parses it
+	 *
+	 * @access public
+	 */
+	function fetchWSDL($wsdl) {
+		$this->debug("parse and process WSDL path=$wsdl");
+		$this->wsdl = $wsdl;
+        // parse wsdl file
+        if ($this->wsdl != "") {
+            $this->parseWSDL($this->wsdl);
+        }
+        // imports
+        // TODO: handle imports more properly, grabbing them in-line and nesting them
+    	$imported_urls = array();
+    	$imported = 1;
+    	while ($imported > 0) {
+    		$imported = 0;
+    		// Schema imports
+    		foreach ($this->schemas as $ns => $list) {
+    			foreach ($list as $xs) {
+					$wsdlparts = parse_url($this->wsdl);	// this is bogusly simple!
+		            foreach ($xs->imports as $ns2 => $list2) {
+		                for ($ii = 0; $ii < count($list2); $ii++) {
+		                	if (! $list2[$ii]['loaded']) {
+		                		$this->schemas[$ns]->imports[$ns2][$ii]['loaded'] = true;
+		                		$url = $list2[$ii]['location'];
+								if ($url != '') {
+									$urlparts = parse_url($url);
+									if (!isset($urlparts['host'])) {
+										$url = $wsdlparts['scheme'] . '://' . $wsdlparts['host'] . (isset($wsdlparts['port']) ? ':' .$wsdlparts['port'] : '') .
+												substr($wsdlparts['path'],0,strrpos($wsdlparts['path'],'/') + 1) .$urlparts['path'];
+									}
+									if (! in_array($url, $imported_urls)) {
+					                	$this->parseWSDL($url);
+				                		$imported++;
+				                		$imported_urls[] = $url;
+				                	}
+								} else {
+									$this->debug("Unexpected scenario: empty URL for unloaded import");
+								}
+							}
+						}
+		            } 
+    			}
+    		}
+    		// WSDL imports
+			$wsdlparts = parse_url($this->wsdl);	// this is bogusly simple!
+            foreach ($this->import as $ns => $list) {
+                for ($ii = 0; $ii < count($list); $ii++) {
+                	if (! $list[$ii]['loaded']) {
+                		$this->import[$ns][$ii]['loaded'] = true;
+                		$url = $list[$ii]['location'];
+						if ($url != '') {
+							$urlparts = parse_url($url);
+							if (!isset($urlparts['host'])) {
+								$url = $wsdlparts['scheme'] . '://' . $wsdlparts['host'] . (isset($wsdlparts['port']) ? ':' . $wsdlparts['port'] : '') .
+										substr($wsdlparts['path'],0,strrpos($wsdlparts['path'],'/') + 1) .$urlparts['path'];
+							}
+							if (! in_array($url, $imported_urls)) {
+			                	$this->parseWSDL($url);
+		                		$imported++;
+		                		$imported_urls[] = $url;
+		                	}
+						} else {
+							$this->debug("Unexpected scenario: empty URL for unloaded import");
+						}
+					}
+				}
+            } 
+		}
+        // add new data to operation data
+        foreach($this->bindings as $binding => $bindingData) {
+            if (isset($bindingData['operations']) && is_array($bindingData['operations'])) {
+                foreach($bindingData['operations'] as $operation => $data) {
+                    $this->debug('post-parse data gathering for ' . $operation);
+                    $this->bindings[$binding]['operations'][$operation]['input'] = 
+						isset($this->bindings[$binding]['operations'][$operation]['input']) ? 
+						array_merge($this->bindings[$binding]['operations'][$operation]['input'], $this->portTypes[ $bindingData['portType'] ][$operation]['input']) :
+						$this->portTypes[ $bindingData['portType'] ][$operation]['input'];
+                    $this->bindings[$binding]['operations'][$operation]['output'] = 
+						isset($this->bindings[$binding]['operations'][$operation]['output']) ?
+						array_merge($this->bindings[$binding]['operations'][$operation]['output'], $this->portTypes[ $bindingData['portType'] ][$operation]['output']) :
+						$this->portTypes[ $bindingData['portType'] ][$operation]['output'];
+                    if(isset($this->messages[ $this->bindings[$binding]['operations'][$operation]['input']['message'] ])){
+						$this->bindings[$binding]['operations'][$operation]['input']['parts'] = $this->messages[ $this->bindings[$binding]['operations'][$operation]['input']['message'] ];
+					}
+					if(isset($this->messages[ $this->bindings[$binding]['operations'][$operation]['output']['message'] ])){
+                   		$this->bindings[$binding]['operations'][$operation]['output']['parts'] = $this->messages[ $this->bindings[$binding]['operations'][$operation]['output']['message'] ];
+                    }
+                    // Set operation style if necessary, but do not override one already provided
+					if (isset($bindingData['style']) && !isset($this->bindings[$binding]['operations'][$operation]['style'])) {
+                        $this->bindings[$binding]['operations'][$operation]['style'] = $bindingData['style'];
+                    }
+                    $this->bindings[$binding]['operations'][$operation]['transport'] = isset($bindingData['transport']) ? $bindingData['transport'] : '';
+                    $this->bindings[$binding]['operations'][$operation]['documentation'] = isset($this->portTypes[ $bindingData['portType'] ][$operation]['documentation']) ? $this->portTypes[ $bindingData['portType'] ][$operation]['documentation'] : '';
+                    $this->bindings[$binding]['operations'][$operation]['endpoint'] = isset($bindingData['endpoint']) ? $bindingData['endpoint'] : '';
+                } 
+            } 
+        }
+	}
+
+    /**
+     * parses the wsdl document
+     * 
+     * @param string $wsdl path or URL
+     * @access private 
+     */
+    function parseWSDL($wsdl = '') {
+		$this->debug("parse WSDL at path=$wsdl");
+
+        if ($wsdl == '') {
+            $this->debug('no wsdl passed to parseWSDL()!!');
+            $this->setError('no wsdl passed to parseWSDL()!!');
+            return false;
+        }
+        
+        // parse $wsdl for url format
+        $wsdl_props = parse_url($wsdl);
+
+        if (isset($wsdl_props['scheme']) && ($wsdl_props['scheme'] == 'http' || $wsdl_props['scheme'] == 'https')) {
+            $this->debug('getting WSDL http(s) URL ' . $wsdl);
+        	// get wsdl
+	        $tr = new soap_transport_http($wsdl, $this->curl_options, $this->use_curl);
+			$tr->request_method = 'GET';
+			$tr->useSOAPAction = false;
+			if($this->proxyhost && $this->proxyport){
+				$tr->setProxy($this->proxyhost,$this->proxyport,$this->proxyusername,$this->proxypassword);
+			}
+			if ($this->authtype != '') {
+				$tr->setCredentials($this->username, $this->password, $this->authtype, array(), $this->certRequest);
+			}
+			$tr->setEncoding('gzip, deflate');
+			$wsdl_string = $tr->send('', $this->timeout, $this->response_timeout);
+			//$this->debug("WSDL request\n" . $tr->outgoing_payload);
+			//$this->debug("WSDL response\n" . $tr->incoming_payload);
+			$this->appendDebug($tr->getDebug());
+			// catch errors
+			if($err = $tr->getError() ){
+				$errstr = 'Getting ' . $wsdl . ' - HTTP ERROR: '.$err;
+				$this->debug($errstr);
+	            $this->setError($errstr);
+				unset($tr);
+	            return false;
+			}
+			unset($tr);
+			$this->debug("got WSDL URL");
+        } else {
+            // $wsdl is not http(s), so treat it as a file URL or plain file path
+        	if (isset($wsdl_props['scheme']) && ($wsdl_props['scheme'] == 'file') && isset($wsdl_props['path'])) {
+        		$path = isset($wsdl_props['host']) ? ($wsdl_props['host'] . ':' . $wsdl_props['path']) : $wsdl_props['path'];
+        	} else {
+        		$path = $wsdl;
+        	}
+            $this->debug('getting WSDL file ' . $path);
+            if ($fp = @fopen($path, 'r')) {
+                $wsdl_string = '';
+                while ($data = fread($fp, 32768)) {
+                    $wsdl_string .= $data;
+                } 
+                fclose($fp);
+            } else {
+            	$errstr = "Bad path to WSDL file $path";
+            	$this->debug($errstr);
+                $this->setError($errstr);
+                return false;
+            } 
+        }
+        $this->debug('Parse WSDL');
+        // end new code added
+        // Create an XML parser.
+        $this->parser = xml_parser_create(); 
+        // Set the options for parsing the XML data.
+        // xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);
+        xml_parser_set_option($this->parser, XML_OPTION_CASE_FOLDING, 0); 
+        // Set the object for the parser.
+        xml_set_object($this->parser, $this); 
+        // Set the element handlers for the parser.
+        xml_set_element_handler($this->parser, 'start_element', 'end_element');
+        xml_set_character_data_handler($this->parser, 'character_data');
+        // Parse the XML file.
+        if (!xml_parse($this->parser, $wsdl_string, true)) {
+            // Display an error message.
+            $errstr = sprintf(
+				'XML error parsing WSDL from %s on line %d: %s',
+				$wsdl,
+                xml_get_current_line_number($this->parser),
+                xml_error_string(xml_get_error_code($this->parser))
+                );
+            $this->debug($errstr);
+			$this->debug("XML payload:\n" . $wsdl_string);
+            $this->setError($errstr);
+            return false;
+        } 
+		// free the parser
+        xml_parser_free($this->parser);
+        $this->debug('Parsing WSDL done');
+		// catch wsdl parse errors
+		if($this->getError()){
+			return false;
+		}
+        return true;
+    } 
+
+    /**
+     * start-element handler
+     * 
+     * @param string $parser XML parser object
+     * @param string $name element name
+     * @param string $attrs associative array of attributes
+     * @access private 
+     */
+    function start_element($parser, $name, $attrs)
+    {
+        if ($this->status == 'schema') {
+            $this->currentSchema->schemaStartElement($parser, $name, $attrs);
+            $this->appendDebug($this->currentSchema->getDebug());
+            $this->currentSchema->clearDebug();
+        } elseif (preg_match('/schema$/', $name)) {
+        	$this->debug('Parsing WSDL schema');
+            // $this->debug("startElement for $name ($attrs[name]). status = $this->status (".$this->getLocalPart($name).")");
+            $this->status = 'schema';
+            $this->currentSchema = new nusoap_xmlschema('', '', $this->namespaces);
+            $this->currentSchema->schemaStartElement($parser, $name, $attrs);
+            $this->appendDebug($this->currentSchema->getDebug());
+            $this->currentSchema->clearDebug();
+        } else {
+            // position in the total number of elements, starting from 0
+            $pos = $this->position++;
+            $depth = $this->depth++; 
+            // set self as current value for this depth
+            $this->depth_array[$depth] = $pos;
+            $this->message[$pos] = array('cdata' => ''); 
+            // process attributes
+            if (count($attrs) > 0) {
+				// register namespace declarations
+                foreach($attrs as $k => $v) {
+                    if (preg_match('/^xmlns/',$k)) {
+                        if ($ns_prefix = substr(strrchr($k, ':'), 1)) {
+                            $this->namespaces[$ns_prefix] = $v;
+                        } else {
+                            $this->namespaces['ns' . (count($this->namespaces) + 1)] = $v;
+                        } 
+                        if ($v == 'http://www.w3.org/2001/XMLSchema' || $v == 'http://www.w3.org/1999/XMLSchema' || $v == 'http://www.w3.org/2000/10/XMLSchema') {
+                            $this->XMLSchemaVersion = $v;
+                            $this->namespaces['xsi'] = $v . '-instance';
+                        } 
+                    }
+                }
+                // expand each attribute prefix to its namespace
+                foreach($attrs as $k => $v) {
+                    $k = strpos($k, ':') ? $this->expandQname($k) : $k;
+                    if ($k != 'location' && $k != 'soapAction' && $k != 'namespace') {
+                        $v = strpos($v, ':') ? $this->expandQname($v) : $v;
+                    } 
+                    $eAttrs[$k] = $v;
+                } 
+                $attrs = $eAttrs;
+            } else {
+                $attrs = array();
+            } 
+            // get element prefix, namespace and name
+            if (preg_match('/:/', $name)) {
+                // get ns prefix
+                $prefix = substr($name, 0, strpos($name, ':')); 
+                // get ns
+                $namespace = isset($this->namespaces[$prefix]) ? $this->namespaces[$prefix] : ''; 
+                // get unqualified name
+                $name = substr(strstr($name, ':'), 1);
+            } 
+			// process attributes, expanding any prefixes to namespaces
+            // find status, register data
+            switch ($this->status) {
+                case 'message':
+                    if ($name == 'part') {
+			            if (isset($attrs['type'])) {
+		                    $this->debug("msg " . $this->currentMessage . ": found part (with type) $attrs[name]: " . implode(',', $attrs));
+		                    $this->messages[$this->currentMessage][$attrs['name']] = $attrs['type'];
+            			} 
+			            if (isset($attrs['element'])) {
+		                    $this->debug("msg " . $this->currentMessage . ": found part (with element) $attrs[name]: " . implode(',', $attrs));
+			                $this->messages[$this->currentMessage][$attrs['name']] = $attrs['element'] . '^';
+			            } 
+        			} 
+        			break;
+			    case 'portType':
+			        switch ($name) {
+			            case 'operation':
+			                $this->currentPortOperation = $attrs['name'];
+			                $this->debug("portType $this->currentPortType operation: $this->currentPortOperation");
+			                if (isset($attrs['parameterOrder'])) {
+			                	$this->portTypes[$this->currentPortType][$attrs['name']]['parameterOrder'] = $attrs['parameterOrder'];
+			        		} 
+			        		break;
+					    case 'documentation':
+					        $this->documentation = true;
+					        break; 
+					    // merge input/output data
+					    default:
+					        $m = isset($attrs['message']) ? $this->getLocalPart($attrs['message']) : '';
+					        $this->portTypes[$this->currentPortType][$this->currentPortOperation][$name]['message'] = $m;
+					        break;
+					} 
+			    	break;
+				case 'binding':
+				    switch ($name) {
+				        case 'binding': 
+				            // get ns prefix
+				            if (isset($attrs['style'])) {
+				            $this->bindings[$this->currentBinding]['prefix'] = $prefix;
+					    	} 
+					    	$this->bindings[$this->currentBinding] = array_merge($this->bindings[$this->currentBinding], $attrs);
+					    	break;
+						case 'header':
+						    $this->bindings[$this->currentBinding]['operations'][$this->currentOperation][$this->opStatus]['headers'][] = $attrs;
+						    break;
+						case 'operation':
+						    if (isset($attrs['soapAction'])) {
+						        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation]['soapAction'] = $attrs['soapAction'];
+						    } 
+						    if (isset($attrs['style'])) {
+						        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation]['style'] = $attrs['style'];
+						    } 
+						    if (isset($attrs['name'])) {
+						        $this->currentOperation = $attrs['name'];
+						        $this->debug("current binding operation: $this->currentOperation");
+						        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation]['name'] = $attrs['name'];
+						        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation]['binding'] = $this->currentBinding;
+						        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation]['endpoint'] = isset($this->bindings[$this->currentBinding]['endpoint']) ? $this->bindings[$this->currentBinding]['endpoint'] : '';
+						    } 
+						    break;
+						case 'input':
+						    $this->opStatus = 'input';
+						    break;
+						case 'output':
+						    $this->opStatus = 'output';
+						    break;
+						case 'body':
+						    if (isset($this->bindings[$this->currentBinding]['operations'][$this->currentOperation][$this->opStatus])) {
+						        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation][$this->opStatus] = array_merge($this->bindings[$this->currentBinding]['operations'][$this->currentOperation][$this->opStatus], $attrs);
+						    } else {
+						        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation][$this->opStatus] = $attrs;
+						    } 
+						    break;
+					} 
+					break;
+				case 'service':
+					switch ($name) {
+					    case 'port':
+					        $this->currentPort = $attrs['name'];
+					        $this->debug('current port: ' . $this->currentPort);
+					        $this->ports[$this->currentPort]['binding'] = $this->getLocalPart($attrs['binding']);
+					
+					        break;
+					    case 'address':
+					        $this->ports[$this->currentPort]['location'] = $attrs['location'];
+					        $this->ports[$this->currentPort]['bindingType'] = $namespace;
+					        $this->bindings[ $this->ports[$this->currentPort]['binding'] ]['bindingType'] = $namespace;
+					        $this->bindings[ $this->ports[$this->currentPort]['binding'] ]['endpoint'] = $attrs['location'];
+					        break;
+					} 
+					break;
+			} 
+		// set status
+		switch ($name) {
+			case 'import':
+			    if (isset($attrs['location'])) {
+                    $this->import[$attrs['namespace']][] = array('location' => $attrs['location'], 'loaded' => false);
+                    $this->debug('parsing import ' . $attrs['namespace']. ' - ' . $attrs['location'] . ' (' . count($this->import[$attrs['namespace']]).')');
+				} else {
+                    $this->import[$attrs['namespace']][] = array('location' => '', 'loaded' => true);
+					if (! $this->getPrefixFromNamespace($attrs['namespace'])) {
+						$this->namespaces['ns'.(count($this->namespaces)+1)] = $attrs['namespace'];
+					}
+                    $this->debug('parsing import ' . $attrs['namespace']. ' - [no location] (' . count($this->import[$attrs['namespace']]).')');
+				}
+				break;
+			//wait for schema
+			//case 'types':
+			//	$this->status = 'schema';
+			//	break;
+			case 'message':
+				$this->status = 'message';
+				$this->messages[$attrs['name']] = array();
+				$this->currentMessage = $attrs['name'];
+				break;
+			case 'portType':
+				$this->status = 'portType';
+				$this->portTypes[$attrs['name']] = array();
+				$this->currentPortType = $attrs['name'];
+				break;
+			case "binding":
+				if (isset($attrs['name'])) {
+				// get binding name
+					if (strpos($attrs['name'], ':')) {
+			    		$this->currentBinding = $this->getLocalPart($attrs['name']);
+					} else {
+			    		$this->currentBinding = $attrs['name'];
+					} 
+					$this->status = 'binding';
+					$this->bindings[$this->currentBinding]['portType'] = $this->getLocalPart($attrs['type']);
+					$this->debug("current binding: $this->currentBinding of portType: " . $attrs['type']);
+				} 
+				break;
+			case 'service':
+				$this->serviceName = $attrs['name'];
+				$this->status = 'service';
+				$this->debug('current service: ' . $this->serviceName);
+				break;
+			case 'definitions':
+				foreach ($attrs as $name => $value) {
+					$this->wsdl_info[$name] = $value;
+				} 
+				break;
+			} 
+		} 
+	} 
+
+	/**
+	* end-element handler
+	* 
+	* @param string $parser XML parser object
+	* @param string $name element name
+	* @access private 
+	*/
+	function end_element($parser, $name){ 
+		// unset schema status
+		if (/*preg_match('/types$/', $name) ||*/ preg_match('/schema$/', $name)) {
+			$this->status = "";
+            $this->appendDebug($this->currentSchema->getDebug());
+            $this->currentSchema->clearDebug();
+			$this->schemas[$this->currentSchema->schemaTargetNamespace][] = $this->currentSchema;
+        	$this->debug('Parsing WSDL schema done');
+		} 
+		if ($this->status == 'schema') {
+			$this->currentSchema->schemaEndElement($parser, $name);
+		} else {
+			// bring depth down a notch
+			$this->depth--;
+		} 
+		// end documentation
+		if ($this->documentation) {
+			//TODO: track the node to which documentation should be assigned; it can be a part, message, etc.
+			//$this->portTypes[$this->currentPortType][$this->currentPortOperation]['documentation'] = $this->documentation;
+			$this->documentation = false;
+		} 
+	} 
+
+	/**
+	 * element content handler
+	 * 
+	 * @param string $parser XML parser object
+	 * @param string $data element content
+	 * @access private 
+	 */
+	function character_data($parser, $data)
+	{
+		$pos = isset($this->depth_array[$this->depth]) ? $this->depth_array[$this->depth] : 0;
+		if (isset($this->message[$pos]['cdata'])) {
+			$this->message[$pos]['cdata'] .= $data;
+		} 
+		if ($this->documentation) {
+			$this->documentation .= $data;
+		} 
+	} 
+
+	/**
+	* if authenticating, set user credentials here
+	*
+	* @param    string $username
+	* @param    string $password
+	* @param	string $authtype (basic|digest|certificate|ntlm)
+	* @param	array $certRequest (keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, certpassword (optional), verifypeer (optional), verifyhost (optional): see corresponding options in cURL docs)
+	* @access   public
+	*/
+	function setCredentials($username, $password, $authtype = 'basic', $certRequest = array()) {
+		$this->debug("setCredentials username=$username authtype=$authtype certRequest=");
+		$this->appendDebug($this->varDump($certRequest));
+		$this->username = $username;
+		$this->password = $password;
+		$this->authtype = $authtype;
+		$this->certRequest = $certRequest;
+	}
+	
+	function getBindingData($binding)
+	{
+		if (is_array($this->bindings[$binding])) {
+			return $this->bindings[$binding];
+		} 
+	}
+	
+	/**
+	 * returns an assoc array of operation names => operation data
+	 * 
+	 * @param string $portName WSDL port name
+	 * @param string $bindingType eg: soap, smtp, dime (only soap and soap12 are currently supported)
+	 * @return array 
+	 * @access public 
+	 */
+	function getOperations($portName = '', $bindingType = 'soap') {
+		$ops = array();
+		if ($bindingType == 'soap') {
+			$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap/';
+		} elseif ($bindingType == 'soap12') {
+			$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap12/';
+		} else {
+			$this->debug("getOperations bindingType $bindingType may not be supported");
+		}
+		$this->debug("getOperations for port '$portName' bindingType $bindingType");
+		// loop thru ports
+		foreach($this->ports as $port => $portData) {
+			$this->debug("getOperations checking port $port bindingType " . $portData['bindingType']);
+			if ($portName == '' || $port == $portName) {
+				// binding type of port matches parameter
+				if ($portData['bindingType'] == $bindingType) {
+					$this->debug("getOperations found port $port bindingType $bindingType");
+					//$this->debug("port data: " . $this->varDump($portData));
+					//$this->debug("bindings: " . $this->varDump($this->bindings[ $portData['binding'] ]));
+					// merge bindings
+					if (isset($this->bindings[ $portData['binding'] ]['operations'])) {
+						$ops = array_merge ($ops, $this->bindings[ $portData['binding'] ]['operations']);
+					}
+				}
+			}
+		}
+		if (count($ops) == 0) {
+			$this->debug("getOperations found no operations for port '$portName' bindingType $bindingType");
+		}
+		return $ops;
+	} 
+	
+	/**
+	 * returns an associative array of data necessary for calling an operation
+	 * 
+	 * @param string $operation name of operation
+	 * @param string $bindingType type of binding eg: soap, soap12
+	 * @return array 
+	 * @access public 
+	 */
+	function getOperationData($operation, $bindingType = 'soap')
+	{
+		if ($bindingType == 'soap') {
+			$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap/';
+		} elseif ($bindingType == 'soap12') {
+			$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap12/';
+		}
+		// loop thru ports
+		foreach($this->ports as $port => $portData) {
+			// binding type of port matches parameter
+			if ($portData['bindingType'] == $bindingType) {
+				// get binding
+				//foreach($this->bindings[ $portData['binding'] ]['operations'] as $bOperation => $opData) {
+				foreach(array_keys($this->bindings[ $portData['binding'] ]['operations']) as $bOperation) {
+					// note that we could/should also check the namespace here
+					if ($operation == $bOperation) {
+						$opData = $this->bindings[ $portData['binding'] ]['operations'][$operation];
+					    return $opData;
+					} 
+				} 
+			}
+		} 
+	}
+	
+	/**
+	 * returns an associative array of data necessary for calling an operation
+	 * 
+	 * @param string $soapAction soapAction for operation
+	 * @param string $bindingType type of binding eg: soap, soap12
+	 * @return array 
+	 * @access public 
+	 */
+	function getOperationDataForSoapAction($soapAction, $bindingType = 'soap') {
+		if ($bindingType == 'soap') {
+			$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap/';
+		} elseif ($bindingType == 'soap12') {
+			$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap12/';
+		}
+		// loop thru ports
+		foreach($this->ports as $port => $portData) {
+			// binding type of port matches parameter
+			if ($portData['bindingType'] == $bindingType) {
+				// loop through operations for the binding
+				foreach ($this->bindings[ $portData['binding'] ]['operations'] as $bOperation => $opData) {
+					if ($opData['soapAction'] == $soapAction) {
+					    return $opData;
+					} 
+				} 
+			}
+		} 
+	}
+	
+	/**
+    * returns an array of information about a given type
+    * returns false if no type exists by the given name
+    *
+	*	 typeDef = array(
+	*	 'elements' => array(), // refs to elements array
+	*	'restrictionBase' => '',
+	*	'phpType' => '',
+	*	'order' => '(sequence|all)',
+	*	'attrs' => array() // refs to attributes array
+	*	)
+    *
+    * @param string $type the type
+    * @param string $ns namespace (not prefix) of the type
+    * @return mixed
+    * @access public
+    * @see nusoap_xmlschema
+    */
+	function getTypeDef($type, $ns) {
+		$this->debug("in getTypeDef: type=$type, ns=$ns");
+		if ((! $ns) && isset($this->namespaces['tns'])) {
+			$ns = $this->namespaces['tns'];
+			$this->debug("in getTypeDef: type namespace forced to $ns");
+		}
+		if (!isset($this->schemas[$ns])) {
+			foreach ($this->schemas as $ns0 => $schema0) {
+				if (strcasecmp($ns, $ns0) == 0) {
+					$this->debug("in getTypeDef: replacing schema namespace $ns with $ns0");
+					$ns = $ns0;
+					break;
+				}
+			}
+		}
+		if (isset($this->schemas[$ns])) {
+			$this->debug("in getTypeDef: have schema for namespace $ns");
+			for ($i = 0; $i < count($this->schemas[$ns]); $i++) {
+				$xs = &$this->schemas[$ns][$i];
+				$t = $xs->getTypeDef($type);
+				$this->appendDebug($xs->getDebug());
+				$xs->clearDebug();
+				if ($t) {
+					$this->debug("in getTypeDef: found type $type");
+					if (!isset($t['phpType'])) {
+						// get info for type to tack onto the element
+						$uqType = substr($t['type'], strrpos($t['type'], ':') + 1);
+						$ns = substr($t['type'], 0, strrpos($t['type'], ':'));
+						$etype = $this->getTypeDef($uqType, $ns);
+						if ($etype) {
+							$this->debug("found type for [element] $type:");
+							$this->debug($this->varDump($etype));
+							if (isset($etype['phpType'])) {
+								$t['phpType'] = $etype['phpType'];
+							}
+							if (isset($etype['elements'])) {
+								$t['elements'] = $etype['elements'];
+							}
+							if (isset($etype['attrs'])) {
+								$t['attrs'] = $etype['attrs'];
+							}
+						} else {
+							$this->debug("did not find type for [element] $type");
+						}
+					}
+					return $t;
+				}
+			}
+			$this->debug("in getTypeDef: did not find type $type");
+		} else {
+			$this->debug("in getTypeDef: do not have schema for namespace $ns");
+		}
+		return false;
+	}
+
+    /**
+    * prints html description of services
+    *
+    * @access private
+    */
+    function webDescription(){
+    	global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER)) {
+			$PHP_SELF = $_SERVER['PHP_SELF'];
+		} elseif (isset($HTTP_SERVER_VARS)) {
+			$PHP_SELF = $HTTP_SERVER_VARS['PHP_SELF'];
+		} else {
+			$this->setError("Neither _SERVER nor HTTP_SERVER_VARS is available");
+		}
+
+		$b = '
+		<html><head><title>NuSOAP: '.$this->serviceName.'</title>
+		<style type="text/css">
+		    body    { font-family: arial; color: #000000; background-color: #ffffff; margin: 0px 0px 0px 0px; }
+		    p       { font-family: arial; color: #000000; margin-top: 0px; margin-bottom: 12px; }
+		    pre { background-color: silver; padding: 5px; font-family: Courier New; font-size: x-small; color: #000000;}
+		    ul      { margin-top: 10px; margin-left: 20px; }
+		    li      { list-style-type: none; margin-top: 10px; color: #000000; }
+		    .content{
+			margin-left: 0px; padding-bottom: 2em; }
+		    .nav {
+			padding-top: 10px; padding-bottom: 10px; padding-left: 15px; font-size: .70em;
+			margin-top: 10px; margin-left: 0px; color: #000000;
+			background-color: #ccccff; width: 20%; margin-left: 20px; margin-top: 20px; }
+		    .title {
+			font-family: arial; font-size: 26px; color: #ffffff;
+			background-color: #999999; width: 100%;
+			margin-left: 0px; margin-right: 0px;
+			padding-top: 10px; padding-bottom: 10px;}
+		    .hidden {
+			position: absolute; visibility: hidden; z-index: 200; left: 250px; top: 100px;
+			font-family: arial; overflow: hidden; width: 600;
+			padding: 20px; font-size: 10px; background-color: #999999;
+			layer-background-color:#FFFFFF; }
+		    a,a:active  { color: charcoal; font-weight: bold; }
+		    a:visited   { color: #666666; font-weight: bold; }
+		    a:hover     { color: cc3300; font-weight: bold; }
+		</style>
+		<script language="JavaScript" type="text/javascript">
+		<!--
+		// POP-UP CAPTIONS...
+		function lib_bwcheck(){ //Browsercheck (needed)
+		    this.ver=navigator.appVersion
+		    this.agent=navigator.userAgent
+		    this.dom=document.getElementById?1:0
+		    this.opera5=this.agent.indexOf("Opera 5")>-1
+		    this.ie5=(this.ver.indexOf("MSIE 5")>-1 && this.dom && !this.opera5)?1:0;
+		    this.ie6=(this.ver.indexOf("MSIE 6")>-1 && this.dom && !this.opera5)?1:0;
+		    this.ie4=(document.all && !this.dom && !this.opera5)?1:0;
+		    this.ie=this.ie4||this.ie5||this.ie6
+		    this.mac=this.agent.indexOf("Mac")>-1
+		    this.ns6=(this.dom && parseInt(this.ver) >= 5) ?1:0;
+		    this.ns4=(document.layers && !this.dom)?1:0;
+		    this.bw=(this.ie6 || this.ie5 || this.ie4 || this.ns4 || this.ns6 || this.opera5)
+		    return this
+		}
+		var bw = new lib_bwcheck()
+		//Makes crossbrowser object.
+		function makeObj(obj){
+		    this.evnt=bw.dom? document.getElementById(obj):bw.ie4?document.all[obj]:bw.ns4?document.layers[obj]:0;
+		    if(!this.evnt) return false
+		    this.css=bw.dom||bw.ie4?this.evnt.style:bw.ns4?this.evnt:0;
+		    this.wref=bw.dom||bw.ie4?this.evnt:bw.ns4?this.css.document:0;
+		    this.writeIt=b_writeIt;
+		    return this
+		}
+		// A unit of measure that will be added when setting the position of a layer.
+		//var px = bw.ns4||window.opera?"":"px";
+		function b_writeIt(text){
+		    if (bw.ns4){this.wref.write(text);this.wref.close()}
+		    else this.wref.innerHTML = text
+		}
+		//Shows the messages
+		var oDesc;
+		function popup(divid){
+		    if(oDesc = new makeObj(divid)){
+			oDesc.css.visibility = "visible"
+		    }
+		}
+		function popout(){ // Hides message
+		    if(oDesc) oDesc.css.visibility = "hidden"
+		}
+		//-->
+		</script>
+		</head>
+		<body>
+		<div class=content>
+			<br><br>
+			<div class=title>'.htmlentities($this->serviceName).'</div>
+			<div class=nav>
+				<p>View the <a href="'.htmlentities($PHP_SELF).'?wsdl">WSDL</a> for the service.
+				Click on an operation name to view it&apos;s details.</p>
+				<ul>';
+				foreach($this->getOperations() as $op => $data){
+				    $b .= "<li><a href='#' onclick=\"popout();popup('$op')\">$op</a></li>";
+				    // create hidden div
+				    $b .= "<div id='$op' class='hidden'>
+				    <a href='#' onclick='popout()'><font color='#ffffff'>Close</font></a><br><br>";
+				    foreach($data as $donnie => $marie){ // loop through opdata
+						if($donnie == 'input' || $donnie == 'output'){ // show input/output data
+						    $b .= "<font color='white'>".htmlentities(ucfirst($donnie)).':</font><br>';
+						    foreach($marie as $captain => $tenille){ // loop through data
+								if($captain == 'parts'){ // loop thru parts
+								    $b .= "&nbsp;&nbsp;".htmlentities($captain).":<br>";
+					                //if(is_array($tenille)){
+								    	foreach($tenille as $joanie => $chachi){
+											$b .= "&nbsp;&nbsp;&nbsp;&nbsp;".htmlentities($joanie).": ".htmlentities($chachi)."<br>";
+								    	}
+					        		//}
+								} else {
+								    $b .= "&nbsp;&nbsp;".htmlentities($captain).": ".htmlentities($tenille)."<br>";
+								}
+						    }
+						} else {
+						    $b .= "<font color='white'>".htmlentities(ucfirst($donnie)).":</font> ".htmlentities($marie)."<br>";
+						}
+				    }
+					$b .= '</div>';
+				}
+				$b .= '
+				<ul>
+			</div>
+		</div></body></html>';
+		return $b;
+    }
+
+	/**
+	* serialize the parsed wsdl
+	*
+	* @param mixed $debug whether to put debug=1 in endpoint URL
+	* @return string serialization of WSDL
+	* @access public 
+	*/
+	function serialize($debug = 0)
+	{
+		$xml = '<?xml version="1.0" encoding="ISO-8859-1"?>';
+		$xml .= "\n<definitions";
+		foreach($this->namespaces as $k => $v) {
+			$xml .= " xmlns:$k=\"$v\"";
+		} 
+		// 10.9.02 - add poulter fix for wsdl and tns declarations
+		if (isset($this->namespaces['wsdl'])) {
+			$xml .= " xmlns=\"" . $this->namespaces['wsdl'] . "\"";
+		} 
+		if (isset($this->namespaces['tns'])) {
+			$xml .= " targetNamespace=\"" . $this->namespaces['tns'] . "\"";
+		} 
+		$xml .= '>'; 
+		// imports
+		if (sizeof($this->import) > 0) {
+			foreach($this->import as $ns => $list) {
+				foreach ($list as $ii) {
+					if ($ii['location'] != '') {
+						$xml .= '<import location="' . $ii['location'] . '" namespace="' . $ns . '" />';
+					} else {
+						$xml .= '<import namespace="' . $ns . '" />';
+					}
+				}
+			} 
+		} 
+		// types
+		if (count($this->schemas)>=1) {
+			$xml .= "\n<types>\n";
+			foreach ($this->schemas as $ns => $list) {
+				foreach ($list as $xs) {
+					$xml .= $xs->serializeSchema();
+				}
+			}
+			$xml .= '</types>';
+		} 
+		// messages
+		if (count($this->messages) >= 1) {
+			foreach($this->messages as $msgName => $msgParts) {
+				$xml .= "\n<message name=\"" . $msgName . '">';
+				if(is_array($msgParts)){
+					foreach($msgParts as $partName => $partType) {
+						// print 'serializing '.$partType.', sv: '.$this->XMLSchemaVersion.'<br>';
+						if (strpos($partType, ':')) {
+						    $typePrefix = $this->getPrefixFromNamespace($this->getPrefix($partType));
+						} elseif (isset($this->typemap[$this->namespaces['xsd']][$partType])) {
+						    // print 'checking typemap: '.$this->XMLSchemaVersion.'<br>';
+						    $typePrefix = 'xsd';
+						} else {
+						    foreach($this->typemap as $ns => $types) {
+						        if (isset($types[$partType])) {
+						            $typePrefix = $this->getPrefixFromNamespace($ns);
+						        } 
+						    } 
+						    if (!isset($typePrefix)) {
+						        die("$partType has no namespace!");
+						    } 
+						}
+						$ns = $this->getNamespaceFromPrefix($typePrefix);
+						$localPart = $this->getLocalPart($partType);
+						$typeDef = $this->getTypeDef($localPart, $ns);
+						if ($typeDef['typeClass'] == 'element') {
+							$elementortype = 'element';
+							if (substr($localPart, -1) == '^') {
+								$localPart = substr($localPart, 0, -1);
+							}
+						} else {
+							$elementortype = 'type';
+						}
+						$xml .= "\n" . '  <part name="' . $partName . '" ' . $elementortype . '="' . $typePrefix . ':' . $localPart . '" />';
+					}
+				}
+				$xml .= '</message>';
+			} 
+		} 
+		// bindings & porttypes
+		if (count($this->bindings) >= 1) {
+			$binding_xml = '';
+			$portType_xml = '';
+			foreach($this->bindings as $bindingName => $attrs) {
+				$binding_xml .= "\n<binding name=\"" . $bindingName . '" type="tns:' . $attrs['portType'] . '">';
+				$binding_xml .= "\n" . '  <soap:binding style="' . $attrs['style'] . '" transport="' . $attrs['transport'] . '"/>';
+				$portType_xml .= "\n<portType name=\"" . $attrs['portType'] . '">';
+				foreach($attrs['operations'] as $opName => $opParts) {
+					$binding_xml .= "\n" . '  <operation name="' . $opName . '">';
+					$binding_xml .= "\n" . '    <soap:operation soapAction="' . $opParts['soapAction'] . '" style="'. $opParts['style'] . '"/>';
+					if (isset($opParts['input']['encodingStyle']) && $opParts['input']['encodingStyle'] != '') {
+						$enc_style = ' encodingStyle="' . $opParts['input']['encodingStyle'] . '"';
+					} else {
+						$enc_style = '';
+					}
+					$binding_xml .= "\n" . '    <input><soap:body use="' . $opParts['input']['use'] . '" namespace="' . $opParts['input']['namespace'] . '"' . $enc_style . '/></input>';
+					if (isset($opParts['output']['encodingStyle']) && $opParts['output']['encodingStyle'] != '') {
+						$enc_style = ' encodingStyle="' . $opParts['output']['encodingStyle'] . '"';
+					} else {
+						$enc_style = '';
+					}
+					$binding_xml .= "\n" . '    <output><soap:body use="' . $opParts['output']['use'] . '" namespace="' . $opParts['output']['namespace'] . '"' . $enc_style . '/></output>';
+					$binding_xml .= "\n" . '  </operation>';
+					$portType_xml .= "\n" . '  <operation name="' . $opParts['name'] . '"';
+					if (isset($opParts['parameterOrder'])) {
+					    $portType_xml .= ' parameterOrder="' . $opParts['parameterOrder'] . '"';
+					} 
+					$portType_xml .= '>';
+					if(isset($opParts['documentation']) && $opParts['documentation'] != '') {
+						$portType_xml .= "\n" . '    <documentation>' . htmlspecialchars($opParts['documentation']) . '</documentation>';
+					}
+					$portType_xml .= "\n" . '    <input message="tns:' . $opParts['input']['message'] . '"/>';
+					$portType_xml .= "\n" . '    <output message="tns:' . $opParts['output']['message'] . '"/>';
+					$portType_xml .= "\n" . '  </operation>';
+				} 
+				$portType_xml .= "\n" . '</portType>';
+				$binding_xml .= "\n" . '</binding>';
+			} 
+			$xml .= $portType_xml . $binding_xml;
+		} 
+		// services
+		$xml .= "\n<service name=\"" . $this->serviceName . '">';
+		if (count($this->ports) >= 1) {
+			foreach($this->ports as $pName => $attrs) {
+				$xml .= "\n" . '  <port name="' . $pName . '" binding="tns:' . $attrs['binding'] . '">';
+				$xml .= "\n" . '    <soap:address location="' . $attrs['location'] . ($debug ? '?debug=1' : '') . '"/>';
+				$xml .= "\n" . '  </port>';
+			} 
+		} 
+		$xml .= "\n" . '</service>';
+		return $xml . "\n</definitions>";
+	} 
+
+	/**
+	 * determine whether a set of parameters are unwrapped
+	 * when they are expect to be wrapped, Microsoft-style.
+	 *
+	 * @param string $type the type (element name) of the wrapper
+	 * @param array $parameters the parameter values for the SOAP call
+	 * @return boolean whether they parameters are unwrapped (and should be wrapped)
+	 * @access private
+	 */
+	function parametersMatchWrapped($type, &$parameters) {
+		$this->debug("in parametersMatchWrapped type=$type, parameters=");
+		$this->appendDebug($this->varDump($parameters));
+
+		// split type into namespace:unqualified-type
+		if (strpos($type, ':')) {
+			$uqType = substr($type, strrpos($type, ':') + 1);
+			$ns = substr($type, 0, strrpos($type, ':'));
+			$this->debug("in parametersMatchWrapped: got a prefixed type: $uqType, $ns");
+			if ($this->getNamespaceFromPrefix($ns)) {
+				$ns = $this->getNamespaceFromPrefix($ns);
+				$this->debug("in parametersMatchWrapped: expanded prefixed type: $uqType, $ns");
+			}
+		} else {
+			// TODO: should the type be compared to types in XSD, and the namespace
+			// set to XSD if the type matches?
+			$this->debug("in parametersMatchWrapped: No namespace for type $type");
+			$ns = '';
+			$uqType = $type;
+		}
+
+		// get the type information
+		if (!$typeDef = $this->getTypeDef($uqType, $ns)) {
+			$this->debug("in parametersMatchWrapped: $type ($uqType) is not a supported type.");
+			return false;
+		}
+		$this->debug("in parametersMatchWrapped: found typeDef=");
+		$this->appendDebug($this->varDump($typeDef));
+		if (substr($uqType, -1) == '^') {
+			$uqType = substr($uqType, 0, -1);
+		}
+		$phpType = $typeDef['phpType'];
+		$arrayType = (isset($typeDef['arrayType']) ? $typeDef['arrayType'] : '');
+		$this->debug("in parametersMatchWrapped: uqType: $uqType, ns: $ns, phptype: $phpType, arrayType: $arrayType");
+		
+		// we expect a complexType or element of complexType
+		if ($phpType != 'struct') {
+			$this->debug("in parametersMatchWrapped: not a struct");
+			return false;
+		}
+
+		// see whether the parameter names match the elements
+		if (isset($typeDef['elements']) && is_array($typeDef['elements'])) {
+			$elements = 0;
+			$matches = 0;
+			foreach ($typeDef['elements'] as $name => $attrs) {
+				if (isset($parameters[$name])) {
+					$this->debug("in parametersMatchWrapped: have parameter named $name");
+					$matches++;
+				} else {
+					$this->debug("in parametersMatchWrapped: do not have parameter named $name");
+				}
+				$elements++;
+			}
+
+			$this->debug("in parametersMatchWrapped: $matches parameter names match $elements wrapped parameter names");
+			if ($matches == 0) {
+				return false;
+			}
+			return true;
+		}
+
+		// since there are no elements for the type, if the user passed no
+		// parameters, the parameters match wrapped.
+		$this->debug("in parametersMatchWrapped: no elements type $ns:$uqType");
+		return count($parameters) == 0;
+	}
+
+	/**
+	 * serialize PHP values according to a WSDL message definition
+	 * contrary to the method name, this is not limited to RPC
+	 *
+	 * TODO
+	 * - multi-ref serialization
+	 * - validate PHP values against type definitions, return errors if invalid
+	 * 
+	 * @param string $operation operation name
+	 * @param string $direction (input|output)
+	 * @param mixed $parameters parameter value(s)
+	 * @param string $bindingType (soap|soap12)
+	 * @return mixed parameters serialized as XML or false on error (e.g. operation not found)
+	 * @access public
+	 */
+	function serializeRPCParameters($operation, $direction, $parameters, $bindingType = 'soap') {
+		$this->debug("in serializeRPCParameters: operation=$operation, direction=$direction, XMLSchemaVersion=$this->XMLSchemaVersion, bindingType=$bindingType");
+		$this->appendDebug('parameters=' . $this->varDump($parameters));
+		
+		if ($direction != 'input' && $direction != 'output') {
+			$this->debug('The value of the \$direction argument needs to be either "input" or "output"');
+			$this->setError('The value of the \$direction argument needs to be either "input" or "output"');
+			return false;
+		} 
+		if (!$opData = $this->getOperationData($operation, $bindingType)) {
+			$this->debug('Unable to retrieve WSDL data for operation: ' . $operation . ' bindingType: ' . $bindingType);
+			$this->setError('Unable to retrieve WSDL data for operation: ' . $operation . ' bindingType: ' . $bindingType);
+			return false;
+		}
+		$this->debug('in serializeRPCParameters: opData:');
+		$this->appendDebug($this->varDump($opData));
+
+		// Get encoding style for output and set to current
+		$encodingStyle = 'http://schemas.xmlsoap.org/soap/encoding/';
+		if(($direction == 'input') && isset($opData['output']['encodingStyle']) && ($opData['output']['encodingStyle'] != $encodingStyle)) {
+			$encodingStyle = $opData['output']['encodingStyle'];
+			$enc_style = $encodingStyle;
+		}
+
+		// set input params
+		$xml = '';
+		if (isset($opData[$direction]['parts']) && sizeof($opData[$direction]['parts']) > 0) {
+			$parts = &$opData[$direction]['parts'];
+			$part_count = sizeof($parts);
+			$style = $opData['style'];
+			$use = $opData[$direction]['use'];
+			$this->debug("have $part_count part(s) to serialize using $style/$use");
+			if (is_array($parameters)) {
+				$parametersArrayType = $this->isArraySimpleOrStruct($parameters);
+				$parameter_count = count($parameters);
+				$this->debug("have $parameter_count parameter(s) provided as $parametersArrayType to serialize");
+				// check for Microsoft-style wrapped parameters
+				if ($style == 'document' && $use == 'literal' && $part_count == 1 && isset($parts['parameters'])) {
+					$this->debug('check whether the caller has wrapped the parameters');
+					if ($direction == 'output' && $parametersArrayType == 'arraySimple' && $parameter_count == 1) {
+						// TODO: consider checking here for double-wrapping, when
+						// service function wraps, then NuSOAP wraps again
+						$this->debug("change simple array to associative with 'parameters' element");
+						$parameters['parameters'] = $parameters[0];
+						unset($parameters[0]);
+					}
+					if (($parametersArrayType == 'arrayStruct' || $parameter_count == 0) && !isset($parameters['parameters'])) {
+						$this->debug('check whether caller\'s parameters match the wrapped ones');
+						if ($this->parametersMatchWrapped($parts['parameters'], $parameters)) {
+							$this->debug('wrap the parameters for the caller');
+							$parameters = array('parameters' => $parameters);
+							$parameter_count = 1;
+						}
+					}
+				}
+				foreach ($parts as $name => $type) {
+					$this->debug("serializing part $name of type $type");
+					// Track encoding style
+					if (isset($opData[$direction]['encodingStyle']) && $encodingStyle != $opData[$direction]['encodingStyle']) {
+						$encodingStyle = $opData[$direction]['encodingStyle'];			
+						$enc_style = $encodingStyle;
+					} else {
+						$enc_style = false;
+					}
+					// NOTE: add error handling here
+					// if serializeType returns false, then catch global error and fault
+					if ($parametersArrayType == 'arraySimple') {
+						$p = array_shift($parameters);
+						$this->debug('calling serializeType w/indexed param');
+						$xml .= $this->serializeType($name, $type, $p, $use, $enc_style);
+					} elseif (isset($parameters[$name])) {
+						$this->debug('calling serializeType w/named param');
+						$xml .= $this->serializeType($name, $type, $parameters[$name], $use, $enc_style);
+					} else {
+						// TODO: only send nillable
+						$this->debug('calling serializeType w/null param');
+						$xml .= $this->serializeType($name, $type, null, $use, $enc_style);
+					}
+				}
+			} else {
+				$this->debug('no parameters passed.');
+			}
+		}
+		$this->debug("serializeRPCParameters returning: $xml");
+		return $xml;
+	} 
+	
+	/**
+	 * serialize a PHP value according to a WSDL message definition
+	 * 
+	 * TODO
+	 * - multi-ref serialization
+	 * - validate PHP values against type definitions, return errors if invalid
+	 * 
+	 * @param string $operation operation name
+	 * @param string $direction (input|output)
+	 * @param mixed $parameters parameter value(s)
+	 * @return mixed parameters serialized as XML or false on error (e.g. operation not found)
+	 * @access public
+	 * @deprecated
+	 */
+	function serializeParameters($operation, $direction, $parameters)
+	{
+		$this->debug("in serializeParameters: operation=$operation, direction=$direction, XMLSchemaVersion=$this->XMLSchemaVersion"); 
+		$this->appendDebug('parameters=' . $this->varDump($parameters));
+		
+		if ($direction != 'input' && $direction != 'output') {
+			$this->debug('The value of the \$direction argument needs to be either "input" or "output"');
+			$this->setError('The value of the \$direction argument needs to be either "input" or "output"');
+			return false;
+		} 
+		if (!$opData = $this->getOperationData($operation)) {
+			$this->debug('Unable to retrieve WSDL data for operation: ' . $operation);
+			$this->setError('Unable to retrieve WSDL data for operation: ' . $operation);
+			return false;
+		}
+		$this->debug('opData:');
+		$this->appendDebug($this->varDump($opData));
+		
+		// Get encoding style for output and set to current
+		$encodingStyle = 'http://schemas.xmlsoap.org/soap/encoding/';
+		if(($direction == 'input') && isset($opData['output']['encodingStyle']) && ($opData['output']['encodingStyle'] != $encodingStyle)) {
+			$encodingStyle = $opData['output']['encodingStyle'];
+			$enc_style = $encodingStyle;
+		}
+		
+		// set input params
+		$xml = '';
+		if (isset($opData[$direction]['parts']) && sizeof($opData[$direction]['parts']) > 0) {
+			
+			$use = $opData[$direction]['use'];
+			$this->debug("use=$use");
+			$this->debug('got ' . count($opData[$direction]['parts']) . ' part(s)');
+			if (is_array($parameters)) {
+				$parametersArrayType = $this->isArraySimpleOrStruct($parameters);
+				$this->debug('have ' . $parametersArrayType . ' parameters');
+				foreach($opData[$direction]['parts'] as $name => $type) {
+					$this->debug('serializing part "'.$name.'" of type "'.$type.'"');
+					// Track encoding style
+					if(isset($opData[$direction]['encodingStyle']) && $encodingStyle != $opData[$direction]['encodingStyle']) {
+						$encodingStyle = $opData[$direction]['encodingStyle'];			
+						$enc_style = $encodingStyle;
+					} else {
+						$enc_style = false;
+					}
+					// NOTE: add error handling here
+					// if serializeType returns false, then catch global error and fault
+					if ($parametersArrayType == 'arraySimple') {
+						$p = array_shift($parameters);
+						$this->debug('calling serializeType w/indexed param');
+						$xml .= $this->serializeType($name, $type, $p, $use, $enc_style);
+					} elseif (isset($parameters[$name])) {
+						$this->debug('calling serializeType w/named param');
+						$xml .= $this->serializeType($name, $type, $parameters[$name], $use, $enc_style);
+					} else {
+						// TODO: only send nillable
+						$this->debug('calling serializeType w/null param');
+						$xml .= $this->serializeType($name, $type, null, $use, $enc_style);
+					}
+				}
+			} else {
+				$this->debug('no parameters passed.');
+			}
+		}
+		$this->debug("serializeParameters returning: $xml");
+		return $xml;
+	} 
+	
+	/**
+	 * serializes a PHP value according a given type definition
+	 * 
+	 * @param string $name name of value (part or element)
+	 * @param string $type XML schema type of value (type or element)
+	 * @param mixed $value a native PHP value (parameter value)
+	 * @param string $use use for part (encoded|literal)
+	 * @param string $encodingStyle SOAP encoding style for the value (if different than the enclosing style)
+	 * @param boolean $unqualified a kludge for what should be XML namespace form handling
+	 * @return string value serialized as an XML string
+	 * @access private
+	 */
+	function serializeType($name, $type, $value, $use='encoded', $encodingStyle=false, $unqualified=false)
+	{
+		$this->debug("in serializeType: name=$name, type=$type, use=$use, encodingStyle=$encodingStyle, unqualified=" . ($unqualified ? "unqualified" : "qualified"));
+		$this->appendDebug("value=" . $this->varDump($value));
+		if($use == 'encoded' && $encodingStyle) {
+			$encodingStyle = ' SOAP-ENV:encodingStyle="' . $encodingStyle . '"';
+		}
+
+		// if a soapval has been supplied, let its type override the WSDL
+    	if (is_object($value) && get_class($value) == 'soapval') {
+    		if ($value->type_ns) {
+    			$type = $value->type_ns . ':' . $value->type;
+		    	$forceType = true;
+		    	$this->debug("in serializeType: soapval overrides type to $type");
+    		} elseif ($value->type) {
+	    		$type = $value->type;
+		    	$forceType = true;
+		    	$this->debug("in serializeType: soapval overrides type to $type");
+	    	} else {
+	    		$forceType = false;
+		    	$this->debug("in serializeType: soapval does not override type");
+	    	}
+	    	$attrs = $value->attributes;
+	    	$value = $value->value;
+	    	$this->debug("in serializeType: soapval overrides value to $value");
+	    	if ($attrs) {
+	    		if (!is_array($value)) {
+	    			$value['!'] = $value;
+	    		}
+	    		foreach ($attrs as $n => $v) {
+	    			$value['!' . $n] = $v;
+	    		}
+		    	$this->debug("in serializeType: soapval provides attributes");
+		    }
+        } else {
+        	$forceType = false;
+        }
+
+		$xml = '';
+		if (strpos($type, ':')) {
+			$uqType = substr($type, strrpos($type, ':') + 1);
+			$ns = substr($type, 0, strrpos($type, ':'));
+			$this->debug("in serializeType: got a prefixed type: $uqType, $ns");
+			if ($this->getNamespaceFromPrefix($ns)) {
+				$ns = $this->getNamespaceFromPrefix($ns);
+				$this->debug("in serializeType: expanded prefixed type: $uqType, $ns");
+			}
+
+			if($ns == $this->XMLSchemaVersion || $ns == 'http://schemas.xmlsoap.org/soap/encoding/'){
+				$this->debug('in serializeType: type namespace indicates XML Schema or SOAP Encoding type');
+				if ($unqualified && $use == 'literal') {
+					$elementNS = " xmlns=\"\"";
+				} else {
+					$elementNS = '';
+				}
+				if (is_null($value)) {
+					if ($use == 'literal') {
+						// TODO: depends on minOccurs
+						$xml = "<$name$elementNS/>";
+					} else {
+						// TODO: depends on nillable, which should be checked before calling this method
+						$xml = "<$name$elementNS xsi:nil=\"true\" xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\"/>";
+					}
+					$this->debug("in serializeType: returning: $xml");
+					return $xml;
+				}
+				if ($uqType == 'Array') {
+					// JBoss/Axis does this sometimes
+					return $this->serialize_val($value, $name, false, false, false, false, $use);
+				}
+		    	if ($uqType == 'boolean') {
+		    		if ((is_string($value) && $value == 'false') || (! $value)) {
+						$value = 'false';
+					} else {
+						$value = 'true';
+					}
+				} 
+				if ($uqType == 'string' && gettype($value) == 'string') {
+					$value = $this->expandEntities($value);
+				}
+				if (($uqType == 'long' || $uqType == 'unsignedLong') && gettype($value) == 'double') {
+					$value = sprintf("%.0lf", $value);
+				}
+				// it's a scalar
+				// TODO: what about null/nil values?
+				// check type isn't a custom type extending xmlschema namespace
+				if (!$this->getTypeDef($uqType, $ns)) {
+					if ($use == 'literal') {
+						if ($forceType) {
+							$xml = "<$name$elementNS xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\">$value</$name>";
+						} else {
+							$xml = "<$name$elementNS>$value</$name>";
+						}
+					} else {
+						$xml = "<$name$elementNS xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\"$encodingStyle>$value</$name>";
+					}
+					$this->debug("in serializeType: returning: $xml");
+					return $xml;
+				}
+				$this->debug('custom type extends XML Schema or SOAP Encoding namespace (yuck)');
+			} else if ($ns == 'http://xml.apache.org/xml-soap') {
+				$this->debug('in serializeType: appears to be Apache SOAP type');
+				if ($uqType == 'Map') {
+					$tt_prefix = $this->getPrefixFromNamespace('http://xml.apache.org/xml-soap');
+					if (! $tt_prefix) {
+						$this->debug('in serializeType: Add namespace for Apache SOAP type');
+						$tt_prefix = 'ns' . rand(1000, 9999);
+						$this->namespaces[$tt_prefix] = 'http://xml.apache.org/xml-soap';
+						// force this to be added to usedNamespaces
+						$tt_prefix = $this->getPrefixFromNamespace('http://xml.apache.org/xml-soap');
+					}
+					$contents = '';
+					foreach($value as $k => $v) {
+						$this->debug("serializing map element: key $k, value $v");
+						$contents .= '<item>';
+						$contents .= $this->serialize_val($k,'key',false,false,false,false,$use);
+						$contents .= $this->serialize_val($v,'value',false,false,false,false,$use);
+						$contents .= '</item>';
+					}
+					if ($use == 'literal') {
+						if ($forceType) {
+							$xml = "<$name xsi:type=\"" . $tt_prefix . ":$uqType\">$contents</$name>";
+						} else {
+							$xml = "<$name>$contents</$name>";
+						}
+					} else {
+						$xml = "<$name xsi:type=\"" . $tt_prefix . ":$uqType\"$encodingStyle>$contents</$name>";
+					}
+					$this->debug("in serializeType: returning: $xml");
+					return $xml;
+				}
+				$this->debug('in serializeType: Apache SOAP type, but only support Map');
+			}
+		} else {
+			// TODO: should the type be compared to types in XSD, and the namespace
+			// set to XSD if the type matches?
+			$this->debug("in serializeType: No namespace for type $type");
+			$ns = '';
+			$uqType = $type;
+		}
+		if(!$typeDef = $this->getTypeDef($uqType, $ns)){
+			$this->setError("$type ($uqType) is not a supported type.");
+			$this->debug("in serializeType: $type ($uqType) is not a supported type.");
+			return false;
+		} else {
+			$this->debug("in serializeType: found typeDef");
+			$this->appendDebug('typeDef=' . $this->varDump($typeDef));
+			if (substr($uqType, -1) == '^') {
+				$uqType = substr($uqType, 0, -1);
+			}
+		}
+		if (!isset($typeDef['phpType'])) {
+			$this->setError("$type ($uqType) has no phpType.");
+			$this->debug("in serializeType: $type ($uqType) has no phpType.");
+			return false;
+		}
+		$phpType = $typeDef['phpType'];
+		$this->debug("in serializeType: uqType: $uqType, ns: $ns, phptype: $phpType, arrayType: " . (isset($typeDef['arrayType']) ? $typeDef['arrayType'] : '') ); 
+		// if php type == struct, map value to the <all> element names
+		if ($phpType == 'struct') {
+			if (isset($typeDef['typeClass']) && $typeDef['typeClass'] == 'element') {
+				$elementName = $uqType;
+				if (isset($typeDef['form']) && ($typeDef['form'] == 'qualified')) {
+					$elementNS = " xmlns=\"$ns\"";
+				} else {
+					$elementNS = " xmlns=\"\"";
+				}
+			} else {
+				$elementName = $name;
+				if ($unqualified) {
+					$elementNS = " xmlns=\"\"";
+				} else {
+					$elementNS = '';
+				}
+			}
+			if (is_null($value)) {
+				if ($use == 'literal') {
+					// TODO: depends on minOccurs and nillable
+					$xml = "<$elementName$elementNS/>";
+				} else {
+					$xml = "<$elementName$elementNS xsi:nil=\"true\" xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\"/>";
+				}
+				$this->debug("in serializeType: returning: $xml");
+				return $xml;
+			}
+			if (is_object($value)) {
+				$value = get_object_vars($value);
+			}
+			if (is_array($value)) {
+				$elementAttrs = $this->serializeComplexTypeAttributes($typeDef, $value, $ns, $uqType);
+				if ($use == 'literal') {
+					if ($forceType) {
+						$xml = "<$elementName$elementNS$elementAttrs xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\">";
+					} else {
+						$xml = "<$elementName$elementNS$elementAttrs>";
+					}
+				} else {
+					$xml = "<$elementName$elementNS$elementAttrs xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\"$encodingStyle>";
+				}
+
+				if (isset($typeDef['simpleContent']) && $typeDef['simpleContent'] == 'true') {
+					if (isset($value['!'])) {
+						$xml .= $value['!'];
+						$this->debug("in serializeType: serialized simpleContent for type $type");
+					} else {
+						$this->debug("in serializeType: no simpleContent to serialize for type $type");
+					}
+				} else {
+					// complexContent
+					$xml .= $this->serializeComplexTypeElements($typeDef, $value, $ns, $uqType, $use, $encodingStyle);
+				}
+				$xml .= "</$elementName>";
+			} else {
+				$this->debug("in serializeType: phpType is struct, but value is not an array");
+				$this->setError("phpType is struct, but value is not an array: see debug output for details");
+				$xml = '';
+			}
+		} elseif ($phpType == 'array') {
+			if (isset($typeDef['form']) && ($typeDef['form'] == 'qualified')) {
+				$elementNS = " xmlns=\"$ns\"";
+			} else {
+				if ($unqualified) {
+					$elementNS = " xmlns=\"\"";
+				} else {
+					$elementNS = '';
+				}
+			}
+			if (is_null($value)) {
+				if ($use == 'literal') {
+					// TODO: depends on minOccurs
+					$xml = "<$name$elementNS/>";
+				} else {
+					$xml = "<$name$elementNS xsi:nil=\"true\" xsi:type=\"" .
+						$this->getPrefixFromNamespace('http://schemas.xmlsoap.org/soap/encoding/') .
+						":Array\" " .
+						$this->getPrefixFromNamespace('http://schemas.xmlsoap.org/soap/encoding/') .
+						':arrayType="' .
+						$this->getPrefixFromNamespace($this->getPrefix($typeDef['arrayType'])) .
+						':' .
+						$this->getLocalPart($typeDef['arrayType'])."[0]\"/>";
+				}
+				$this->debug("in serializeType: returning: $xml");
+				return $xml;
+			}
+			if (isset($typeDef['multidimensional'])) {
+				$nv = array();
+				foreach($value as $v) {
+					$cols = ',' . sizeof($v);
+					$nv = array_merge($nv, $v);
+				} 
+				$value = $nv;
+			} else {
+				$cols = '';
+			} 
+			if (is_array($value) && sizeof($value) >= 1) {
+				$rows = sizeof($value);
+				$contents = '';
+				foreach($value as $k => $v) {
+					$this->debug("serializing array element: $k, $v of type: $typeDef[arrayType]");
+					//if (strpos($typeDef['arrayType'], ':') ) {
+					if (!in_array($typeDef['arrayType'],$this->typemap['http://www.w3.org/2001/XMLSchema'])) {
+					    $contents .= $this->serializeType('item', $typeDef['arrayType'], $v, $use);
+					} else {
+					    $contents .= $this->serialize_val($v, 'item', $typeDef['arrayType'], null, $this->XMLSchemaVersion, false, $use);
+					} 
+				}
+			} else {
+				$rows = 0;
+				$contents = null;
+			}
+			// TODO: for now, an empty value will be serialized as a zero element
+			// array.  Revisit this when coding the handling of null/nil values.
+			if ($use == 'literal') {
+				$xml = "<$name$elementNS>"
+					.$contents
+					."</$name>";
+			} else {
+				$xml = "<$name$elementNS xsi:type=\"".$this->getPrefixFromNamespace('http://schemas.xmlsoap.org/soap/encoding/').':Array" '.
+					$this->getPrefixFromNamespace('http://schemas.xmlsoap.org/soap/encoding/')
+					.':arrayType="'
+					.$this->getPrefixFromNamespace($this->getPrefix($typeDef['arrayType']))
+					.":".$this->getLocalPart($typeDef['arrayType'])."[$rows$cols]\">"
+					.$contents
+					."</$name>";
+			}
+		} elseif ($phpType == 'scalar') {
+			if (isset($typeDef['form']) && ($typeDef['form'] == 'qualified')) {
+				$elementNS = " xmlns=\"$ns\"";
+			} else {
+				if ($unqualified) {
+					$elementNS = " xmlns=\"\"";
+				} else {
+					$elementNS = '';
+				}
+			}
+			if ($use == 'literal') {
+				if ($forceType) {
+					$xml = "<$name$elementNS xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\">$value</$name>";
+				} else {
+					$xml = "<$name$elementNS>$value</$name>";
+				}
+			} else {
+				$xml = "<$name$elementNS xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\"$encodingStyle>$value</$name>";
+			}
+		}
+		$this->debug("in serializeType: returning: $xml");
+		return $xml;
+	}
+	
+	/**
+	 * serializes the attributes for a complexType
+	 *
+	 * @param array $typeDef our internal representation of an XML schema type (or element)
+	 * @param mixed $value a native PHP value (parameter value)
+	 * @param string $ns the namespace of the type
+	 * @param string $uqType the local part of the type
+	 * @return string value serialized as an XML string
+	 * @access private
+	 */
+	function serializeComplexTypeAttributes($typeDef, $value, $ns, $uqType) {
+		$this->debug("serializeComplexTypeAttributes for XML Schema type $ns:$uqType");
+		$xml = '';
+		if (isset($typeDef['extensionBase'])) {
+			$nsx = $this->getPrefix($typeDef['extensionBase']);
+			$uqTypex = $this->getLocalPart($typeDef['extensionBase']);
+			if ($this->getNamespaceFromPrefix($nsx)) {
+				$nsx = $this->getNamespaceFromPrefix($nsx);
+			}
+			if ($typeDefx = $this->getTypeDef($uqTypex, $nsx)) {
+				$this->debug("serialize attributes for extension base $nsx:$uqTypex");
+				$xml .= $this->serializeComplexTypeAttributes($typeDefx, $value, $nsx, $uqTypex);
+			} else {
+				$this->debug("extension base $nsx:$uqTypex is not a supported type");
+			}
+		}
+		if (isset($typeDef['attrs']) && is_array($typeDef['attrs'])) {
+			$this->debug("serialize attributes for XML Schema type $ns:$uqType");
+			if (is_array($value)) {
+				$xvalue = $value;
+			} elseif (is_object($value)) {
+				$xvalue = get_object_vars($value);
+			} else {
+				$this->debug("value is neither an array nor an object for XML Schema type $ns:$uqType");
+				$xvalue = array();
+			}
+			foreach ($typeDef['attrs'] as $aName => $attrs) {
+				if (isset($xvalue['!' . $aName])) {
+					$xname = '!' . $aName;
+					$this->debug("value provided for attribute $aName with key $xname");
+				} elseif (isset($xvalue[$aName])) {
+					$xname = $aName;
+					$this->debug("value provided for attribute $aName with key $xname");
+				} elseif (isset($attrs['default'])) {
+					$xname = '!' . $aName;
+					$xvalue[$xname] = $attrs['default'];
+					$this->debug('use default value of ' . $xvalue[$aName] . ' for attribute ' . $aName);
+				} else {
+					$xname = '';
+					$this->debug("no value provided for attribute $aName");
+				}
+				if ($xname) {
+					$xml .=  " $aName=\"" . $this->expandEntities($xvalue[$xname]) . "\"";
+				}
+			} 
+		} else {
+			$this->debug("no attributes to serialize for XML Schema type $ns:$uqType");
+		}
+		return $xml;
+	}
+
+	/**
+	 * serializes the elements for a complexType
+	 *
+	 * @param array $typeDef our internal representation of an XML schema type (or element)
+	 * @param mixed $value a native PHP value (parameter value)
+	 * @param string $ns the namespace of the type
+	 * @param string $uqType the local part of the type
+	 * @param string $use use for part (encoded|literal)
+	 * @param string $encodingStyle SOAP encoding style for the value (if different than the enclosing style)
+	 * @return string value serialized as an XML string
+	 * @access private
+	 */
+	function serializeComplexTypeElements($typeDef, $value, $ns, $uqType, $use='encoded', $encodingStyle=false) {
+		$this->debug("in serializeComplexTypeElements for XML Schema type $ns:$uqType");
+		$xml = '';
+		if (isset($typeDef['extensionBase'])) {
+			$nsx = $this->getPrefix($typeDef['extensionBase']);
+			$uqTypex = $this->getLocalPart($typeDef['extensionBase']);
+			if ($this->getNamespaceFromPrefix($nsx)) {
+				$nsx = $this->getNamespaceFromPrefix($nsx);
+			}
+			if ($typeDefx = $this->getTypeDef($uqTypex, $nsx)) {
+				$this->debug("serialize elements for extension base $nsx:$uqTypex");
+				$xml .= $this->serializeComplexTypeElements($typeDefx, $value, $nsx, $uqTypex, $use, $encodingStyle);
+			} else {
+				$this->debug("extension base $nsx:$uqTypex is not a supported type");
+			}
+		}
+		if (isset($typeDef['elements']) && is_array($typeDef['elements'])) {
+			$this->debug("in serializeComplexTypeElements, serialize elements for XML Schema type $ns:$uqType");
+			if (is_array($value)) {
+				$xvalue = $value;
+			} elseif (is_object($value)) {
+				$xvalue = get_object_vars($value);
+			} else {
+				$this->debug("value is neither an array nor an object for XML Schema type $ns:$uqType");
+				$xvalue = array();
+			}
+			// toggle whether all elements are present - ideally should validate against schema
+			if (count($typeDef['elements']) != count($xvalue)){
+				$optionals = true;
+			}
+			foreach ($typeDef['elements'] as $eName => $attrs) {
+				if (!isset($xvalue[$eName])) {
+					if (isset($attrs['default'])) {
+						$xvalue[$eName] = $attrs['default'];
+						$this->debug('use default value of ' . $xvalue[$eName] . ' for element ' . $eName);
+					}
+				}
+				// if user took advantage of a minOccurs=0, then only serialize named parameters
+				if (isset($optionals)
+				    && (!isset($xvalue[$eName])) 
+					&& ( (!isset($attrs['nillable'])) || $attrs['nillable'] != 'true')
+					){
+					if (isset($attrs['minOccurs']) && $attrs['minOccurs'] <> '0') {
+						$this->debug("apparent error: no value provided for element $eName with minOccurs=" . $attrs['minOccurs']);
+					}
+					// do nothing
+					$this->debug("no value provided for complexType element $eName and element is not nillable, so serialize nothing");
+				} else {
+					// get value
+					if (isset($xvalue[$eName])) {
+					    $v = $xvalue[$eName];
+					} else {
+					    $v = null;
+					}
+					if (isset($attrs['form'])) {
+						$unqualified = ($attrs['form'] == 'unqualified');
+					} else {
+						$unqualified = false;
+					}
+					if (isset($attrs['maxOccurs']) && ($attrs['maxOccurs'] == 'unbounded' || $attrs['maxOccurs'] > 1) && isset($v) && is_array($v) && $this->isArraySimpleOrStruct($v) == 'arraySimple') {
+						$vv = $v;
+						foreach ($vv as $k => $v) {
+							if (isset($attrs['type']) || isset($attrs['ref'])) {
+								// serialize schema-defined type
+							    $xml .= $this->serializeType($eName, isset($attrs['type']) ? $attrs['type'] : $attrs['ref'], $v, $use, $encodingStyle, $unqualified);
+							} else {
+								// serialize generic type (can this ever really happen?)
+							    $this->debug("calling serialize_val() for $v, $eName, false, false, false, false, $use");
+							    $xml .= $this->serialize_val($v, $eName, false, false, false, false, $use);
+							}
+						}
+					} else {
+						if (is_null($v) && isset($attrs['minOccurs']) && $attrs['minOccurs'] == '0') {
+							// do nothing
+						} elseif (is_null($v) && isset($attrs['nillable']) && $attrs['nillable'] == 'true') {
+							// TODO: serialize a nil correctly, but for now serialize schema-defined type
+						    $xml .= $this->serializeType($eName, isset($attrs['type']) ? $attrs['type'] : $attrs['ref'], $v, $use, $encodingStyle, $unqualified);
+						} elseif (isset($attrs['type']) || isset($attrs['ref'])) {
+							// serialize schema-defined type
+						    $xml .= $this->serializeType($eName, isset($attrs['type']) ? $attrs['type'] : $attrs['ref'], $v, $use, $encodingStyle, $unqualified);
+						} else {
+							// serialize generic type (can this ever really happen?)
+						    $this->debug("calling serialize_val() for $v, $eName, false, false, false, false, $use");
+						    $xml .= $this->serialize_val($v, $eName, false, false, false, false, $use);
+						}
+					}
+				}
+			} 
+		} else {
+			$this->debug("no elements to serialize for XML Schema type $ns:$uqType");
+		}
+		return $xml;
+	}
+
+	/**
+	* adds an XML Schema complex type to the WSDL types
+	*
+	* @param string	$name
+	* @param string $typeClass (complexType|simpleType|attribute)
+	* @param string $phpType currently supported are array and struct (php assoc array)
+	* @param string $compositor (all|sequence|choice)
+	* @param string $restrictionBase namespace:name (http://schemas.xmlsoap.org/soap/encoding/:Array)
+	* @param array $elements e.g. array ( name => array(name=>'',type=>'') )
+	* @param array $attrs e.g. array(array('ref'=>'SOAP-ENC:arrayType','wsdl:arrayType'=>'xsd:string[]'))
+	* @param string $arrayType as namespace:name (xsd:string)
+	* @see nusoap_xmlschema
+	* @access public
+	*/
+	function addComplexType($name,$typeClass='complexType',$phpType='array',$compositor='',$restrictionBase='',$elements=array(),$attrs=array(),$arrayType='') {
+		if (count($elements) > 0) {
+			$eElements = array();
+	    	foreach($elements as $n => $e){
+	            // expand each element
+	            $ee = array();
+	            foreach ($e as $k => $v) {
+		            $k = strpos($k,':') ? $this->expandQname($k) : $k;
+		            $v = strpos($v,':') ? $this->expandQname($v) : $v;
+		            $ee[$k] = $v;
+		    	}
+	    		$eElements[$n] = $ee;
+	    	}
+	    	$elements = $eElements;
+		}
+		
+		if (count($attrs) > 0) {
+	    	foreach($attrs as $n => $a){
+	            // expand each attribute
+	            foreach ($a as $k => $v) {
+		            $k = strpos($k,':') ? $this->expandQname($k) : $k;
+		            $v = strpos($v,':') ? $this->expandQname($v) : $v;
+		            $aa[$k] = $v;
+		    	}
+	    		$eAttrs[$n] = $aa;
+	    	}
+	    	$attrs = $eAttrs;
+		}
+
+		$restrictionBase = strpos($restrictionBase,':') ? $this->expandQname($restrictionBase) : $restrictionBase;
+		$arrayType = strpos($arrayType,':') ? $this->expandQname($arrayType) : $arrayType;
+
+		$typens = isset($this->namespaces['types']) ? $this->namespaces['types'] : $this->namespaces['tns'];
+		$this->schemas[$typens][0]->addComplexType($name,$typeClass,$phpType,$compositor,$restrictionBase,$elements,$attrs,$arrayType);
+	}
+
+	/**
+	* adds an XML Schema simple type to the WSDL types
+	*
+	* @param string $name
+	* @param string $restrictionBase namespace:name (http://schemas.xmlsoap.org/soap/encoding/:Array)
+	* @param string $typeClass (should always be simpleType)
+	* @param string $phpType (should always be scalar)
+	* @param array $enumeration array of values
+	* @see nusoap_xmlschema
+	* @access public
+	*/
+	function addSimpleType($name, $restrictionBase='', $typeClass='simpleType', $phpType='scalar', $enumeration=array()) {
+		$restrictionBase = strpos($restrictionBase,':') ? $this->expandQname($restrictionBase) : $restrictionBase;
+
+		$typens = isset($this->namespaces['types']) ? $this->namespaces['types'] : $this->namespaces['tns'];
+		$this->schemas[$typens][0]->addSimpleType($name, $restrictionBase, $typeClass, $phpType, $enumeration);
+	}
+
+	/**
+	* adds an element to the WSDL types
+	*
+	* @param array $attrs attributes that must include name and type
+	* @see nusoap_xmlschema
+	* @access public
+	*/
+	function addElement($attrs) {
+		$typens = isset($this->namespaces['types']) ? $this->namespaces['types'] : $this->namespaces['tns'];
+		$this->schemas[$typens][0]->addElement($attrs);
+	}
+
+	/**
+	* register an operation with the server
+	* 
+	* @param string $name operation (method) name
+	* @param array $in assoc array of input values: key = param name, value = param type
+	* @param array $out assoc array of output values: key = param name, value = param type
+	* @param string $namespace optional The namespace for the operation
+	* @param string $soapaction optional The soapaction for the operation
+	* @param string $style (rpc|document) optional The style for the operation Note: when 'document' is specified, parameter and return wrappers are created for you automatically
+	* @param string $use (encoded|literal) optional The use for the parameters (cannot mix right now)
+	* @param string $documentation optional The description to include in the WSDL
+	* @param string $encodingStyle optional (usually 'http://schemas.xmlsoap.org/soap/encoding/' for encoded)
+	* @access public 
+	*/
+	function addOperation($name, $in = false, $out = false, $namespace = false, $soapaction = false, $style = 'rpc', $use = 'encoded', $documentation = '', $encodingStyle = ''){
+		if ($use == 'encoded' && $encodingStyle == '') {
+			$encodingStyle = 'http://schemas.xmlsoap.org/soap/encoding/';
+		}
+
+		if ($style == 'document') {
+			$elements = array();
+			foreach ($in as $n => $t) {
+				$elements[$n] = array('name' => $n, 'type' => $t, 'form' => 'unqualified');
+			}
+			$this->addComplexType($name . 'RequestType', 'complexType', 'struct', 'all', '', $elements);
+			$this->addElement(array('name' => $name, 'type' => $name . 'RequestType'));
+			$in = array('parameters' => 'tns:' . $name . '^');
+
+			$elements = array();
+			foreach ($out as $n => $t) {
+				$elements[$n] = array('name' => $n, 'type' => $t, 'form' => 'unqualified');
+			}
+			$this->addComplexType($name . 'ResponseType', 'complexType', 'struct', 'all', '', $elements);
+			$this->addElement(array('name' => $name . 'Response', 'type' => $name . 'ResponseType', 'form' => 'qualified'));
+			$out = array('parameters' => 'tns:' . $name . 'Response' . '^');
+		}
+
+		// get binding
+		$this->bindings[ $this->serviceName . 'Binding' ]['operations'][$name] =
+		array(
+		'name' => $name,
+		'binding' => $this->serviceName . 'Binding',
+		'endpoint' => $this->endpoint,
+		'soapAction' => $soapaction,
+		'style' => $style,
+		'input' => array(
+			'use' => $use,
+			'namespace' => $namespace,
+			'encodingStyle' => $encodingStyle,
+			'message' => $name . 'Request',
+			'parts' => $in),
+		'output' => array(
+			'use' => $use,
+			'namespace' => $namespace,
+			'encodingStyle' => $encodingStyle,
+			'message' => $name . 'Response',
+			'parts' => $out),
+		'namespace' => $namespace,
+		'transport' => 'http://schemas.xmlsoap.org/soap/http',
+		'documentation' => $documentation); 
+		// add portTypes
+		// add messages
+		if($in)
+		{
+			foreach($in as $pName => $pType)
+			{
+				if(strpos($pType,':')) {
+					$pType = $this->getNamespaceFromPrefix($this->getPrefix($pType)).":".$this->getLocalPart($pType);
+				}
+				$this->messages[$name.'Request'][$pName] = $pType;
+			}
+		} else {
+            $this->messages[$name.'Request']= '0';
+        }
+		if($out)
+		{
+			foreach($out as $pName => $pType)
+			{
+				if(strpos($pType,':')) {
+					$pType = $this->getNamespaceFromPrefix($this->getPrefix($pType)).":".$this->getLocalPart($pType);
+				}
+				$this->messages[$name.'Response'][$pName] = $pType;
+			}
+		} else {
+            $this->messages[$name.'Response']= '0';
+        }
+		return true;
+	} 
+}
+
+?>
diff -rNU5 spip-ori/ecrire/nusoap/class.xmlschema.php spip/ecrire/nusoap/class.xmlschema.php
--- spip-ori/ecrire/nusoap/class.xmlschema.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nusoap/class.xmlschema.php	2013-04-05 11:06:41.157923139 +0200
@@ -0,0 +1,973 @@
+<?php
+
+
+
+
+/**
+* parses an XML Schema, allows access to it's data, other utility methods.
+* imperfect, no validation... yet, but quite functional.
+*
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @version  $Id: class.xmlschema.php,v 1.53 2010/04/26 20:15:08 snichol Exp $
+* @access   public
+*/
+class nusoap_xmlschema extends nusoap_base  {
+	
+	// files
+	var $schema = '';
+	var $xml = '';
+	// namespaces
+	var $enclosingNamespaces;
+	// schema info
+	var $schemaInfo = array();
+	var $schemaTargetNamespace = '';
+	// types, elements, attributes defined by the schema
+	var $attributes = array();
+	var $complexTypes = array();
+	var $complexTypeStack = array();
+	var $currentComplexType = null;
+	var $elements = array();
+	var $elementStack = array();
+	var $currentElement = null;
+	var $simpleTypes = array();
+	var $simpleTypeStack = array();
+	var $currentSimpleType = null;
+	// imports
+	var $imports = array();
+	// parser vars
+	var $parser;
+	var $position = 0;
+	var $depth = 0;
+	var $depth_array = array();
+	var $message = array();
+	var $defaultNamespace = array();
+    
+	/**
+	* constructor
+	*
+	* @param    string $schema schema document URI
+	* @param    string $xml xml document URI
+	* @param	string $namespaces namespaces defined in enclosing XML
+	* @access   public
+	*/
+	function nusoap_xmlschema($schema='',$xml='',$namespaces=array()){
+		parent::nusoap_base();
+		$this->debug('nusoap_xmlschema class instantiated, inside constructor');
+		// files
+		$this->schema = $schema;
+		$this->xml = $xml;
+
+		// namespaces
+		$this->enclosingNamespaces = $namespaces;
+		$this->namespaces = array_merge($this->namespaces, $namespaces);
+
+		// parse schema file
+		if($schema != ''){
+			$this->debug('initial schema file: '.$schema);
+			$this->parseFile($schema, 'schema');
+		}
+
+		// parse xml file
+		if($xml != ''){
+			$this->debug('initial xml file: '.$xml);
+			$this->parseFile($xml, 'xml');
+		}
+
+	}
+
+    /**
+    * parse an XML file
+    *
+    * @param string $xml path/URL to XML file
+    * @param string $type (schema | xml)
+	* @return boolean
+    * @access public
+    */
+	function parseFile($xml,$type){
+		// parse xml file
+		if($xml != ""){
+			$xmlStr = @join("",@file($xml));
+			if($xmlStr == ""){
+				$msg = 'Error reading XML from '.$xml;
+				$this->setError($msg);
+				$this->debug($msg);
+			return false;
+			} else {
+				$this->debug("parsing $xml");
+				$this->parseString($xmlStr,$type);
+				$this->debug("done parsing $xml");
+			return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	* parse an XML string
+	*
+	* @param    string $xml path or URL
+    * @param	string $type (schema|xml)
+	* @access   private
+	*/
+	function parseString($xml,$type){
+		// parse xml string
+		if($xml != ""){
+
+	    	// Create an XML parser.
+	    	$this->parser = xml_parser_create();
+	    	// Set the options for parsing the XML data.
+	    	xml_parser_set_option($this->parser, XML_OPTION_CASE_FOLDING, 0);
+
+	    	// Set the object for the parser.
+	    	xml_set_object($this->parser, $this);
+
+	    	// Set the element handlers for the parser.
+			if($type == "schema"){
+		    	xml_set_element_handler($this->parser, 'schemaStartElement','schemaEndElement');
+		    	xml_set_character_data_handler($this->parser,'schemaCharacterData');
+			} elseif($type == "xml"){
+				xml_set_element_handler($this->parser, 'xmlStartElement','xmlEndElement');
+		    	xml_set_character_data_handler($this->parser,'xmlCharacterData');
+			}
+
+		    // Parse the XML file.
+		    if(!xml_parse($this->parser,$xml,true)){
+			// Display an error message.
+				$errstr = sprintf('XML error parsing XML schema on line %d: %s',
+				xml_get_current_line_number($this->parser),
+				xml_error_string(xml_get_error_code($this->parser))
+				);
+				$this->debug($errstr);
+				$this->debug("XML payload:\n" . $xml);
+				$this->setError($errstr);
+	    	}
+            
+			xml_parser_free($this->parser);
+		} else{
+			$this->debug('no xml passed to parseString()!!');
+			$this->setError('no xml passed to parseString()!!');
+		}
+	}
+
+	/**
+	 * gets a type name for an unnamed type
+	 *
+	 * @param	string	Element name
+	 * @return	string	A type name for an unnamed type
+	 * @access	private
+	 */
+	function CreateTypeName($ename) {
+		$scope = '';
+		for ($i = 0; $i < count($this->complexTypeStack); $i++) {
+			$scope .= $this->complexTypeStack[$i] . '_';
+		}
+		return $scope . $ename . '_ContainedType';
+	}
+	
+	/**
+	* start-element handler
+	*
+	* @param    string $parser XML parser object
+	* @param    string $name element name
+	* @param    string $attrs associative array of attributes
+	* @access   private
+	*/
+	function schemaStartElement($parser, $name, $attrs) {
+		
+		// position in the total number of elements, starting from 0
+		$pos = $this->position++;
+		$depth = $this->depth++;
+		// set self as current value for this depth
+		$this->depth_array[$depth] = $pos;
+		$this->message[$pos] = array('cdata' => ''); 
+		if ($depth > 0) {
+			$this->defaultNamespace[$pos] = $this->defaultNamespace[$this->depth_array[$depth - 1]];
+		} else {
+			$this->defaultNamespace[$pos] = false;
+		}
+
+		// get element prefix
+		if($prefix = $this->getPrefix($name)){
+			// get unqualified name
+			$name = $this->getLocalPart($name);
+		} else {
+        	$prefix = '';
+        }
+		
+        // loop thru attributes, expanding, and registering namespace declarations
+        if(count($attrs) > 0){
+        	foreach($attrs as $k => $v){
+                // if ns declarations, add to class level array of valid namespaces
+				if(preg_match('/^xmlns/',$k)){
+                	//$this->xdebug("$k: $v");
+                	//$this->xdebug('ns_prefix: '.$this->getPrefix($k));
+                	if($ns_prefix = substr(strrchr($k,':'),1)){
+                		//$this->xdebug("Add namespace[$ns_prefix] = $v");
+						$this->namespaces[$ns_prefix] = $v;
+					} else {
+						$this->defaultNamespace[$pos] = $v;
+						if (! $this->getPrefixFromNamespace($v)) {
+							$this->namespaces['ns'.(count($this->namespaces)+1)] = $v;
+						}
+					}
+					if($v == 'http://www.w3.org/2001/XMLSchema' || $v == 'http://www.w3.org/1999/XMLSchema' || $v == 'http://www.w3.org/2000/10/XMLSchema'){
+						$this->XMLSchemaVersion = $v;
+						$this->namespaces['xsi'] = $v.'-instance';
+					}
+				}
+        	}
+        	foreach($attrs as $k => $v){
+                // expand each attribute
+                $k = strpos($k,':') ? $this->expandQname($k) : $k;
+                $v = strpos($v,':') ? $this->expandQname($v) : $v;
+        		$eAttrs[$k] = $v;
+        	}
+        	$attrs = $eAttrs;
+        } else {
+        	$attrs = array();
+        }
+		// find status, register data
+		switch($name){
+			case 'all':			// (optional) compositor content for a complexType
+			case 'choice':
+			case 'group':
+			case 'sequence':
+				//$this->xdebug("compositor $name for currentComplexType: $this->currentComplexType and currentElement: $this->currentElement");
+				$this->complexTypes[$this->currentComplexType]['compositor'] = $name;
+				//if($name == 'all' || $name == 'sequence'){
+				//	$this->complexTypes[$this->currentComplexType]['phpType'] = 'struct';
+				//}
+			break;
+			case 'attribute':	// complexType attribute
+            	//$this->xdebug("parsing attribute $attrs[name] $attrs[ref] of value: ".$attrs['http://schemas.xmlsoap.org/wsdl/:arrayType']);
+            	$this->xdebug("parsing attribute:");
+            	$this->appendDebug($this->varDump($attrs));
+				if (!isset($attrs['form'])) {
+					// TODO: handle globals
+					$attrs['form'] = $this->schemaInfo['attributeFormDefault'];
+				}
+            	if (isset($attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'])) {
+					$v = $attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'];
+					if (!strpos($v, ':')) {
+						// no namespace in arrayType attribute value...
+						if ($this->defaultNamespace[$pos]) {
+							// ...so use the default
+							$attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'] = $this->defaultNamespace[$pos] . ':' . $attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'];
+						}
+					}
+            	}
+                if(isset($attrs['name'])){
+					$this->attributes[$attrs['name']] = $attrs;
+					$aname = $attrs['name'];
+				} elseif(isset($attrs['ref']) && $attrs['ref'] == 'http://schemas.xmlsoap.org/soap/encoding/:arrayType'){
+					if (isset($attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'])) {
+	                	$aname = $attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'];
+	                } else {
+	                	$aname = '';
+	                }
+				} elseif(isset($attrs['ref'])){
+					$aname = $attrs['ref'];
+                    $this->attributes[$attrs['ref']] = $attrs;
+				}
+                
+				if($this->currentComplexType){	// This should *always* be
+					$this->complexTypes[$this->currentComplexType]['attrs'][$aname] = $attrs;
+				}
+				// arrayType attribute
+				if(isset($attrs['http://schemas.xmlsoap.org/wsdl/:arrayType']) || $this->getLocalPart($aname) == 'arrayType'){
+					$this->complexTypes[$this->currentComplexType]['phpType'] = 'array';
+                	$prefix = $this->getPrefix($aname);
+					if(isset($attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'])){
+						$v = $attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'];
+					} else {
+						$v = '';
+					}
+                    if(strpos($v,'[,]')){
+                        $this->complexTypes[$this->currentComplexType]['multidimensional'] = true;
+                    }
+                    $v = substr($v,0,strpos($v,'[')); // clip the []
+                    if(!strpos($v,':') && isset($this->typemap[$this->XMLSchemaVersion][$v])){
+                        $v = $this->XMLSchemaVersion.':'.$v;
+                    }
+                    $this->complexTypes[$this->currentComplexType]['arrayType'] = $v;
+				}
+			break;
+			case 'complexContent':	// (optional) content for a complexType
+				$this->xdebug("do nothing for element $name");
+			break;
+			case 'complexType':
+				array_push($this->complexTypeStack, $this->currentComplexType);
+				if(isset($attrs['name'])){
+					// TODO: what is the scope of named complexTypes that appear
+					//       nested within other c complexTypes?
+					$this->xdebug('processing named complexType '.$attrs['name']);
+					//$this->currentElement = false;
+					$this->currentComplexType = $attrs['name'];
+					$this->complexTypes[$this->currentComplexType] = $attrs;
+					$this->complexTypes[$this->currentComplexType]['typeClass'] = 'complexType';
+					// This is for constructs like
+					//           <complexType name="ListOfString" base="soap:Array">
+					//                <sequence>
+					//                    <element name="string" type="xsd:string"
+					//                        minOccurs="0" maxOccurs="unbounded" />
+					//                </sequence>
+					//            </complexType>
+					if(isset($attrs['base']) && preg_match('/:Array$/',$attrs['base'])){
+						$this->xdebug('complexType is unusual array');
+						$this->complexTypes[$this->currentComplexType]['phpType'] = 'array';
+					} else {
+						$this->complexTypes[$this->currentComplexType]['phpType'] = 'struct';
+					}
+				} else {
+					$name = $this->CreateTypeName($this->currentElement);
+					$this->xdebug('processing unnamed complexType for element ' . $this->currentElement . ' named ' . $name);
+					$this->currentComplexType = $name;
+					//$this->currentElement = false;
+					$this->complexTypes[$this->currentComplexType] = $attrs;
+					$this->complexTypes[$this->currentComplexType]['typeClass'] = 'complexType';
+					// This is for constructs like
+					//           <complexType name="ListOfString" base="soap:Array">
+					//                <sequence>
+					//                    <element name="string" type="xsd:string"
+					//                        minOccurs="0" maxOccurs="unbounded" />
+					//                </sequence>
+					//            </complexType>
+					if(isset($attrs['base']) && preg_match('/:Array$/',$attrs['base'])){
+						$this->xdebug('complexType is unusual array');
+						$this->complexTypes[$this->currentComplexType]['phpType'] = 'array';
+					} else {
+						$this->complexTypes[$this->currentComplexType]['phpType'] = 'struct';
+					}
+				}
+				$this->complexTypes[$this->currentComplexType]['simpleContent'] = 'false';
+			break;
+			case 'element':
+				array_push($this->elementStack, $this->currentElement);
+				if (!isset($attrs['form'])) {
+					if ($this->currentComplexType) {
+						$attrs['form'] = $this->schemaInfo['elementFormDefault'];
+					} else {
+						// global
+						$attrs['form'] = 'qualified';
+					}
+				}
+				if(isset($attrs['type'])){
+					$this->xdebug("processing typed element ".$attrs['name']." of type ".$attrs['type']);
+					if (! $this->getPrefix($attrs['type'])) {
+						if ($this->defaultNamespace[$pos]) {
+							$attrs['type'] = $this->defaultNamespace[$pos] . ':' . $attrs['type'];
+							$this->xdebug('used default namespace to make type ' . $attrs['type']);
+						}
+					}
+					// This is for constructs like
+					//           <complexType name="ListOfString" base="soap:Array">
+					//                <sequence>
+					//                    <element name="string" type="xsd:string"
+					//                        minOccurs="0" maxOccurs="unbounded" />
+					//                </sequence>
+					//            </complexType>
+					if ($this->currentComplexType && $this->complexTypes[$this->currentComplexType]['phpType'] == 'array') {
+						$this->xdebug('arrayType for unusual array is ' . $attrs['type']);
+						$this->complexTypes[$this->currentComplexType]['arrayType'] = $attrs['type'];
+					}
+					$this->currentElement = $attrs['name'];
+					$ename = $attrs['name'];
+				} elseif(isset($attrs['ref'])){
+					$this->xdebug("processing element as ref to ".$attrs['ref']);
+					$this->currentElement = "ref to ".$attrs['ref'];
+					$ename = $this->getLocalPart($attrs['ref']);
+				} else {
+					$type = $this->CreateTypeName($this->currentComplexType . '_' . $attrs['name']);
+					$this->xdebug("processing untyped element " . $attrs['name'] . ' type ' . $type);
+					$this->currentElement = $attrs['name'];
+					$attrs['type'] = $this->schemaTargetNamespace . ':' . $type;
+					$ename = $attrs['name'];
+				}
+				if (isset($ename) && $this->currentComplexType) {
+					$this->xdebug("add element $ename to complexType $this->currentComplexType");
+					$this->complexTypes[$this->currentComplexType]['elements'][$ename] = $attrs;
+				} elseif (!isset($attrs['ref'])) {
+					$this->xdebug("add element $ename to elements array");
+					$this->elements[ $attrs['name'] ] = $attrs;
+					$this->elements[ $attrs['name'] ]['typeClass'] = 'element';
+				}
+			break;
+			case 'enumeration':	//	restriction value list member
+				$this->xdebug('enumeration ' . $attrs['value']);
+				if ($this->currentSimpleType) {
+					$this->simpleTypes[$this->currentSimpleType]['enumeration'][] = $attrs['value'];
+				} elseif ($this->currentComplexType) {
+					$this->complexTypes[$this->currentComplexType]['enumeration'][] = $attrs['value'];
+				}
+			break;
+			case 'extension':	// simpleContent or complexContent type extension
+				$this->xdebug('extension ' . $attrs['base']);
+				if ($this->currentComplexType) {
+					$ns = $this->getPrefix($attrs['base']);
+					if ($ns == '') {
+						$this->complexTypes[$this->currentComplexType]['extensionBase'] = $this->schemaTargetNamespace . ':' . $attrs['base'];
+					} else {
+						$this->complexTypes[$this->currentComplexType]['extensionBase'] = $attrs['base'];
+					}
+				} else {
+					$this->xdebug('no current complexType to set extensionBase');
+				}
+			break;
+			case 'import':
+			    if (isset($attrs['schemaLocation'])) {
+					$this->xdebug('import namespace ' . $attrs['namespace'] . ' from ' . $attrs['schemaLocation']);
+                    $this->imports[$attrs['namespace']][] = array('location' => $attrs['schemaLocation'], 'loaded' => false);
+				} else {
+					$this->xdebug('import namespace ' . $attrs['namespace']);
+                    $this->imports[$attrs['namespace']][] = array('location' => '', 'loaded' => true);
+					if (! $this->getPrefixFromNamespace($attrs['namespace'])) {
+						$this->namespaces['ns'.(count($this->namespaces)+1)] = $attrs['namespace'];
+					}
+				}
+			break;
+			case 'include':
+			    if (isset($attrs['schemaLocation'])) {
+					$this->xdebug('include into namespace ' . $this->schemaTargetNamespace . ' from ' . $attrs['schemaLocation']);
+                    $this->imports[$this->schemaTargetNamespace][] = array('location' => $attrs['schemaLocation'], 'loaded' => false);
+				} else {
+					$this->xdebug('ignoring invalid XML Schema construct: include without schemaLocation attribute');
+				}
+			break;
+			case 'list':	// simpleType value list
+				$this->xdebug("do nothing for element $name");
+			break;
+			case 'restriction':	// simpleType, simpleContent or complexContent value restriction
+				$this->xdebug('restriction ' . $attrs['base']);
+				if($this->currentSimpleType){
+					$this->simpleTypes[$this->currentSimpleType]['type'] = $attrs['base'];
+				} elseif($this->currentComplexType){
+					$this->complexTypes[$this->currentComplexType]['restrictionBase'] = $attrs['base'];
+					if(strstr($attrs['base'],':') == ':Array'){
+						$this->complexTypes[$this->currentComplexType]['phpType'] = 'array';
+					}
+				}
+			break;
+			case 'schema':
+				$this->schemaInfo = $attrs;
+				$this->schemaInfo['schemaVersion'] = $this->getNamespaceFromPrefix($prefix);
+				if (isset($attrs['targetNamespace'])) {
+					$this->schemaTargetNamespace = $attrs['targetNamespace'];
+				}
+				if (!isset($attrs['elementFormDefault'])) {
+					$this->schemaInfo['elementFormDefault'] = 'unqualified';
+				}
+				if (!isset($attrs['attributeFormDefault'])) {
+					$this->schemaInfo['attributeFormDefault'] = 'unqualified';
+				}
+			break;
+			case 'simpleContent':	// (optional) content for a complexType
+				if ($this->currentComplexType) {	// This should *always* be
+					$this->complexTypes[$this->currentComplexType]['simpleContent'] = 'true';
+				} else {
+					$this->xdebug("do nothing for element $name because there is no current complexType");
+				}
+			break;
+			case 'simpleType':
+				array_push($this->simpleTypeStack, $this->currentSimpleType);
+				if(isset($attrs['name'])){
+					$this->xdebug("processing simpleType for name " . $attrs['name']);
+					$this->currentSimpleType = $attrs['name'];
+					$this->simpleTypes[ $attrs['name'] ] = $attrs;
+					$this->simpleTypes[ $attrs['name'] ]['typeClass'] = 'simpleType';
+					$this->simpleTypes[ $attrs['name'] ]['phpType'] = 'scalar';
+				} else {
+					$name = $this->CreateTypeName($this->currentComplexType . '_' . $this->currentElement);
+					$this->xdebug('processing unnamed simpleType for element ' . $this->currentElement . ' named ' . $name);
+					$this->currentSimpleType = $name;
+					//$this->currentElement = false;
+					$this->simpleTypes[$this->currentSimpleType] = $attrs;
+					$this->simpleTypes[$this->currentSimpleType]['phpType'] = 'scalar';
+				}
+			break;
+			case 'union':	// simpleType type list
+				$this->xdebug("do nothing for element $name");
+			break;
+			default:
+				$this->xdebug("do not have any logic to process element $name");
+		}
+	}
+
+	/**
+	* end-element handler
+	*
+	* @param    string $parser XML parser object
+	* @param    string $name element name
+	* @access   private
+	*/
+	function schemaEndElement($parser, $name) {
+		// bring depth down a notch
+		$this->depth--;
+		// position of current element is equal to the last value left in depth_array for my depth
+		if(isset($this->depth_array[$this->depth])){
+        	$pos = $this->depth_array[$this->depth];
+        }
+		// get element prefix
+		if ($prefix = $this->getPrefix($name)){
+			// get unqualified name
+			$name = $this->getLocalPart($name);
+		} else {
+        	$prefix = '';
+        }
+		// move on...
+		if($name == 'complexType'){
+			$this->xdebug('done processing complexType ' . ($this->currentComplexType ? $this->currentComplexType : '(unknown)'));
+			$this->xdebug($this->varDump($this->complexTypes[$this->currentComplexType]));
+			$this->currentComplexType = array_pop($this->complexTypeStack);
+			//$this->currentElement = false;
+		}
+		if($name == 'element'){
+			$this->xdebug('done processing element ' . ($this->currentElement ? $this->currentElement : '(unknown)'));
+			$this->currentElement = array_pop($this->elementStack);
+		}
+		if($name == 'simpleType'){
+			$this->xdebug('done processing simpleType ' . ($this->currentSimpleType ? $this->currentSimpleType : '(unknown)'));
+			$this->xdebug($this->varDump($this->simpleTypes[$this->currentSimpleType]));
+			$this->currentSimpleType = array_pop($this->simpleTypeStack);
+		}
+	}
+
+	/**
+	* element content handler
+	*
+	* @param    string $parser XML parser object
+	* @param    string $data element content
+	* @access   private
+	*/
+	function schemaCharacterData($parser, $data){
+		$pos = $this->depth_array[$this->depth - 1];
+		$this->message[$pos]['cdata'] .= $data;
+	}
+
+	/**
+	* serialize the schema
+	*
+	* @access   public
+	*/
+	function serializeSchema(){
+
+		$schemaPrefix = $this->getPrefixFromNamespace($this->XMLSchemaVersion);
+		$xml = '';
+		// imports
+		if (sizeof($this->imports) > 0) {
+			foreach($this->imports as $ns => $list) {
+				foreach ($list as $ii) {
+					if ($ii['location'] != '') {
+						$xml .= " <$schemaPrefix:import location=\"" . $ii['location'] . '" namespace="' . $ns . "\" />\n";
+					} else {
+						$xml .= " <$schemaPrefix:import namespace=\"" . $ns . "\" />\n";
+					}
+				}
+			} 
+		} 
+		// complex types
+		foreach($this->complexTypes as $typeName => $attrs){
+			$contentStr = '';
+			// serialize child elements
+			if(isset($attrs['elements']) && (count($attrs['elements']) > 0)){
+				foreach($attrs['elements'] as $element => $eParts){
+					if(isset($eParts['ref'])){
+						$contentStr .= "   <$schemaPrefix:element ref=\"$element\"/>\n";
+					} else {
+						$contentStr .= "   <$schemaPrefix:element name=\"$element\" type=\"" . $this->contractQName($eParts['type']) . "\"";
+						foreach ($eParts as $aName => $aValue) {
+							// handle, e.g., abstract, default, form, minOccurs, maxOccurs, nillable
+							if ($aName != 'name' && $aName != 'type') {
+								$contentStr .= " $aName=\"$aValue\"";
+							}
+						}
+						$contentStr .= "/>\n";
+					}
+				}
+				// compositor wraps elements
+				if (isset($attrs['compositor']) && ($attrs['compositor'] != '')) {
+					$contentStr = "  <$schemaPrefix:$attrs[compositor]>\n".$contentStr."  </$schemaPrefix:$attrs[compositor]>\n";
+				}
+			}
+			// attributes
+			if(isset($attrs['attrs']) && (count($attrs['attrs']) >= 1)){
+				foreach($attrs['attrs'] as $attr => $aParts){
+					$contentStr .= "    <$schemaPrefix:attribute";
+					foreach ($aParts as $a => $v) {
+						if ($a == 'ref' || $a == 'type') {
+							$contentStr .= " $a=\"".$this->contractQName($v).'"';
+						} elseif ($a == 'http://schemas.xmlsoap.org/wsdl/:arrayType') {
+							$this->usedNamespaces['wsdl'] = $this->namespaces['wsdl'];
+							$contentStr .= ' wsdl:arrayType="'.$this->contractQName($v).'"';
+						} else {
+							$contentStr .= " $a=\"$v\"";
+						}
+					}
+					$contentStr .= "/>\n";
+				}
+			}
+			// if restriction
+			if (isset($attrs['restrictionBase']) && $attrs['restrictionBase'] != ''){
+				$contentStr = "   <$schemaPrefix:restriction base=\"".$this->contractQName($attrs['restrictionBase'])."\">\n".$contentStr."   </$schemaPrefix:restriction>\n";
+				// complex or simple content
+				if ((isset($attrs['elements']) && count($attrs['elements']) > 0) || (isset($attrs['attrs']) && count($attrs['attrs']) > 0)){
+					$contentStr = "  <$schemaPrefix:complexContent>\n".$contentStr."  </$schemaPrefix:complexContent>\n";
+				}
+			}
+			// finalize complex type
+			if($contentStr != ''){
+				$contentStr = " <$schemaPrefix:complexType name=\"$typeName\">\n".$contentStr." </$schemaPrefix:complexType>\n";
+			} else {
+				$contentStr = " <$schemaPrefix:complexType name=\"$typeName\"/>\n";
+			}
+			$xml .= $contentStr;
+		}
+		// simple types
+		if(isset($this->simpleTypes) && count($this->simpleTypes) > 0){
+			foreach($this->simpleTypes as $typeName => $eParts){
+				$xml .= " <$schemaPrefix:simpleType name=\"$typeName\">\n  <$schemaPrefix:restriction base=\"".$this->contractQName($eParts['type'])."\">\n";
+				if (isset($eParts['enumeration'])) {
+					foreach ($eParts['enumeration'] as $e) {
+						$xml .= "  <$schemaPrefix:enumeration value=\"$e\"/>\n";
+					}
+				}
+				$xml .= "  </$schemaPrefix:restriction>\n </$schemaPrefix:simpleType>";
+			}
+		}
+		// elements
+		if(isset($this->elements) && count($this->elements) > 0){
+			foreach($this->elements as $element => $eParts){
+				$xml .= " <$schemaPrefix:element name=\"$element\" type=\"".$this->contractQName($eParts['type'])."\"/>\n";
+			}
+		}
+		// attributes
+		if(isset($this->attributes) && count($this->attributes) > 0){
+			foreach($this->attributes as $attr => $aParts){
+				$xml .= " <$schemaPrefix:attribute name=\"$attr\" type=\"".$this->contractQName($aParts['type'])."\"\n/>";
+			}
+		}
+		// finish 'er up
+		$attr = '';
+		foreach ($this->schemaInfo as $k => $v) {
+			if ($k == 'elementFormDefault' || $k == 'attributeFormDefault') {
+				$attr .= " $k=\"$v\"";
+			}
+		}
+		$el = "<$schemaPrefix:schema$attr targetNamespace=\"$this->schemaTargetNamespace\"\n";
+		foreach (array_diff($this->usedNamespaces, $this->enclosingNamespaces) as $nsp => $ns) {
+			$el .= " xmlns:$nsp=\"$ns\"";
+		}
+		$xml = $el . ">\n".$xml."</$schemaPrefix:schema>\n";
+		return $xml;
+	}
+
+	/**
+	* adds debug data to the clas level debug string
+	*
+	* @param    string $string debug data
+	* @access   private
+	*/
+	function xdebug($string){
+		$this->debug('<' . $this->schemaTargetNamespace . '> '.$string);
+	}
+
+    /**
+    * get the PHP type of a user defined type in the schema
+    * PHP type is kind of a misnomer since it actually returns 'struct' for assoc. arrays
+    * returns false if no type exists, or not w/ the given namespace
+    * else returns a string that is either a native php type, or 'struct'
+    *
+    * @param string $type name of defined type
+    * @param string $ns namespace of type
+    * @return mixed
+    * @access public
+    * @deprecated
+    */
+	function getPHPType($type,$ns){
+		if(isset($this->typemap[$ns][$type])){
+			//print "found type '$type' and ns $ns in typemap<br>";
+			return $this->typemap[$ns][$type];
+		} elseif(isset($this->complexTypes[$type])){
+			//print "getting type '$type' and ns $ns from complexTypes array<br>";
+			return $this->complexTypes[$type]['phpType'];
+		}
+		return false;
+	}
+
+	/**
+    * returns an associative array of information about a given type
+    * returns false if no type exists by the given name
+    *
+	*	For a complexType typeDef = array(
+	*	'restrictionBase' => '',
+	*	'phpType' => '',
+	*	'compositor' => '(sequence|all)',
+	*	'elements' => array(), // refs to elements array
+	*	'attrs' => array() // refs to attributes array
+	*	... and so on (see addComplexType)
+	*	)
+	*
+	*   For simpleType or element, the array has different keys.
+    *
+    * @param string $type
+    * @return mixed
+    * @access public
+    * @see addComplexType
+    * @see addSimpleType
+    * @see addElement
+    */
+	function getTypeDef($type){
+		//$this->debug("in getTypeDef for type $type");
+		if (substr($type, -1) == '^') {
+			$is_element = 1;
+			$type = substr($type, 0, -1);
+		} else {
+			$is_element = 0;
+		}
+
+		if((! $is_element) && isset($this->complexTypes[$type])){
+			$this->xdebug("in getTypeDef, found complexType $type");
+			return $this->complexTypes[$type];
+		} elseif((! $is_element) && isset($this->simpleTypes[$type])){
+			$this->xdebug("in getTypeDef, found simpleType $type");
+			if (!isset($this->simpleTypes[$type]['phpType'])) {
+				// get info for type to tack onto the simple type
+				// TODO: can this ever really apply (i.e. what is a simpleType really?)
+				$uqType = substr($this->simpleTypes[$type]['type'], strrpos($this->simpleTypes[$type]['type'], ':') + 1);
+				$ns = substr($this->simpleTypes[$type]['type'], 0, strrpos($this->simpleTypes[$type]['type'], ':'));
+				$etype = $this->getTypeDef($uqType);
+				if ($etype) {
+					$this->xdebug("in getTypeDef, found type for simpleType $type:");
+					$this->xdebug($this->varDump($etype));
+					if (isset($etype['phpType'])) {
+						$this->simpleTypes[$type]['phpType'] = $etype['phpType'];
+					}
+					if (isset($etype['elements'])) {
+						$this->simpleTypes[$type]['elements'] = $etype['elements'];
+					}
+				}
+			}
+			return $this->simpleTypes[$type];
+		} elseif(isset($this->elements[$type])){
+			$this->xdebug("in getTypeDef, found element $type");
+			if (!isset($this->elements[$type]['phpType'])) {
+				// get info for type to tack onto the element
+				$uqType = substr($this->elements[$type]['type'], strrpos($this->elements[$type]['type'], ':') + 1);
+				$ns = substr($this->elements[$type]['type'], 0, strrpos($this->elements[$type]['type'], ':'));
+				$etype = $this->getTypeDef($uqType);
+				if ($etype) {
+					$this->xdebug("in getTypeDef, found type for element $type:");
+					$this->xdebug($this->varDump($etype));
+					if (isset($etype['phpType'])) {
+						$this->elements[$type]['phpType'] = $etype['phpType'];
+					}
+					if (isset($etype['elements'])) {
+						$this->elements[$type]['elements'] = $etype['elements'];
+					}
+					if (isset($etype['extensionBase'])) {
+						$this->elements[$type]['extensionBase'] = $etype['extensionBase'];
+					}
+				} elseif ($ns == 'http://www.w3.org/2001/XMLSchema') {
+					$this->xdebug("in getTypeDef, element $type is an XSD type");
+					$this->elements[$type]['phpType'] = 'scalar';
+				}
+			}
+			return $this->elements[$type];
+		} elseif(isset($this->attributes[$type])){
+			$this->xdebug("in getTypeDef, found attribute $type");
+			return $this->attributes[$type];
+		} elseif (preg_match('/_ContainedType$/', $type)) {
+			$this->xdebug("in getTypeDef, have an untyped element $type");
+			$typeDef['typeClass'] = 'simpleType';
+			$typeDef['phpType'] = 'scalar';
+			$typeDef['type'] = 'http://www.w3.org/2001/XMLSchema:string';
+			return $typeDef;
+		}
+		$this->xdebug("in getTypeDef, did not find $type");
+		return false;
+	}
+
+	/**
+    * returns a sample serialization of a given type, or false if no type by the given name
+    *
+    * @param string $type name of type
+    * @return mixed
+    * @access public
+    * @deprecated
+    */
+    function serializeTypeDef($type){
+    	//print "in sTD() for type $type<br>";
+	if($typeDef = $this->getTypeDef($type)){
+		$str .= '<'.$type;
+	    if(is_array($typeDef['attrs'])){
+		foreach($typeDef['attrs'] as $attName => $data){
+		    $str .= " $attName=\"{type = ".$data['type']."}\"";
+		}
+	    }
+	    $str .= " xmlns=\"".$this->schema['targetNamespace']."\"";
+	    if(count($typeDef['elements']) > 0){
+		$str .= ">";
+		foreach($typeDef['elements'] as $element => $eData){
+		    $str .= $this->serializeTypeDef($element);
+		}
+		$str .= "</$type>";
+	    } elseif($typeDef['typeClass'] == 'element') {
+		$str .= "></$type>";
+	    } else {
+		$str .= "/>";
+	    }
+			return $str;
+	}
+    	return false;
+    }
+
+    /**
+    * returns HTML form elements that allow a user
+    * to enter values for creating an instance of the given type.
+    *
+    * @param string $name name for type instance
+    * @param string $type name of type
+    * @return string
+    * @access public
+    * @deprecated
+	*/
+	function typeToForm($name,$type){
+		// get typedef
+		if($typeDef = $this->getTypeDef($type)){
+			// if struct
+			if($typeDef['phpType'] == 'struct'){
+				$buffer .= '<table>';
+				foreach($typeDef['elements'] as $child => $childDef){
+					$buffer .= "
+					<tr><td align='right'>$childDef[name] (type: ".$this->getLocalPart($childDef['type'])."):</td>
+					<td><input type='text' name='parameters[".$name."][$childDef[name]]'></td></tr>";
+				}
+				$buffer .= '</table>';
+			// if array
+			} elseif($typeDef['phpType'] == 'array'){
+				$buffer .= '<table>';
+				for($i=0;$i < 3; $i++){
+					$buffer .= "
+					<tr><td align='right'>array item (type: $typeDef[arrayType]):</td>
+					<td><input type='text' name='parameters[".$name."][]'></td></tr>";
+				}
+				$buffer .= '</table>';
+			// if scalar
+			} else {
+				$buffer .= "<input type='text' name='parameters[$name]'>";
+			}
+		} else {
+			$buffer .= "<input type='text' name='parameters[$name]'>";
+		}
+		return $buffer;
+	}
+	
+	/**
+	* adds a complex type to the schema
+	* 
+	* example: array
+	* 
+	* addType(
+	* 	'ArrayOfstring',
+	* 	'complexType',
+	* 	'array',
+	* 	'',
+	* 	'SOAP-ENC:Array',
+	* 	array('ref'=>'SOAP-ENC:arrayType','wsdl:arrayType'=>'string[]'),
+	* 	'xsd:string'
+	* );
+	* 
+	* example: PHP associative array ( SOAP Struct )
+	* 
+	* addType(
+	* 	'SOAPStruct',
+	* 	'complexType',
+	* 	'struct',
+	* 	'all',
+	* 	array('myVar'=> array('name'=>'myVar','type'=>'string')
+	* );
+	* 
+	* @param name
+	* @param typeClass (complexType|simpleType|attribute)
+	* @param phpType: currently supported are array and struct (php assoc array)
+	* @param compositor (all|sequence|choice)
+	* @param restrictionBase namespace:name (http://schemas.xmlsoap.org/soap/encoding/:Array)
+	* @param elements = array ( name = array(name=>'',type=>'') )
+	* @param attrs = array(
+	* 	array(
+	*		'ref' => "http://schemas.xmlsoap.org/soap/encoding/:arrayType",
+	*		"http://schemas.xmlsoap.org/wsdl/:arrayType" => "string[]"
+	* 	)
+	* )
+	* @param arrayType: namespace:name (http://www.w3.org/2001/XMLSchema:string)
+	* @access public
+	* @see getTypeDef
+	*/
+	function addComplexType($name,$typeClass='complexType',$phpType='array',$compositor='',$restrictionBase='',$elements=array(),$attrs=array(),$arrayType=''){
+		$this->complexTypes[$name] = array(
+	    'name'		=> $name,
+	    'typeClass'	=> $typeClass,
+	    'phpType'	=> $phpType,
+		'compositor'=> $compositor,
+	    'restrictionBase' => $restrictionBase,
+		'elements'	=> $elements,
+	    'attrs'		=> $attrs,
+	    'arrayType'	=> $arrayType
+		);
+		
+		$this->xdebug("addComplexType $name:");
+		$this->appendDebug($this->varDump($this->complexTypes[$name]));
+	}
+	
+	/**
+	* adds a simple type to the schema
+	*
+	* @param string $name
+	* @param string $restrictionBase namespace:name (http://schemas.xmlsoap.org/soap/encoding/:Array)
+	* @param string $typeClass (should always be simpleType)
+	* @param string $phpType (should always be scalar)
+	* @param array $enumeration array of values
+	* @access public
+	* @see nusoap_xmlschema
+	* @see getTypeDef
+	*/
+	function addSimpleType($name, $restrictionBase='', $typeClass='simpleType', $phpType='scalar', $enumeration=array()) {
+		$this->simpleTypes[$name] = array(
+	    'name'			=> $name,
+	    'typeClass'		=> $typeClass,
+	    'phpType'		=> $phpType,
+	    'type'			=> $restrictionBase,
+	    'enumeration'	=> $enumeration
+		);
+		
+		$this->xdebug("addSimpleType $name:");
+		$this->appendDebug($this->varDump($this->simpleTypes[$name]));
+	}
+
+	/**
+	* adds an element to the schema
+	*
+	* @param array $attrs attributes that must include name and type
+	* @see nusoap_xmlschema
+	* @access public
+	*/
+	function addElement($attrs) {
+		if (! $this->getPrefix($attrs['type'])) {
+			$attrs['type'] = $this->schemaTargetNamespace . ':' . $attrs['type'];
+		}
+		$this->elements[ $attrs['name'] ] = $attrs;
+		$this->elements[ $attrs['name'] ]['typeClass'] = 'element';
+		
+		$this->xdebug("addElement " . $attrs['name']);
+		$this->appendDebug($this->varDump($this->elements[ $attrs['name'] ]));
+	}
+}
+
+/**
+ * Backward compatibility
+ */
+class XMLSchema extends nusoap_xmlschema {
+}
+
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/ecrire/nusoap/nusoapmime.php spip/ecrire/nusoap/nusoapmime.php
--- spip-ori/ecrire/nusoap/nusoapmime.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nusoap/nusoapmime.php	2013-04-05 11:06:41.157923139 +0200
@@ -0,0 +1,501 @@
+<?php
+/*
+$Id: nusoapmime.php,v 1.13 2010/04/26 20:15:08 snichol Exp $
+
+NuSOAP - Web Services Toolkit for PHP
+
+Copyright (c) 2002 NuSphere Corporation
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The NuSOAP project home is:
+http://sourceforge.net/projects/nusoap/
+
+The primary support for NuSOAP is the mailing list:
+nusoap-general@lists.sourceforge.net
+
+If you have any questions or comments, please email:
+
+Dietrich Ayala
+dietrich@ganx4.com
+http://dietrich.ganx4.com/nusoap
+
+NuSphere Corporation
+http://www.nusphere.com
+
+*/
+
+/*require_once('nusoap.php');*/
+/* PEAR Mail_MIME library */
+require_once('Mail/mimeDecode.php');
+require_once('Mail/mimePart.php');
+
+/**
+* nusoap_client_mime client supporting MIME attachments defined at
+* http://www.w3.org/TR/SOAP-attachments.  It depends on the PEAR Mail_MIME library.
+*
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @author	Thanks to Guillaume and Henning Reich for posting great attachment code to the mail list
+* @version  $Id: nusoapmime.php,v 1.13 2010/04/26 20:15:08 snichol Exp $
+* @access   public
+*/
+class nusoap_client_mime extends nusoap_client {
+	/**
+	 * @var array Each array element in the return is an associative array with keys
+	 * data, filename, contenttype, cid
+	 * @access private
+	 */
+	var $requestAttachments = array();
+	/**
+	 * @var array Each array element in the return is an associative array with keys
+	 * data, filename, contenttype, cid
+	 * @access private
+	 */
+	var $responseAttachments;
+	/**
+	 * @var string
+	 * @access private
+	 */
+	var $mimeContentType;
+	
+	/**
+	* adds a MIME attachment to the current request.
+	*
+	* If the $data parameter contains an empty string, this method will read
+	* the contents of the file named by the $filename parameter.
+	*
+	* If the $cid parameter is false, this method will generate the cid.
+	*
+	* @param string $data The data of the attachment
+	* @param string $filename The filename of the attachment (default is empty string)
+	* @param string $contenttype The MIME Content-Type of the attachment (default is application/octet-stream)
+	* @param string $cid The content-id (cid) of the attachment (default is false)
+	* @return string The content-id (cid) of the attachment
+	* @access public
+	*/
+	function addAttachment($data, $filename = '', $contenttype = 'application/octet-stream', $cid = false) {
+		if (! $cid) {
+			$cid = md5(uniqid(time()));
+		}
+
+		$info['data'] = $data;
+		$info['filename'] = $filename;
+		$info['contenttype'] = $contenttype;
+		$info['cid'] = $cid;
+		
+		$this->requestAttachments[] = $info;
+
+		return $cid;
+	}
+
+	/**
+	* clears the MIME attachments for the current request.
+	*
+	* @access public
+	*/
+	function clearAttachments() {
+		$this->requestAttachments = array();
+	}
+
+	/**
+	* gets the MIME attachments from the current response.
+	*
+	* Each array element in the return is an associative array with keys
+	* data, filename, contenttype, cid.  These keys correspond to the parameters
+	* for addAttachment.
+	*
+	* @return array The attachments.
+	* @access public
+	*/
+	function getAttachments() {
+		return $this->responseAttachments;
+	}
+
+	/**
+	* gets the HTTP body for the current request.
+	*
+	* @param string $soapmsg The SOAP payload
+	* @return string The HTTP body, which includes the SOAP payload
+	* @access private
+	*/
+	function getHTTPBody($soapmsg) {
+		if (count($this->requestAttachments) > 0) {
+			$params['content_type'] = 'multipart/related; type="text/xml"';
+			$mimeMessage = new Mail_mimePart('', $params);
+			unset($params);
+
+			$params['content_type'] = 'text/xml';
+			$params['encoding']     = '8bit';
+			$params['charset']      = $this->soap_defencoding;
+			$mimeMessage->addSubpart($soapmsg, $params);
+			
+			foreach ($this->requestAttachments as $att) {
+				unset($params);
+
+				$params['content_type'] = $att['contenttype'];
+				$params['encoding']     = 'base64';
+				$params['disposition']  = 'attachment';
+				$params['dfilename']    = $att['filename'];
+				$params['cid']          = $att['cid'];
+
+				if ($att['data'] == '' && $att['filename'] <> '') {
+					if ($fd = fopen($att['filename'], 'rb')) {
+						$data = fread($fd, filesize($att['filename']));
+						fclose($fd);
+					} else {
+						$data = '';
+					}
+					$mimeMessage->addSubpart($data, $params);
+				} else {
+					$mimeMessage->addSubpart($att['data'], $params);
+				}
+			}
+
+			$output = $mimeMessage->encode();
+			$mimeHeaders = $output['headers'];
+	
+			foreach ($mimeHeaders as $k => $v) {
+				$this->debug("MIME header $k: $v");
+				if (strtolower($k) == 'content-type') {
+					// PHP header() seems to strip leading whitespace starting
+					// the second line, so force everything to one line
+					$this->mimeContentType = str_replace("\r\n", " ", $v);
+				}
+			}
+	
+			return $output['body'];
+		}
+
+		return parent::getHTTPBody($soapmsg);
+	}
+	
+	/**
+	* gets the HTTP content type for the current request.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type for the current request.
+	* @access private
+	*/
+	function getHTTPContentType() {
+		if (count($this->requestAttachments) > 0) {
+			return $this->mimeContentType;
+		}
+		return parent::getHTTPContentType();
+	}
+	
+	/**
+	* gets the HTTP content type charset for the current request.
+	* returns false for non-text content types.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type charset for the current request.
+	* @access private
+	*/
+	function getHTTPContentTypeCharset() {
+		if (count($this->requestAttachments) > 0) {
+			return false;
+		}
+		return parent::getHTTPContentTypeCharset();
+	}
+
+	/**
+	* processes SOAP message returned from server
+	*
+	* @param	array	$headers	The HTTP headers
+	* @param	string	$data		unprocessed response data from server
+	* @return	mixed	value of the message, decoded into a PHP type
+	* @access   private
+	*/
+    function parseResponse($headers, $data) {
+		$this->debug('Entering parseResponse() for payload of length ' . strlen($data) . ' and type of ' . $headers['content-type']);
+		$this->responseAttachments = array();
+		if (strstr($headers['content-type'], 'multipart/related')) {
+			$this->debug('Decode multipart/related');
+			$input = '';
+			foreach ($headers as $k => $v) {
+				$input .= "$k: $v\r\n";
+			}
+			$params['input'] = $input . "\r\n" . $data;
+			$params['include_bodies'] = true;
+			$params['decode_bodies'] = true;
+			$params['decode_headers'] = true;
+			
+			$structure = Mail_mimeDecode::decode($params);
+
+			foreach ($structure->parts as $part) {
+				if (!isset($part->disposition) && (strstr($part->headers['content-type'], 'text/xml'))) {
+					$this->debug('Have root part of type ' . $part->headers['content-type']);
+					$root = $part->body;
+					$return = parent::parseResponse($part->headers, $part->body);
+				} else {
+					$this->debug('Have an attachment of type ' . $part->headers['content-type']);
+					$info['data'] = $part->body;
+					$info['filename'] = isset($part->d_parameters['filename']) ? $part->d_parameters['filename'] : '';
+					$info['contenttype'] = $part->headers['content-type'];
+					$info['cid'] = $part->headers['content-id'];
+					$this->responseAttachments[] = $info;
+				}
+			}
+		
+			if (isset($return)) {
+				$this->responseData = $root;
+				return $return;
+			}
+			
+			$this->setError('No root part found in multipart/related content');
+			return '';
+		}
+		$this->debug('Not multipart/related');
+		return parent::parseResponse($headers, $data);
+	}
+}
+
+/*
+ *	For backwards compatiblity, define soapclientmime unless the PHP SOAP extension is loaded.
+ */
+if (!extension_loaded('soap')) {
+	class soapclientmime extends nusoap_client_mime {
+	}
+}
+
+/**
+* nusoap_server_mime server supporting MIME attachments defined at
+* http://www.w3.org/TR/SOAP-attachments.  It depends on the PEAR Mail_MIME library.
+*
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @author	Thanks to Guillaume and Henning Reich for posting great attachment code to the mail list
+* @version  $Id: nusoapmime.php,v 1.13 2010/04/26 20:15:08 snichol Exp $
+* @access   public
+*/
+class nusoap_server_mime extends nusoap_server {
+	/**
+	 * @var array Each array element in the return is an associative array with keys
+	 * data, filename, contenttype, cid
+	 * @access private
+	 */
+	var $requestAttachments = array();
+	/**
+	 * @var array Each array element in the return is an associative array with keys
+	 * data, filename, contenttype, cid
+	 * @access private
+	 */
+	var $responseAttachments;
+	/**
+	 * @var string
+	 * @access private
+	 */
+	var $mimeContentType;
+	
+	/**
+	* adds a MIME attachment to the current response.
+	*
+	* If the $data parameter contains an empty string, this method will read
+	* the contents of the file named by the $filename parameter.
+	*
+	* If the $cid parameter is false, this method will generate the cid.
+	*
+	* @param string $data The data of the attachment
+	* @param string $filename The filename of the attachment (default is empty string)
+	* @param string $contenttype The MIME Content-Type of the attachment (default is application/octet-stream)
+	* @param string $cid The content-id (cid) of the attachment (default is false)
+	* @return string The content-id (cid) of the attachment
+	* @access public
+	*/
+	function addAttachment($data, $filename = '', $contenttype = 'application/octet-stream', $cid = false) {
+		if (! $cid) {
+			$cid = md5(uniqid(time()));
+		}
+
+		$info['data'] = $data;
+		$info['filename'] = $filename;
+		$info['contenttype'] = $contenttype;
+		$info['cid'] = $cid;
+		
+		$this->responseAttachments[] = $info;
+
+		return $cid;
+	}
+
+	/**
+	* clears the MIME attachments for the current response.
+	*
+	* @access public
+	*/
+	function clearAttachments() {
+		$this->responseAttachments = array();
+	}
+
+	/**
+	* gets the MIME attachments from the current request.
+	*
+	* Each array element in the return is an associative array with keys
+	* data, filename, contenttype, cid.  These keys correspond to the parameters
+	* for addAttachment.
+	*
+	* @return array The attachments.
+	* @access public
+	*/
+	function getAttachments() {
+		return $this->requestAttachments;
+	}
+
+	/**
+	* gets the HTTP body for the current response.
+	*
+	* @param string $soapmsg The SOAP payload
+	* @return string The HTTP body, which includes the SOAP payload
+	* @access private
+	*/
+	function getHTTPBody($soapmsg) {
+		if (count($this->responseAttachments) > 0) {
+			$params['content_type'] = 'multipart/related; type="text/xml"';
+			$mimeMessage = new Mail_mimePart('', $params);
+			unset($params);
+
+			$params['content_type'] = 'text/xml';
+			$params['encoding']     = '8bit';
+			$params['charset']      = $this->soap_defencoding;
+			$mimeMessage->addSubpart($soapmsg, $params);
+			
+			foreach ($this->responseAttachments as $att) {
+				unset($params);
+
+				$params['content_type'] = $att['contenttype'];
+				$params['encoding']     = 'base64';
+				$params['disposition']  = 'attachment';
+				$params['dfilename']    = $att['filename'];
+				$params['cid']          = $att['cid'];
+
+				if ($att['data'] == '' && $att['filename'] <> '') {
+					if ($fd = fopen($att['filename'], 'rb')) {
+						$data = fread($fd, filesize($att['filename']));
+						fclose($fd);
+					} else {
+						$data = '';
+					}
+					$mimeMessage->addSubpart($data, $params);
+				} else {
+					$mimeMessage->addSubpart($att['data'], $params);
+				}
+			}
+
+			$output = $mimeMessage->encode();
+			$mimeHeaders = $output['headers'];
+	
+			foreach ($mimeHeaders as $k => $v) {
+				$this->debug("MIME header $k: $v");
+				if (strtolower($k) == 'content-type') {
+					// PHP header() seems to strip leading whitespace starting
+					// the second line, so force everything to one line
+					$this->mimeContentType = str_replace("\r\n", " ", $v);
+				}
+			}
+	
+			return $output['body'];
+		}
+
+		return parent::getHTTPBody($soapmsg);
+	}
+	
+	/**
+	* gets the HTTP content type for the current response.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type for the current response.
+	* @access private
+	*/
+	function getHTTPContentType() {
+		if (count($this->responseAttachments) > 0) {
+			return $this->mimeContentType;
+		}
+		return parent::getHTTPContentType();
+	}
+	
+	/**
+	* gets the HTTP content type charset for the current response.
+	* returns false for non-text content types.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type charset for the current response.
+	* @access private
+	*/
+	function getHTTPContentTypeCharset() {
+		if (count($this->responseAttachments) > 0) {
+			return false;
+		}
+		return parent::getHTTPContentTypeCharset();
+	}
+
+	/**
+	* processes SOAP message received from client
+	*
+	* @param	array	$headers	The HTTP headers
+	* @param	string	$data		unprocessed request data from client
+	* @return	mixed	value of the message, decoded into a PHP type
+	* @access   private
+	*/
+    function parseRequest($headers, $data) {
+		$this->debug('Entering parseRequest() for payload of length ' . strlen($data) . ' and type of ' . $headers['content-type']);
+		$this->requestAttachments = array();
+		if (strstr($headers['content-type'], 'multipart/related')) {
+			$this->debug('Decode multipart/related');
+			$input = '';
+			foreach ($headers as $k => $v) {
+				$input .= "$k: $v\r\n";
+			}
+			$params['input'] = $input . "\r\n" . $data;
+			$params['include_bodies'] = true;
+			$params['decode_bodies'] = true;
+			$params['decode_headers'] = true;
+			
+			$structure = Mail_mimeDecode::decode($params);
+
+			foreach ($structure->parts as $part) {
+				if (!isset($part->disposition) && (strstr($part->headers['content-type'], 'text/xml'))) {
+					$this->debug('Have root part of type ' . $part->headers['content-type']);
+					$return = parent::parseRequest($part->headers, $part->body);
+				} else {
+					$this->debug('Have an attachment of type ' . $part->headers['content-type']);
+					$info['data'] = $part->body;
+					$info['filename'] = isset($part->d_parameters['filename']) ? $part->d_parameters['filename'] : '';
+					$info['contenttype'] = $part->headers['content-type'];
+					$info['cid'] = $part->headers['content-id'];
+					$this->requestAttachments[] = $info;
+				}
+			}
+		
+			if (isset($return)) {
+				return $return;
+			}
+			
+			$this->setError('No root part found in multipart/related content');
+			return;
+		}
+		$this->debug('Not multipart/related');
+		return parent::parseRequest($headers, $data);
+	}
+}
+
+/*
+ *	For backwards compatiblity
+ */
+class nusoapservermime extends nusoap_server_mime {
+}
+
+?>
diff -rNU5 spip-ori/ecrire/nusoap/nusoap.php spip/ecrire/nusoap/nusoap.php
--- spip-ori/ecrire/nusoap/nusoap.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nusoap/nusoap.php	2013-04-05 11:06:41.161923140 +0200
@@ -0,0 +1,8150 @@
+<?php
+
+/*
+$Id: nusoap.php,v 1.123 2010/04/26 20:15:08 snichol Exp $
+
+NuSOAP - Web Services Toolkit for PHP
+
+Copyright (c) 2002 NuSphere Corporation
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The NuSOAP project home is:
+http://sourceforge.net/projects/nusoap/
+
+The primary support for NuSOAP is the Help forum on the project home page.
+
+If you have any questions or comments, please email:
+
+Dietrich Ayala
+dietrich@ganx4.com
+http://dietrich.ganx4.com/nusoap
+
+NuSphere Corporation
+http://www.nusphere.com
+
+*/
+
+/*
+ *	Some of the standards implmented in whole or part by NuSOAP:
+ *
+ *	SOAP 1.1 (http://www.w3.org/TR/2000/NOTE-SOAP-20000508/)
+ *	WSDL 1.1 (http://www.w3.org/TR/2001/NOTE-wsdl-20010315)
+ *	SOAP Messages With Attachments (http://www.w3.org/TR/SOAP-attachments)
+ *	XML 1.0 (http://www.w3.org/TR/2006/REC-xml-20060816/)
+ *	Namespaces in XML 1.0 (http://www.w3.org/TR/2006/REC-xml-names-20060816/)
+ *	XML Schema 1.0 (http://www.w3.org/TR/xmlschema-0/)
+ *	RFC 2045 Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies
+ *	RFC 2068 Hypertext Transfer Protocol -- HTTP/1.1
+ *	RFC 2617 HTTP Authentication: Basic and Digest Access Authentication
+ */
+
+/* load classes
+
+// necessary classes
+require_once('class.soapclient.php');
+require_once('class.soap_val.php');
+require_once('class.soap_parser.php');
+require_once('class.soap_fault.php');
+
+// transport classes
+require_once('class.soap_transport_http.php');
+
+// optional add-on classes
+require_once('class.xmlschema.php');
+require_once('class.wsdl.php');
+
+// server class
+require_once('class.soap_server.php');*/
+
+// class variable emulation
+// cf. http://www.webkreator.com/php/techniques/php-static-class-variables.html
+$GLOBALS['_transient']['static']['nusoap_base']['globalDebugLevel'] = 9;
+
+/**
+*
+* nusoap_base
+*
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @version  $Id: nusoap.php,v 1.123 2010/04/26 20:15:08 snichol Exp $
+* @access   public
+*/
+class nusoap_base {
+	/**
+	 * Identification for HTTP headers.
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $title = 'NuSOAP';
+	/**
+	 * Version for HTTP headers.
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $version = '0.9.5';
+	/**
+	 * CVS revision for HTTP headers.
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $revision = '$Revision: 1.123 $';
+    /**
+     * Current error string (manipulated by getError/setError)
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $error_str = '';
+    /**
+     * Current debug string (manipulated by debug/appendDebug/clearDebug/getDebug/getDebugAsXMLComment)
+	 *
+	 * @var string
+	 * @access private
+	 */
+    var $debug_str = '';
+    /**
+	 * toggles automatic encoding of special characters as entities
+	 * (should always be true, I think)
+	 *
+	 * @var boolean
+	 * @access private
+	 */
+	var $charencoding = true;
+	/**
+	 * the debug level for this instance
+	 *
+	 * @var	integer
+	 * @access private
+	 */
+	var $debugLevel;
+
+    /**
+	* set schema version
+	*
+	* @var      string
+	* @access   public
+	*/
+	var $XMLSchemaVersion = 'http://www.w3.org/2001/XMLSchema';
+	
+    /**
+	* charset encoding for outgoing messages
+	*
+	* @var      string
+	* @access   public
+	*/
+    var $soap_defencoding = 'ISO-8859-1';
+	//var $soap_defencoding = 'UTF-8';
+
+	/**
+	* namespaces in an array of prefix => uri
+	*
+	* this is "seeded" by a set of constants, but it may be altered by code
+	*
+	* @var      array
+	* @access   public
+	*/
+	var $namespaces = array(
+		'SOAP-ENV' => 'http://schemas.xmlsoap.org/soap/envelope/',
+		'xsd' => 'http://www.w3.org/2001/XMLSchema',
+		'xsi' => 'http://www.w3.org/2001/XMLSchema-instance',
+		'SOAP-ENC' => 'http://schemas.xmlsoap.org/soap/encoding/'
+		);
+
+	/**
+	* namespaces used in the current context, e.g. during serialization
+	*
+	* @var      array
+	* @access   private
+	*/
+	var $usedNamespaces = array();
+
+	/**
+	* XML Schema types in an array of uri => (array of xml type => php type)
+	* is this legacy yet?
+	* no, this is used by the nusoap_xmlschema class to verify type => namespace mappings.
+	* @var      array
+	* @access   public
+	*/
+	var $typemap = array(
+	'http://www.w3.org/2001/XMLSchema' => array(
+		'string'=>'string','boolean'=>'boolean','float'=>'double','double'=>'double','decimal'=>'double',
+		'duration'=>'','dateTime'=>'string','time'=>'string','date'=>'string','gYearMonth'=>'',
+		'gYear'=>'','gMonthDay'=>'','gDay'=>'','gMonth'=>'','hexBinary'=>'string','base64Binary'=>'string',
+		// abstract "any" types
+		'anyType'=>'string','anySimpleType'=>'string',
+		// derived datatypes
+		'normalizedString'=>'string','token'=>'string','language'=>'','NMTOKEN'=>'','NMTOKENS'=>'','Name'=>'','NCName'=>'','ID'=>'',
+		'IDREF'=>'','IDREFS'=>'','ENTITY'=>'','ENTITIES'=>'','integer'=>'integer','nonPositiveInteger'=>'integer',
+		'negativeInteger'=>'integer','long'=>'integer','int'=>'integer','short'=>'integer','byte'=>'integer','nonNegativeInteger'=>'integer',
+		'unsignedLong'=>'','unsignedInt'=>'','unsignedShort'=>'','unsignedByte'=>'','positiveInteger'=>''),
+	'http://www.w3.org/2000/10/XMLSchema' => array(
+		'i4'=>'','int'=>'integer','boolean'=>'boolean','string'=>'string','double'=>'double',
+		'float'=>'double','dateTime'=>'string',
+		'timeInstant'=>'string','base64Binary'=>'string','base64'=>'string','ur-type'=>'array'),
+	'http://www.w3.org/1999/XMLSchema' => array(
+		'i4'=>'','int'=>'integer','boolean'=>'boolean','string'=>'string','double'=>'double',
+		'float'=>'double','dateTime'=>'string',
+		'timeInstant'=>'string','base64Binary'=>'string','base64'=>'string','ur-type'=>'array'),
+	'http://soapinterop.org/xsd' => array('SOAPStruct'=>'struct'),
+	'http://schemas.xmlsoap.org/soap/encoding/' => array('base64'=>'string','array'=>'array','Array'=>'array'),
+    'http://xml.apache.org/xml-soap' => array('Map')
+	);
+
+	/**
+	* XML entities to convert
+	*
+	* @var      array
+	* @access   public
+	* @deprecated
+	* @see	expandEntities
+	*/
+	var $xmlEntities = array('quot' => '"','amp' => '&',
+		'lt' => '<','gt' => '>','apos' => "'");
+
+	/**
+	* constructor
+	*
+	* @access	public
+	*/
+	function nusoap_base() {
+		$this->debugLevel = $GLOBALS['_transient']['static']['nusoap_base']['globalDebugLevel'];
+	}
+
+	/**
+	* gets the global debug level, which applies to future instances
+	*
+	* @return	integer	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function getGlobalDebugLevel() {
+		return $GLOBALS['_transient']['static']['nusoap_base']['globalDebugLevel'];
+	}
+
+	/**
+	* sets the global debug level, which applies to future instances
+	*
+	* @param	int	$level	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function setGlobalDebugLevel($level) {
+		$GLOBALS['_transient']['static']['nusoap_base']['globalDebugLevel'] = $level;
+	}
+
+	/**
+	* gets the debug level for this instance
+	*
+	* @return	int	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function getDebugLevel() {
+		return $this->debugLevel;
+	}
+
+	/**
+	* sets the debug level for this instance
+	*
+	* @param	int	$level	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function setDebugLevel($level) {
+		$this->debugLevel = $level;
+	}
+
+	/**
+	* adds debug data to the instance debug string with formatting
+	*
+	* @param    string $string debug data
+	* @access   private
+	*/
+	function debug($string){
+		if ($this->debugLevel > 0) {
+			$this->appendDebug($this->getmicrotime().' '.get_class($this).": $string\n");
+		}
+	}
+
+	/**
+	* adds debug data to the instance debug string without formatting
+	*
+	* @param    string $string debug data
+	* @access   public
+	*/
+	function appendDebug($string){
+		if ($this->debugLevel > 0) {
+			// it would be nice to use a memory stream here to use
+			// memory more efficiently
+			$this->debug_str .= $string;
+		}
+	}
+
+	/**
+	* clears the current debug data for this instance
+	*
+	* @access   public
+	*/
+	function clearDebug() {
+		// it would be nice to use a memory stream here to use
+		// memory more efficiently
+		$this->debug_str = '';
+	}
+
+	/**
+	* gets the current debug data for this instance
+	*
+	* @return   debug data
+	* @access   public
+	*/
+	function &getDebug() {
+		// it would be nice to use a memory stream here to use
+		// memory more efficiently
+		return $this->debug_str;
+	}
+
+	/**
+	* gets the current debug data for this instance as an XML comment
+	* this may change the contents of the debug data
+	*
+	* @return   debug data as an XML comment
+	* @access   public
+	*/
+	function &getDebugAsXMLComment() {
+		// it would be nice to use a memory stream here to use
+		// memory more efficiently
+		while (strpos($this->debug_str, '--')) {
+			$this->debug_str = str_replace('--', '- -', $this->debug_str);
+		}
+		$ret = "<!--\n" . $this->debug_str . "\n-->";
+    	return $ret;
+	}
+
+	/**
+	* expands entities, e.g. changes '<' to '&lt;'.
+	*
+	* @param	string	$val	The string in which to expand entities.
+	* @access	private
+	*/
+	function expandEntities($val) {
+		if ($this->charencoding) {
+	    	$val = str_replace('&', '&amp;', $val);
+	    	$val = str_replace("'", '&apos;', $val);
+	    	$val = str_replace('"', '&quot;', $val);
+	    	$val = str_replace('<', '&lt;', $val);
+	    	$val = str_replace('>', '&gt;', $val);
+	    }
+	    return $val;
+	}
+
+	/**
+	* returns error string if present
+	*
+	* @return   mixed error string or false
+	* @access   public
+	*/
+	function getError(){
+		if($this->error_str != ''){
+			return $this->error_str;
+		}
+		return false;
+	}
+
+	/**
+	* sets error string
+	*
+	* @return   boolean $string error string
+	* @access   private
+	*/
+	function setError($str){
+		$this->error_str = $str;
+	}
+
+	/**
+	* detect if array is a simple array or a struct (associative array)
+	*
+	* @param	mixed	$val	The PHP array
+	* @return	string	(arraySimple|arrayStruct)
+	* @access	private
+	*/
+	function isArraySimpleOrStruct($val) {
+        $keyList = array_keys($val);
+		foreach ($keyList as $keyListValue) {
+			if (!is_int($keyListValue)) {
+				return 'arrayStruct';
+			}
+		}
+		return 'arraySimple';
+	}
+
+	/**
+	* serializes PHP values in accordance w/ section 5. Type information is
+	* not serialized if $use == 'literal'.
+	*
+	* @param	mixed	$val	The value to serialize
+	* @param	string	$name	The name (local part) of the XML element
+	* @param	string	$type	The XML schema type (local part) for the element
+	* @param	string	$name_ns	The namespace for the name of the XML element
+	* @param	string	$type_ns	The namespace for the type of the element
+	* @param	array	$attributes	The attributes to serialize as name=>value pairs
+	* @param	string	$use	The WSDL "use" (encoded|literal)
+	* @param	boolean	$soapval	Whether this is called from soapval.
+	* @return	string	The serialized element, possibly with child elements
+    * @access	public
+	*/
+	function serialize_val($val,$name=false,$type=false,$name_ns=false,$type_ns=false,$attributes=false,$use='encoded',$soapval=false) {
+		$this->debug("in serialize_val: name=$name, type=$type, name_ns=$name_ns, type_ns=$type_ns, use=$use, soapval=$soapval");
+		$this->appendDebug('value=' . $this->varDump($val));
+		$this->appendDebug('attributes=' . $this->varDump($attributes));
+		
+    	if (is_object($val) && get_class($val) == 'soapval' && (! $soapval)) {
+    		$this->debug("serialize_val: serialize soapval");
+        	$xml = $val->serialize($use);
+			$this->appendDebug($val->getDebug());
+			$val->clearDebug();
+			$this->debug("serialize_val of soapval returning $xml");
+			return $xml;
+        }
+		// force valid name if necessary
+		if (is_numeric($name)) {
+			$name = '__numeric_' . $name;
+		} elseif (! $name) {
+			$name = 'noname';
+		}
+		// if name has ns, add ns prefix to name
+		$xmlns = '';
+        if($name_ns){
+			$prefix = 'nu'.rand(1000,9999);
+			$name = $prefix.':'.$name;
+			$xmlns .= " xmlns:$prefix=\"$name_ns\"";
+		}
+		// if type is prefixed, create type prefix
+		if($type_ns != '' && $type_ns == $this->namespaces['xsd']){
+			// need to fix this. shouldn't default to xsd if no ns specified
+		    // w/o checking against typemap
+			$type_prefix = 'xsd';
+		} elseif($type_ns){
+			$type_prefix = 'ns'.rand(1000,9999);
+			$xmlns .= " xmlns:$type_prefix=\"$type_ns\"";
+		}
+		// serialize attributes if present
+		$atts = '';
+		if($attributes){
+			foreach($attributes as $k => $v){
+				$atts .= " $k=\"".$this->expandEntities($v).'"';
+			}
+		}
+		// serialize null value
+		if (is_null($val)) {
+    		$this->debug("serialize_val: serialize null");
+			if ($use == 'literal') {
+				// TODO: depends on minOccurs
+				$xml = "<$name$xmlns$atts/>";
+				$this->debug("serialize_val returning $xml");
+	        	return $xml;
+        	} else {
+				if (isset($type) && isset($type_prefix)) {
+					$type_str = " xsi:type=\"$type_prefix:$type\"";
+				} else {
+					$type_str = '';
+				}
+				$xml = "<$name$xmlns$type_str$atts xsi:nil=\"true\"/>";
+				$this->debug("serialize_val returning $xml");
+	        	return $xml;
+        	}
+		}
+        // serialize if an xsd built-in primitive type
+        if($type != '' && isset($this->typemap[$this->XMLSchemaVersion][$type])){
+    		$this->debug("serialize_val: serialize xsd built-in primitive type");
+        	if (is_bool($val)) {
+        		if ($type == 'boolean') {
+	        		$val = $val ? 'true' : 'false';
+	        	} elseif (! $val) {
+	        		$val = 0;
+	        	}
+			} else if (is_string($val)) {
+				$val = $this->expandEntities($val);
+			}
+			if ($use == 'literal') {
+				$xml = "<$name$xmlns$atts>$val</$name>";
+				$this->debug("serialize_val returning $xml");
+	        	return $xml;
+        	} else {
+				$xml = "<$name$xmlns xsi:type=\"xsd:$type\"$atts>$val</$name>";
+				$this->debug("serialize_val returning $xml");
+	        	return $xml;
+        	}
+        }
+		// detect type and serialize
+		$xml = '';
+		switch(true) {
+			case (is_bool($val) || $type == 'boolean'):
+		   		$this->debug("serialize_val: serialize boolean");
+        		if ($type == 'boolean') {
+	        		$val = $val ? 'true' : 'false';
+	        	} elseif (! $val) {
+	        		$val = 0;
+	        	}
+				if ($use == 'literal') {
+					$xml .= "<$name$xmlns$atts>$val</$name>";
+				} else {
+					$xml .= "<$name$xmlns xsi:type=\"xsd:boolean\"$atts>$val</$name>";
+				}
+				break;
+			case (is_int($val) || is_long($val) || $type == 'int'):
+		   		$this->debug("serialize_val: serialize int");
+				if ($use == 'literal') {
+					$xml .= "<$name$xmlns$atts>$val</$name>";
+				} else {
+					$xml .= "<$name$xmlns xsi:type=\"xsd:int\"$atts>$val</$name>";
+				}
+				break;
+			case (is_float($val)|| is_double($val) || $type == 'float'):
+		   		$this->debug("serialize_val: serialize float");
+				if ($use == 'literal') {
+					$xml .= "<$name$xmlns$atts>$val</$name>";
+				} else {
+					$xml .= "<$name$xmlns xsi:type=\"xsd:float\"$atts>$val</$name>";
+				}
+				break;
+			case (is_string($val) || $type == 'string'):
+		   		$this->debug("serialize_val: serialize string");
+				$val = $this->expandEntities($val);
+				if ($use == 'literal') {
+					$xml .= "<$name$xmlns$atts>$val</$name>";
+				} else {
+					$xml .= "<$name$xmlns xsi:type=\"xsd:string\"$atts>$val</$name>";
+				}
+				break;
+			case is_object($val):
+		   		$this->debug("serialize_val: serialize object");
+		    	if (get_class($val) == 'soapval') {
+		    		$this->debug("serialize_val: serialize soapval object");
+		        	$pXml = $val->serialize($use);
+					$this->appendDebug($val->getDebug());
+					$val->clearDebug();
+		        } else {
+					if (! $name) {
+						$name = get_class($val);
+						$this->debug("In serialize_val, used class name $name as element name");
+					} else {
+						$this->debug("In serialize_val, do not override name $name for element name for class " . get_class($val));
+					}
+					foreach(get_object_vars($val) as $k => $v){
+						$pXml = isset($pXml) ? $pXml.$this->serialize_val($v,$k,false,false,false,false,$use) : $this->serialize_val($v,$k,false,false,false,false,$use);
+					}
+				}
+				if(isset($type) && isset($type_prefix)){
+					$type_str = " xsi:type=\"$type_prefix:$type\"";
+				} else {
+					$type_str = '';
+				}
+				if ($use == 'literal') {
+					$xml .= "<$name$xmlns$atts>$pXml</$name>";
+				} else {
+					$xml .= "<$name$xmlns$type_str$atts>$pXml</$name>";
+				}
+				break;
+			break;
+			case (is_array($val) || $type):
+				// detect if struct or array
+				$valueType = $this->isArraySimpleOrStruct($val);
+                if($valueType=='arraySimple' || preg_match('/^ArrayOf/',$type)){
+			   		$this->debug("serialize_val: serialize array");
+					$i = 0;
+					if(is_array($val) && count($val)> 0){
+						foreach($val as $v){
+	                    	if(is_object($v) && get_class($v) ==  'soapval'){
+								$tt_ns = $v->type_ns;
+								$tt = $v->type;
+							} elseif (is_array($v)) {
+								$tt = $this->isArraySimpleOrStruct($v);
+							} else {
+								$tt = gettype($v);
+	                        }
+							$array_types[$tt] = 1;
+							// TODO: for literal, the name should be $name
+							$xml .= $this->serialize_val($v,'item',false,false,false,false,$use);
+							++$i;
+						}
+						if(count($array_types) > 1){
+							$array_typename = 'xsd:anyType';
+						} elseif(isset($tt) && isset($this->typemap[$this->XMLSchemaVersion][$tt])) {
+							if ($tt == 'integer') {
+								$tt = 'int';
+							}
+							$array_typename = 'xsd:'.$tt;
+						} elseif(isset($tt) && $tt == 'arraySimple'){
+							$array_typename = 'SOAP-ENC:Array';
+						} elseif(isset($tt) && $tt == 'arrayStruct'){
+							$array_typename = 'unnamed_struct_use_soapval';
+						} else {
+							// if type is prefixed, create type prefix
+							if ($tt_ns != '' && $tt_ns == $this->namespaces['xsd']){
+								 $array_typename = 'xsd:' . $tt;
+							} elseif ($tt_ns) {
+								$tt_prefix = 'ns' . rand(1000, 9999);
+								$array_typename = "$tt_prefix:$tt";
+								$xmlns .= " xmlns:$tt_prefix=\"$tt_ns\"";
+							} else {
+								$array_typename = $tt;
+							}
+						}
+						$array_type = $i;
+						if ($use == 'literal') {
+							$type_str = '';
+						} else if (isset($type) && isset($type_prefix)) {
+							$type_str = " xsi:type=\"$type_prefix:$type\"";
+						} else {
+							$type_str = " xsi:type=\"SOAP-ENC:Array\" SOAP-ENC:arrayType=\"".$array_typename."[$array_type]\"";
+						}
+					// empty array
+					} else {
+						if ($use == 'literal') {
+							$type_str = '';
+						} else if (isset($type) && isset($type_prefix)) {
+							$type_str = " xsi:type=\"$type_prefix:$type\"";
+						} else {
+							$type_str = " xsi:type=\"SOAP-ENC:Array\" SOAP-ENC:arrayType=\"xsd:anyType[0]\"";
+						}
+					}
+					// TODO: for array in literal, there is no wrapper here
+					$xml = "<$name$xmlns$type_str$atts>".$xml."</$name>";
+				} else {
+					// got a struct
+			   		$this->debug("serialize_val: serialize struct");
+					if(isset($type) && isset($type_prefix)){
+						$type_str = " xsi:type=\"$type_prefix:$type\"";
+					} else {
+						$type_str = '';
+					}
+					if ($use == 'literal') {
+						$xml .= "<$name$xmlns$atts>";
+					} else {
+						$xml .= "<$name$xmlns$type_str$atts>";
+					}
+					foreach($val as $k => $v){
+						// Apache Map
+						if ($type == 'Map' && $type_ns == 'http://xml.apache.org/xml-soap') {
+							$xml .= '<item>';
+							$xml .= $this->serialize_val($k,'key',false,false,false,false,$use);
+							$xml .= $this->serialize_val($v,'value',false,false,false,false,$use);
+							$xml .= '</item>';
+						} else {
+							$xml .= $this->serialize_val($v,$k,false,false,false,false,$use);
+						}
+					}
+					$xml .= "</$name>";
+				}
+				break;
+			default:
+		   		$this->debug("serialize_val: serialize unknown");
+				$xml .= 'not detected, got '.gettype($val).' for '.$val;
+				break;
+		}
+		$this->debug("serialize_val returning $xml");
+		return $xml;
+	}
+
+    /**
+    * serializes a message
+    *
+    * @param string $body the XML of the SOAP body
+    * @param mixed $headers optional string of XML with SOAP header content, or array of soapval objects for SOAP headers, or associative array
+    * @param array $namespaces optional the namespaces used in generating the body and headers
+    * @param string $style optional (rpc|document)
+    * @param string $use optional (encoded|literal)
+    * @param string $encodingStyle optional (usually 'http://schemas.xmlsoap.org/soap/encoding/' for encoded)
+    * @return string the message
+    * @access public
+    */
+    function serializeEnvelope($body,$headers=false,$namespaces=array(),$style='rpc',$use='encoded',$encodingStyle='http://schemas.xmlsoap.org/soap/encoding/'){
+    // TODO: add an option to automatically run utf8_encode on $body and $headers
+    // if $this->soap_defencoding is UTF-8.  Not doing this automatically allows
+    // one to send arbitrary UTF-8 characters, not just characters that map to ISO-8859-1
+
+	$this->debug("In serializeEnvelope length=" . strlen($body) . " body (max 1000 characters)=" . substr($body, 0, 1000) . " style=$style use=$use encodingStyle=$encodingStyle");
+	$this->debug("headers:");
+	$this->appendDebug($this->varDump($headers));
+	$this->debug("namespaces:");
+	$this->appendDebug($this->varDump($namespaces));
+
+	// serialize namespaces
+    $ns_string = '';
+	foreach(array_merge($this->namespaces,$namespaces) as $k => $v){
+		$ns_string .= " xmlns:$k=\"$v\"";
+	}
+	if($encodingStyle) {
+		$ns_string = " SOAP-ENV:encodingStyle=\"$encodingStyle\"$ns_string";
+	}
+
+	// serialize headers
+	if($headers){
+		if (is_array($headers)) {
+			$xml = '';
+			foreach ($headers as $k => $v) {
+				if (is_object($v) && get_class($v) == 'soapval') {
+					$xml .= $this->serialize_val($v, false, false, false, false, false, $use);
+				} else {
+					$xml .= $this->serialize_val($v, $k, false, false, false, false, $use);
+				}
+			}
+			$headers = $xml;
+			$this->debug("In serializeEnvelope, serialized array of headers to $headers");
+		}
+		$headers = "<SOAP-ENV:Header>".$headers."</SOAP-ENV:Header>";
+	}
+	// serialize envelope
+	return
+	'<?xml version="1.0" encoding="'.$this->soap_defencoding .'"?'.">".
+	'<SOAP-ENV:Envelope'.$ns_string.">".
+	$headers.
+	"<SOAP-ENV:Body>".
+		$body.
+	"</SOAP-ENV:Body>".
+	"</SOAP-ENV:Envelope>";
+    }
+
+	/**
+	 * formats a string to be inserted into an HTML stream
+	 *
+	 * @param string $str The string to format
+	 * @return string The formatted string
+	 * @access public
+	 * @deprecated
+	 */
+    function formatDump($str){
+		$str = htmlspecialchars($str);
+		return nl2br($str);
+    }
+
+	/**
+	* contracts (changes namespace to prefix) a qualified name
+	*
+	* @param    string $qname qname
+	* @return	string contracted qname
+	* @access   private
+	*/
+	function contractQname($qname){
+		// get element namespace
+		//$this->xdebug("Contract $qname");
+		if (strrpos($qname, ':')) {
+			// get unqualified name
+			$name = substr($qname, strrpos($qname, ':') + 1);
+			// get ns
+			$ns = substr($qname, 0, strrpos($qname, ':'));
+			$p = $this->getPrefixFromNamespace($ns);
+			if ($p) {
+				return $p . ':' . $name;
+			}
+			return $qname;
+		} else {
+			return $qname;
+		}
+	}
+
+	/**
+	* expands (changes prefix to namespace) a qualified name
+	*
+	* @param    string $qname qname
+	* @return	string expanded qname
+	* @access   private
+	*/
+	function expandQname($qname){
+		// get element prefix
+		if(strpos($qname,':') && !preg_match('/^http:\/\//',$qname)){
+			// get unqualified name
+			$name = substr(strstr($qname,':'),1);
+			// get ns prefix
+			$prefix = substr($qname,0,strpos($qname,':'));
+			if(isset($this->namespaces[$prefix])){
+				return $this->namespaces[$prefix].':'.$name;
+			} else {
+				return $qname;
+			}
+		} else {
+			return $qname;
+		}
+	}
+
+    /**
+    * returns the local part of a prefixed string
+    * returns the original string, if not prefixed
+    *
+    * @param string $str The prefixed string
+    * @return string The local part
+    * @access public
+    */
+	function getLocalPart($str){
+		if($sstr = strrchr($str,':')){
+			// get unqualified name
+			return substr( $sstr, 1 );
+		} else {
+			return $str;
+		}
+	}
+
+	/**
+    * returns the prefix part of a prefixed string
+    * returns false, if not prefixed
+    *
+    * @param string $str The prefixed string
+    * @return mixed The prefix or false if there is no prefix
+    * @access public
+    */
+	function getPrefix($str){
+		if($pos = strrpos($str,':')){
+			// get prefix
+			return substr($str,0,$pos);
+		}
+		return false;
+	}
+
+	/**
+    * pass it a prefix, it returns a namespace
+    *
+    * @param string $prefix The prefix
+    * @return mixed The namespace, false if no namespace has the specified prefix
+    * @access public
+    */
+	function getNamespaceFromPrefix($prefix){
+		if (isset($this->namespaces[$prefix])) {
+			return $this->namespaces[$prefix];
+		}
+		//$this->setError("No namespace registered for prefix '$prefix'");
+		return false;
+	}
+
+	/**
+    * returns the prefix for a given namespace (or prefix)
+    * or false if no prefixes registered for the given namespace
+    *
+    * @param string $ns The namespace
+    * @return mixed The prefix, false if the namespace has no prefixes
+    * @access public
+    */
+	function getPrefixFromNamespace($ns) {
+		foreach ($this->namespaces as $p => $n) {
+			if ($ns == $n || $ns == $p) {
+			    $this->usedNamespaces[$p] = $n;
+				return $p;
+			}
+		}
+		return false;
+	}
+
+	/**
+    * returns the time in ODBC canonical form with microseconds
+    *
+    * @return string The time in ODBC canonical form with microseconds
+    * @access public
+    */
+	function getmicrotime() {
+		if (function_exists('gettimeofday')) {
+			$tod = gettimeofday();
+			$sec = $tod['sec'];
+			$usec = $tod['usec'];
+		} else {
+			$sec = time();
+			$usec = 0;
+		}
+		return strftime('%Y-%m-%d %H:%M:%S', $sec) . '.' . sprintf('%06d', $usec);
+	}
+
+	/**
+	 * Returns a string with the output of var_dump
+	 *
+	 * @param mixed $data The variable to var_dump
+	 * @return string The output of var_dump
+	 * @access public
+	 */
+    function varDump($data) {
+		ob_start();
+		var_dump($data);
+		$ret_val = ob_get_contents();
+		ob_end_clean();
+		return $ret_val;
+	}
+
+	/**
+	* represents the object as a string
+	*
+	* @return	string
+	* @access   public
+	*/
+	function __toString() {
+		return $this->varDump($this);
+	}
+}
+
+// XML Schema Datatype Helper Functions
+
+//xsd:dateTime helpers
+
+/**
+* convert unix timestamp to ISO 8601 compliant date string
+*
+* @param    int $timestamp Unix time stamp
+* @param	boolean $utc Whether the time stamp is UTC or local
+* @return	mixed ISO 8601 date string or false
+* @access   public
+*/
+function timestamp_to_iso8601($timestamp,$utc=true){
+	$datestr = date('Y-m-d\TH:i:sO',$timestamp);
+	$pos = strrpos($datestr, "+");
+	if ($pos === FALSE) {
+		$pos = strrpos($datestr, "-");
+	}
+	if ($pos !== FALSE) {
+		if (strlen($datestr) == $pos + 5) {
+			$datestr = substr($datestr, 0, $pos + 3) . ':' . substr($datestr, -2);
+		}
+	}
+	if($utc){
+		$pattern = '/'.
+		'([0-9]{4})-'.	// centuries & years CCYY-
+		'([0-9]{2})-'.	// months MM-
+		'([0-9]{2})'.	// days DD
+		'T'.			// separator T
+		'([0-9]{2}):'.	// hours hh:
+		'([0-9]{2}):'.	// minutes mm:
+		'([0-9]{2})(\.[0-9]*)?'. // seconds ss.ss...
+		'(Z|[+\-][0-9]{2}:?[0-9]{2})?'. // Z to indicate UTC, -/+HH:MM:SS.SS... for local tz's
+		'/';
+
+		if(preg_match($pattern,$datestr,$regs)){
+			return sprintf('%04d-%02d-%02dT%02d:%02d:%02dZ',$regs[1],$regs[2],$regs[3],$regs[4],$regs[5],$regs[6]);
+		}
+		return false;
+	} else {
+		return $datestr;
+	}
+}
+
+/**
+* convert ISO 8601 compliant date string to unix timestamp
+*
+* @param    string $datestr ISO 8601 compliant date string
+* @return	mixed Unix timestamp (int) or false
+* @access   public
+*/
+function iso8601_to_timestamp($datestr){
+	$pattern = '/'.
+	'([0-9]{4})-'.	// centuries & years CCYY-
+	'([0-9]{2})-'.	// months MM-
+	'([0-9]{2})'.	// days DD
+	'T'.			// separator T
+	'([0-9]{2}):'.	// hours hh:
+	'([0-9]{2}):'.	// minutes mm:
+	'([0-9]{2})(\.[0-9]+)?'. // seconds ss.ss...
+	'(Z|[+\-][0-9]{2}:?[0-9]{2})?'. // Z to indicate UTC, -/+HH:MM:SS.SS... for local tz's
+	'/';
+	if(preg_match($pattern,$datestr,$regs)){
+		// not utc
+		if($regs[8] != 'Z'){
+			$op = substr($regs[8],0,1);
+			$h = substr($regs[8],1,2);
+			$m = substr($regs[8],strlen($regs[8])-2,2);
+			if($op == '-'){
+				$regs[4] = $regs[4] + $h;
+				$regs[5] = $regs[5] + $m;
+			} elseif($op == '+'){
+				$regs[4] = $regs[4] - $h;
+				$regs[5] = $regs[5] - $m;
+			}
+		}
+		return gmmktime($regs[4], $regs[5], $regs[6], $regs[2], $regs[3], $regs[1]);
+//		return strtotime("$regs[1]-$regs[2]-$regs[3] $regs[4]:$regs[5]:$regs[6]Z");
+	} else {
+		return false;
+	}
+}
+
+/**
+* sleeps some number of microseconds
+*
+* @param    string $usec the number of microseconds to sleep
+* @access   public
+* @deprecated
+*/
+function usleepWindows($usec)
+{
+	$start = gettimeofday();
+	
+	do
+	{
+		$stop = gettimeofday();
+		$timePassed = 1000000 * ($stop['sec'] - $start['sec'])
+		+ $stop['usec'] - $start['usec'];
+	}
+	while ($timePassed < $usec);
+}
+
+?><?php
+
+
+
+/**
+* Contains information for a SOAP fault.
+* Mainly used for returning faults from deployed functions
+* in a server instance.
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @version  $Id: nusoap.php,v 1.123 2010/04/26 20:15:08 snichol Exp $
+* @access public
+*/
+class nusoap_fault extends nusoap_base {
+	/**
+	 * The fault code (client|server)
+	 * @var string
+	 * @access private
+	 */
+	var $faultcode;
+	/**
+	 * The fault actor
+	 * @var string
+	 * @access private
+	 */
+	var $faultactor;
+	/**
+	 * The fault string, a description of the fault
+	 * @var string
+	 * @access private
+	 */
+	var $faultstring;
+	/**
+	 * The fault detail, typically a string or array of string
+	 * @var mixed
+	 * @access private
+	 */
+	var $faultdetail;
+
+	/**
+	* constructor
+    *
+    * @param string $faultcode (SOAP-ENV:Client | SOAP-ENV:Server)
+    * @param string $faultactor only used when msg routed between multiple actors
+    * @param string $faultstring human readable error message
+    * @param mixed $faultdetail detail, typically a string or array of string
+	*/
+	function nusoap_fault($faultcode,$faultactor='',$faultstring='',$faultdetail=''){
+		parent::nusoap_base();
+		$this->faultcode = $faultcode;
+		$this->faultactor = $faultactor;
+		$this->faultstring = $faultstring;
+		$this->faultdetail = $faultdetail;
+	}
+
+	/**
+	* serialize a fault
+	*
+	* @return	string	The serialization of the fault instance.
+	* @access   public
+	*/
+	function serialize(){
+		$ns_string = '';
+		foreach($this->namespaces as $k => $v){
+			$ns_string .= "\n  xmlns:$k=\"$v\"";
+		}
+		$return_msg =
+			'<?xml version="1.0" encoding="'.$this->soap_defencoding.'"?>'.
+			'<SOAP-ENV:Envelope SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"'.$ns_string.">\n".
+				'<SOAP-ENV:Body>'.
+				'<SOAP-ENV:Fault>'.
+					$this->serialize_val($this->faultcode, 'faultcode').
+					$this->serialize_val($this->faultactor, 'faultactor').
+					$this->serialize_val($this->faultstring, 'faultstring').
+					$this->serialize_val($this->faultdetail, 'detail').
+				'</SOAP-ENV:Fault>'.
+				'</SOAP-ENV:Body>'.
+			'</SOAP-ENV:Envelope>';
+		return $return_msg;
+	}
+}
+
+/**
+ * Backward compatibility
+ */
+class soap_fault extends nusoap_fault {
+}
+
+?><?php
+
+
+
+/**
+* parses an XML Schema, allows access to it's data, other utility methods.
+* imperfect, no validation... yet, but quite functional.
+*
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @version  $Id: nusoap.php,v 1.123 2010/04/26 20:15:08 snichol Exp $
+* @access   public
+*/
+class nusoap_xmlschema extends nusoap_base  {
+	
+	// files
+	var $schema = '';
+	var $xml = '';
+	// namespaces
+	var $enclosingNamespaces;
+	// schema info
+	var $schemaInfo = array();
+	var $schemaTargetNamespace = '';
+	// types, elements, attributes defined by the schema
+	var $attributes = array();
+	var $complexTypes = array();
+	var $complexTypeStack = array();
+	var $currentComplexType = null;
+	var $elements = array();
+	var $elementStack = array();
+	var $currentElement = null;
+	var $simpleTypes = array();
+	var $simpleTypeStack = array();
+	var $currentSimpleType = null;
+	// imports
+	var $imports = array();
+	// parser vars
+	var $parser;
+	var $position = 0;
+	var $depth = 0;
+	var $depth_array = array();
+	var $message = array();
+	var $defaultNamespace = array();
+    
+	/**
+	* constructor
+	*
+	* @param    string $schema schema document URI
+	* @param    string $xml xml document URI
+	* @param	string $namespaces namespaces defined in enclosing XML
+	* @access   public
+	*/
+	function nusoap_xmlschema($schema='',$xml='',$namespaces=array()){
+		parent::nusoap_base();
+		$this->debug('nusoap_xmlschema class instantiated, inside constructor');
+		// files
+		$this->schema = $schema;
+		$this->xml = $xml;
+
+		// namespaces
+		$this->enclosingNamespaces = $namespaces;
+		$this->namespaces = array_merge($this->namespaces, $namespaces);
+
+		// parse schema file
+		if($schema != ''){
+			$this->debug('initial schema file: '.$schema);
+			$this->parseFile($schema, 'schema');
+		}
+
+		// parse xml file
+		if($xml != ''){
+			$this->debug('initial xml file: '.$xml);
+			$this->parseFile($xml, 'xml');
+		}
+
+	}
+
+    /**
+    * parse an XML file
+    *
+    * @param string $xml path/URL to XML file
+    * @param string $type (schema | xml)
+	* @return boolean
+    * @access public
+    */
+	function parseFile($xml,$type){
+		// parse xml file
+		if($xml != ""){
+			$xmlStr = @join("",@file($xml));
+			if($xmlStr == ""){
+				$msg = 'Error reading XML from '.$xml;
+				$this->setError($msg);
+				$this->debug($msg);
+			return false;
+			} else {
+				$this->debug("parsing $xml");
+				$this->parseString($xmlStr,$type);
+				$this->debug("done parsing $xml");
+			return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	* parse an XML string
+	*
+	* @param    string $xml path or URL
+    * @param	string $type (schema|xml)
+	* @access   private
+	*/
+	function parseString($xml,$type){
+		// parse xml string
+		if($xml != ""){
+
+	    	// Create an XML parser.
+	    	$this->parser = xml_parser_create();
+	    	// Set the options for parsing the XML data.
+	    	xml_parser_set_option($this->parser, XML_OPTION_CASE_FOLDING, 0);
+
+	    	// Set the object for the parser.
+	    	xml_set_object($this->parser, $this);
+
+	    	// Set the element handlers for the parser.
+			if($type == "schema"){
+		    	xml_set_element_handler($this->parser, 'schemaStartElement','schemaEndElement');
+		    	xml_set_character_data_handler($this->parser,'schemaCharacterData');
+			} elseif($type == "xml"){
+				xml_set_element_handler($this->parser, 'xmlStartElement','xmlEndElement');
+		    	xml_set_character_data_handler($this->parser,'xmlCharacterData');
+			}
+
+		    // Parse the XML file.
+		    if(!xml_parse($this->parser,$xml,true)){
+			// Display an error message.
+				$errstr = sprintf('XML error parsing XML schema on line %d: %s',
+				xml_get_current_line_number($this->parser),
+				xml_error_string(xml_get_error_code($this->parser))
+				);
+				$this->debug($errstr);
+				$this->debug("XML payload:\n" . $xml);
+				$this->setError($errstr);
+	    	}
+            
+			xml_parser_free($this->parser);
+		} else{
+			$this->debug('no xml passed to parseString()!!');
+			$this->setError('no xml passed to parseString()!!');
+		}
+	}
+
+	/**
+	 * gets a type name for an unnamed type
+	 *
+	 * @param	string	Element name
+	 * @return	string	A type name for an unnamed type
+	 * @access	private
+	 */
+	function CreateTypeName($ename) {
+		$scope = '';
+		for ($i = 0; $i < count($this->complexTypeStack); $i++) {
+			$scope .= $this->complexTypeStack[$i] . '_';
+		}
+		return $scope . $ename . '_ContainedType';
+	}
+	
+	/**
+	* start-element handler
+	*
+	* @param    string $parser XML parser object
+	* @param    string $name element name
+	* @param    string $attrs associative array of attributes
+	* @access   private
+	*/
+	function schemaStartElement($parser, $name, $attrs) {
+		
+		// position in the total number of elements, starting from 0
+		$pos = $this->position++;
+		$depth = $this->depth++;
+		// set self as current value for this depth
+		$this->depth_array[$depth] = $pos;
+		$this->message[$pos] = array('cdata' => ''); 
+		if ($depth > 0) {
+			$this->defaultNamespace[$pos] = $this->defaultNamespace[$this->depth_array[$depth - 1]];
+		} else {
+			$this->defaultNamespace[$pos] = false;
+		}
+
+		// get element prefix
+		if($prefix = $this->getPrefix($name)){
+			// get unqualified name
+			$name = $this->getLocalPart($name);
+		} else {
+        	$prefix = '';
+        }
+		
+        // loop thru attributes, expanding, and registering namespace declarations
+        if(count($attrs) > 0){
+        	foreach($attrs as $k => $v){
+                // if ns declarations, add to class level array of valid namespaces
+				if(preg_match('/^xmlns/',$k)){
+                	//$this->xdebug("$k: $v");
+                	//$this->xdebug('ns_prefix: '.$this->getPrefix($k));
+                	if($ns_prefix = substr(strrchr($k,':'),1)){
+                		//$this->xdebug("Add namespace[$ns_prefix] = $v");
+						$this->namespaces[$ns_prefix] = $v;
+					} else {
+						$this->defaultNamespace[$pos] = $v;
+						if (! $this->getPrefixFromNamespace($v)) {
+							$this->namespaces['ns'.(count($this->namespaces)+1)] = $v;
+						}
+					}
+					if($v == 'http://www.w3.org/2001/XMLSchema' || $v == 'http://www.w3.org/1999/XMLSchema' || $v == 'http://www.w3.org/2000/10/XMLSchema'){
+						$this->XMLSchemaVersion = $v;
+						$this->namespaces['xsi'] = $v.'-instance';
+					}
+				}
+        	}
+        	foreach($attrs as $k => $v){
+                // expand each attribute
+                $k = strpos($k,':') ? $this->expandQname($k) : $k;
+                $v = strpos($v,':') ? $this->expandQname($v) : $v;
+        		$eAttrs[$k] = $v;
+        	}
+        	$attrs = $eAttrs;
+        } else {
+        	$attrs = array();
+        }
+		// find status, register data
+		switch($name){
+			case 'all':			// (optional) compositor content for a complexType
+			case 'choice':
+			case 'group':
+			case 'sequence':
+				//$this->xdebug("compositor $name for currentComplexType: $this->currentComplexType and currentElement: $this->currentElement");
+				$this->complexTypes[$this->currentComplexType]['compositor'] = $name;
+				//if($name == 'all' || $name == 'sequence'){
+				//	$this->complexTypes[$this->currentComplexType]['phpType'] = 'struct';
+				//}
+			break;
+			case 'attribute':	// complexType attribute
+            	//$this->xdebug("parsing attribute $attrs[name] $attrs[ref] of value: ".$attrs['http://schemas.xmlsoap.org/wsdl/:arrayType']);
+            	$this->xdebug("parsing attribute:");
+            	$this->appendDebug($this->varDump($attrs));
+				if (!isset($attrs['form'])) {
+					// TODO: handle globals
+					$attrs['form'] = $this->schemaInfo['attributeFormDefault'];
+				}
+            	if (isset($attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'])) {
+					$v = $attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'];
+					if (!strpos($v, ':')) {
+						// no namespace in arrayType attribute value...
+						if ($this->defaultNamespace[$pos]) {
+							// ...so use the default
+							$attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'] = $this->defaultNamespace[$pos] . ':' . $attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'];
+						}
+					}
+            	}
+                if(isset($attrs['name'])){
+					$this->attributes[$attrs['name']] = $attrs;
+					$aname = $attrs['name'];
+				} elseif(isset($attrs['ref']) && $attrs['ref'] == 'http://schemas.xmlsoap.org/soap/encoding/:arrayType'){
+					if (isset($attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'])) {
+	                	$aname = $attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'];
+	                } else {
+	                	$aname = '';
+	                }
+				} elseif(isset($attrs['ref'])){
+					$aname = $attrs['ref'];
+                    $this->attributes[$attrs['ref']] = $attrs;
+				}
+                
+				if($this->currentComplexType){	// This should *always* be
+					$this->complexTypes[$this->currentComplexType]['attrs'][$aname] = $attrs;
+				}
+				// arrayType attribute
+				if(isset($attrs['http://schemas.xmlsoap.org/wsdl/:arrayType']) || $this->getLocalPart($aname) == 'arrayType'){
+					$this->complexTypes[$this->currentComplexType]['phpType'] = 'array';
+                	$prefix = $this->getPrefix($aname);
+					if(isset($attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'])){
+						$v = $attrs['http://schemas.xmlsoap.org/wsdl/:arrayType'];
+					} else {
+						$v = '';
+					}
+                    if(strpos($v,'[,]')){
+                        $this->complexTypes[$this->currentComplexType]['multidimensional'] = true;
+                    }
+                    $v = substr($v,0,strpos($v,'[')); // clip the []
+                    if(!strpos($v,':') && isset($this->typemap[$this->XMLSchemaVersion][$v])){
+                        $v = $this->XMLSchemaVersion.':'.$v;
+                    }
+                    $this->complexTypes[$this->currentComplexType]['arrayType'] = $v;
+				}
+			break;
+			case 'complexContent':	// (optional) content for a complexType
+				$this->xdebug("do nothing for element $name");
+			break;
+			case 'complexType':
+				array_push($this->complexTypeStack, $this->currentComplexType);
+				if(isset($attrs['name'])){
+					// TODO: what is the scope of named complexTypes that appear
+					//       nested within other c complexTypes?
+					$this->xdebug('processing named complexType '.$attrs['name']);
+					//$this->currentElement = false;
+					$this->currentComplexType = $attrs['name'];
+					$this->complexTypes[$this->currentComplexType] = $attrs;
+					$this->complexTypes[$this->currentComplexType]['typeClass'] = 'complexType';
+					// This is for constructs like
+					//           <complexType name="ListOfString" base="soap:Array">
+					//                <sequence>
+					//                    <element name="string" type="xsd:string"
+					//                        minOccurs="0" maxOccurs="unbounded" />
+					//                </sequence>
+					//            </complexType>
+					if(isset($attrs['base']) && preg_match('/:Array$/',$attrs['base'])){
+						$this->xdebug('complexType is unusual array');
+						$this->complexTypes[$this->currentComplexType]['phpType'] = 'array';
+					} else {
+						$this->complexTypes[$this->currentComplexType]['phpType'] = 'struct';
+					}
+				} else {
+					$name = $this->CreateTypeName($this->currentElement);
+					$this->xdebug('processing unnamed complexType for element ' . $this->currentElement . ' named ' . $name);
+					$this->currentComplexType = $name;
+					//$this->currentElement = false;
+					$this->complexTypes[$this->currentComplexType] = $attrs;
+					$this->complexTypes[$this->currentComplexType]['typeClass'] = 'complexType';
+					// This is for constructs like
+					//           <complexType name="ListOfString" base="soap:Array">
+					//                <sequence>
+					//                    <element name="string" type="xsd:string"
+					//                        minOccurs="0" maxOccurs="unbounded" />
+					//                </sequence>
+					//            </complexType>
+					if(isset($attrs['base']) && preg_match('/:Array$/',$attrs['base'])){
+						$this->xdebug('complexType is unusual array');
+						$this->complexTypes[$this->currentComplexType]['phpType'] = 'array';
+					} else {
+						$this->complexTypes[$this->currentComplexType]['phpType'] = 'struct';
+					}
+				}
+				$this->complexTypes[$this->currentComplexType]['simpleContent'] = 'false';
+			break;
+			case 'element':
+				array_push($this->elementStack, $this->currentElement);
+				if (!isset($attrs['form'])) {
+					if ($this->currentComplexType) {
+						$attrs['form'] = $this->schemaInfo['elementFormDefault'];
+					} else {
+						// global
+						$attrs['form'] = 'qualified';
+					}
+				}
+				if(isset($attrs['type'])){
+					$this->xdebug("processing typed element ".$attrs['name']." of type ".$attrs['type']);
+					if (! $this->getPrefix($attrs['type'])) {
+						if ($this->defaultNamespace[$pos]) {
+							$attrs['type'] = $this->defaultNamespace[$pos] . ':' . $attrs['type'];
+							$this->xdebug('used default namespace to make type ' . $attrs['type']);
+						}
+					}
+					// This is for constructs like
+					//           <complexType name="ListOfString" base="soap:Array">
+					//                <sequence>
+					//                    <element name="string" type="xsd:string"
+					//                        minOccurs="0" maxOccurs="unbounded" />
+					//                </sequence>
+					//            </complexType>
+					if ($this->currentComplexType && $this->complexTypes[$this->currentComplexType]['phpType'] == 'array') {
+						$this->xdebug('arrayType for unusual array is ' . $attrs['type']);
+						$this->complexTypes[$this->currentComplexType]['arrayType'] = $attrs['type'];
+					}
+					$this->currentElement = $attrs['name'];
+					$ename = $attrs['name'];
+				} elseif(isset($attrs['ref'])){
+					$this->xdebug("processing element as ref to ".$attrs['ref']);
+					$this->currentElement = "ref to ".$attrs['ref'];
+					$ename = $this->getLocalPart($attrs['ref']);
+				} else {
+					$type = $this->CreateTypeName($this->currentComplexType . '_' . $attrs['name']);
+					$this->xdebug("processing untyped element " . $attrs['name'] . ' type ' . $type);
+					$this->currentElement = $attrs['name'];
+					$attrs['type'] = $this->schemaTargetNamespace . ':' . $type;
+					$ename = $attrs['name'];
+				}
+				if (isset($ename) && $this->currentComplexType) {
+					$this->xdebug("add element $ename to complexType $this->currentComplexType");
+					$this->complexTypes[$this->currentComplexType]['elements'][$ename] = $attrs;
+				} elseif (!isset($attrs['ref'])) {
+					$this->xdebug("add element $ename to elements array");
+					$this->elements[ $attrs['name'] ] = $attrs;
+					$this->elements[ $attrs['name'] ]['typeClass'] = 'element';
+				}
+			break;
+			case 'enumeration':	//	restriction value list member
+				$this->xdebug('enumeration ' . $attrs['value']);
+				if ($this->currentSimpleType) {
+					$this->simpleTypes[$this->currentSimpleType]['enumeration'][] = $attrs['value'];
+				} elseif ($this->currentComplexType) {
+					$this->complexTypes[$this->currentComplexType]['enumeration'][] = $attrs['value'];
+				}
+			break;
+			case 'extension':	// simpleContent or complexContent type extension
+				$this->xdebug('extension ' . $attrs['base']);
+				if ($this->currentComplexType) {
+					$ns = $this->getPrefix($attrs['base']);
+					if ($ns == '') {
+						$this->complexTypes[$this->currentComplexType]['extensionBase'] = $this->schemaTargetNamespace . ':' . $attrs['base'];
+					} else {
+						$this->complexTypes[$this->currentComplexType]['extensionBase'] = $attrs['base'];
+					}
+				} else {
+					$this->xdebug('no current complexType to set extensionBase');
+				}
+			break;
+			case 'import':
+			    if (isset($attrs['schemaLocation'])) {
+					$this->xdebug('import namespace ' . $attrs['namespace'] . ' from ' . $attrs['schemaLocation']);
+                    $this->imports[$attrs['namespace']][] = array('location' => $attrs['schemaLocation'], 'loaded' => false);
+				} else {
+					$this->xdebug('import namespace ' . $attrs['namespace']);
+                    $this->imports[$attrs['namespace']][] = array('location' => '', 'loaded' => true);
+					if (! $this->getPrefixFromNamespace($attrs['namespace'])) {
+						$this->namespaces['ns'.(count($this->namespaces)+1)] = $attrs['namespace'];
+					}
+				}
+			break;
+			case 'include':
+			    if (isset($attrs['schemaLocation'])) {
+					$this->xdebug('include into namespace ' . $this->schemaTargetNamespace . ' from ' . $attrs['schemaLocation']);
+                    $this->imports[$this->schemaTargetNamespace][] = array('location' => $attrs['schemaLocation'], 'loaded' => false);
+				} else {
+					$this->xdebug('ignoring invalid XML Schema construct: include without schemaLocation attribute');
+				}
+			break;
+			case 'list':	// simpleType value list
+				$this->xdebug("do nothing for element $name");
+			break;
+			case 'restriction':	// simpleType, simpleContent or complexContent value restriction
+				$this->xdebug('restriction ' . $attrs['base']);
+				if($this->currentSimpleType){
+					$this->simpleTypes[$this->currentSimpleType]['type'] = $attrs['base'];
+				} elseif($this->currentComplexType){
+					$this->complexTypes[$this->currentComplexType]['restrictionBase'] = $attrs['base'];
+					if(strstr($attrs['base'],':') == ':Array'){
+						$this->complexTypes[$this->currentComplexType]['phpType'] = 'array';
+					}
+				}
+			break;
+			case 'schema':
+				$this->schemaInfo = $attrs;
+				$this->schemaInfo['schemaVersion'] = $this->getNamespaceFromPrefix($prefix);
+				if (isset($attrs['targetNamespace'])) {
+					$this->schemaTargetNamespace = $attrs['targetNamespace'];
+				}
+				if (!isset($attrs['elementFormDefault'])) {
+					$this->schemaInfo['elementFormDefault'] = 'unqualified';
+				}
+				if (!isset($attrs['attributeFormDefault'])) {
+					$this->schemaInfo['attributeFormDefault'] = 'unqualified';
+				}
+			break;
+			case 'simpleContent':	// (optional) content for a complexType
+				if ($this->currentComplexType) {	// This should *always* be
+					$this->complexTypes[$this->currentComplexType]['simpleContent'] = 'true';
+				} else {
+					$this->xdebug("do nothing for element $name because there is no current complexType");
+				}
+			break;
+			case 'simpleType':
+				array_push($this->simpleTypeStack, $this->currentSimpleType);
+				if(isset($attrs['name'])){
+					$this->xdebug("processing simpleType for name " . $attrs['name']);
+					$this->currentSimpleType = $attrs['name'];
+					$this->simpleTypes[ $attrs['name'] ] = $attrs;
+					$this->simpleTypes[ $attrs['name'] ]['typeClass'] = 'simpleType';
+					$this->simpleTypes[ $attrs['name'] ]['phpType'] = 'scalar';
+				} else {
+					$name = $this->CreateTypeName($this->currentComplexType . '_' . $this->currentElement);
+					$this->xdebug('processing unnamed simpleType for element ' . $this->currentElement . ' named ' . $name);
+					$this->currentSimpleType = $name;
+					//$this->currentElement = false;
+					$this->simpleTypes[$this->currentSimpleType] = $attrs;
+					$this->simpleTypes[$this->currentSimpleType]['phpType'] = 'scalar';
+				}
+			break;
+			case 'union':	// simpleType type list
+				$this->xdebug("do nothing for element $name");
+			break;
+			default:
+				$this->xdebug("do not have any logic to process element $name");
+		}
+	}
+
+	/**
+	* end-element handler
+	*
+	* @param    string $parser XML parser object
+	* @param    string $name element name
+	* @access   private
+	*/
+	function schemaEndElement($parser, $name) {
+		// bring depth down a notch
+		$this->depth--;
+		// position of current element is equal to the last value left in depth_array for my depth
+		if(isset($this->depth_array[$this->depth])){
+        	$pos = $this->depth_array[$this->depth];
+        }
+		// get element prefix
+		if ($prefix = $this->getPrefix($name)){
+			// get unqualified name
+			$name = $this->getLocalPart($name);
+		} else {
+        	$prefix = '';
+        }
+		// move on...
+		if($name == 'complexType'){
+			$this->xdebug('done processing complexType ' . ($this->currentComplexType ? $this->currentComplexType : '(unknown)'));
+			$this->xdebug($this->varDump($this->complexTypes[$this->currentComplexType]));
+			$this->currentComplexType = array_pop($this->complexTypeStack);
+			//$this->currentElement = false;
+		}
+		if($name == 'element'){
+			$this->xdebug('done processing element ' . ($this->currentElement ? $this->currentElement : '(unknown)'));
+			$this->currentElement = array_pop($this->elementStack);
+		}
+		if($name == 'simpleType'){
+			$this->xdebug('done processing simpleType ' . ($this->currentSimpleType ? $this->currentSimpleType : '(unknown)'));
+			$this->xdebug($this->varDump($this->simpleTypes[$this->currentSimpleType]));
+			$this->currentSimpleType = array_pop($this->simpleTypeStack);
+		}
+	}
+
+	/**
+	* element content handler
+	*
+	* @param    string $parser XML parser object
+	* @param    string $data element content
+	* @access   private
+	*/
+	function schemaCharacterData($parser, $data){
+		$pos = $this->depth_array[$this->depth - 1];
+		$this->message[$pos]['cdata'] .= $data;
+	}
+
+	/**
+	* serialize the schema
+	*
+	* @access   public
+	*/
+	function serializeSchema(){
+
+		$schemaPrefix = $this->getPrefixFromNamespace($this->XMLSchemaVersion);
+		$xml = '';
+		// imports
+		if (sizeof($this->imports) > 0) {
+			foreach($this->imports as $ns => $list) {
+				foreach ($list as $ii) {
+					if ($ii['location'] != '') {
+						$xml .= " <$schemaPrefix:import location=\"" . $ii['location'] . '" namespace="' . $ns . "\" />\n";
+					} else {
+						$xml .= " <$schemaPrefix:import namespace=\"" . $ns . "\" />\n";
+					}
+				}
+			} 
+		} 
+		// complex types
+		foreach($this->complexTypes as $typeName => $attrs){
+			$contentStr = '';
+			// serialize child elements
+			if(isset($attrs['elements']) && (count($attrs['elements']) > 0)){
+				foreach($attrs['elements'] as $element => $eParts){
+					if(isset($eParts['ref'])){
+						$contentStr .= "   <$schemaPrefix:element ref=\"$element\"/>\n";
+					} else {
+						$contentStr .= "   <$schemaPrefix:element name=\"$element\" type=\"" . $this->contractQName($eParts['type']) . "\"";
+						foreach ($eParts as $aName => $aValue) {
+							// handle, e.g., abstract, default, form, minOccurs, maxOccurs, nillable
+							if ($aName != 'name' && $aName != 'type') {
+								$contentStr .= " $aName=\"$aValue\"";
+							}
+						}
+						$contentStr .= "/>\n";
+					}
+				}
+				// compositor wraps elements
+				if (isset($attrs['compositor']) && ($attrs['compositor'] != '')) {
+					$contentStr = "  <$schemaPrefix:$attrs[compositor]>\n".$contentStr."  </$schemaPrefix:$attrs[compositor]>\n";
+				}
+			}
+			// attributes
+			if(isset($attrs['attrs']) && (count($attrs['attrs']) >= 1)){
+				foreach($attrs['attrs'] as $attr => $aParts){
+					$contentStr .= "    <$schemaPrefix:attribute";
+					foreach ($aParts as $a => $v) {
+						if ($a == 'ref' || $a == 'type') {
+							$contentStr .= " $a=\"".$this->contractQName($v).'"';
+						} elseif ($a == 'http://schemas.xmlsoap.org/wsdl/:arrayType') {
+							$this->usedNamespaces['wsdl'] = $this->namespaces['wsdl'];
+							$contentStr .= ' wsdl:arrayType="'.$this->contractQName($v).'"';
+						} else {
+							$contentStr .= " $a=\"$v\"";
+						}
+					}
+					$contentStr .= "/>\n";
+				}
+			}
+			// if restriction
+			if (isset($attrs['restrictionBase']) && $attrs['restrictionBase'] != ''){
+				$contentStr = "   <$schemaPrefix:restriction base=\"".$this->contractQName($attrs['restrictionBase'])."\">\n".$contentStr."   </$schemaPrefix:restriction>\n";
+				// complex or simple content
+				if ((isset($attrs['elements']) && count($attrs['elements']) > 0) || (isset($attrs['attrs']) && count($attrs['attrs']) > 0)){
+					$contentStr = "  <$schemaPrefix:complexContent>\n".$contentStr."  </$schemaPrefix:complexContent>\n";
+				}
+			}
+			// finalize complex type
+			if($contentStr != ''){
+				$contentStr = " <$schemaPrefix:complexType name=\"$typeName\">\n".$contentStr." </$schemaPrefix:complexType>\n";
+			} else {
+				$contentStr = " <$schemaPrefix:complexType name=\"$typeName\"/>\n";
+			}
+			$xml .= $contentStr;
+		}
+		// simple types
+		if(isset($this->simpleTypes) && count($this->simpleTypes) > 0){
+			foreach($this->simpleTypes as $typeName => $eParts){
+				$xml .= " <$schemaPrefix:simpleType name=\"$typeName\">\n  <$schemaPrefix:restriction base=\"".$this->contractQName($eParts['type'])."\">\n";
+				if (isset($eParts['enumeration'])) {
+					foreach ($eParts['enumeration'] as $e) {
+						$xml .= "  <$schemaPrefix:enumeration value=\"$e\"/>\n";
+					}
+				}
+				$xml .= "  </$schemaPrefix:restriction>\n </$schemaPrefix:simpleType>";
+			}
+		}
+		// elements
+		if(isset($this->elements) && count($this->elements) > 0){
+			foreach($this->elements as $element => $eParts){
+				$xml .= " <$schemaPrefix:element name=\"$element\" type=\"".$this->contractQName($eParts['type'])."\"/>\n";
+			}
+		}
+		// attributes
+		if(isset($this->attributes) && count($this->attributes) > 0){
+			foreach($this->attributes as $attr => $aParts){
+				$xml .= " <$schemaPrefix:attribute name=\"$attr\" type=\"".$this->contractQName($aParts['type'])."\"\n/>";
+			}
+		}
+		// finish 'er up
+		$attr = '';
+		foreach ($this->schemaInfo as $k => $v) {
+			if ($k == 'elementFormDefault' || $k == 'attributeFormDefault') {
+				$attr .= " $k=\"$v\"";
+			}
+		}
+		$el = "<$schemaPrefix:schema$attr targetNamespace=\"$this->schemaTargetNamespace\"\n";
+		foreach (array_diff($this->usedNamespaces, $this->enclosingNamespaces) as $nsp => $ns) {
+			$el .= " xmlns:$nsp=\"$ns\"";
+		}
+		$xml = $el . ">\n".$xml."</$schemaPrefix:schema>\n";
+		return $xml;
+	}
+
+	/**
+	* adds debug data to the clas level debug string
+	*
+	* @param    string $string debug data
+	* @access   private
+	*/
+	function xdebug($string){
+		$this->debug('<' . $this->schemaTargetNamespace . '> '.$string);
+	}
+
+    /**
+    * get the PHP type of a user defined type in the schema
+    * PHP type is kind of a misnomer since it actually returns 'struct' for assoc. arrays
+    * returns false if no type exists, or not w/ the given namespace
+    * else returns a string that is either a native php type, or 'struct'
+    *
+    * @param string $type name of defined type
+    * @param string $ns namespace of type
+    * @return mixed
+    * @access public
+    * @deprecated
+    */
+	function getPHPType($type,$ns){
+		if(isset($this->typemap[$ns][$type])){
+			//print "found type '$type' and ns $ns in typemap<br>";
+			return $this->typemap[$ns][$type];
+		} elseif(isset($this->complexTypes[$type])){
+			//print "getting type '$type' and ns $ns from complexTypes array<br>";
+			return $this->complexTypes[$type]['phpType'];
+		}
+		return false;
+	}
+
+	/**
+    * returns an associative array of information about a given type
+    * returns false if no type exists by the given name
+    *
+	*	For a complexType typeDef = array(
+	*	'restrictionBase' => '',
+	*	'phpType' => '',
+	*	'compositor' => '(sequence|all)',
+	*	'elements' => array(), // refs to elements array
+	*	'attrs' => array() // refs to attributes array
+	*	... and so on (see addComplexType)
+	*	)
+	*
+	*   For simpleType or element, the array has different keys.
+    *
+    * @param string $type
+    * @return mixed
+    * @access public
+    * @see addComplexType
+    * @see addSimpleType
+    * @see addElement
+    */
+	function getTypeDef($type){
+		//$this->debug("in getTypeDef for type $type");
+		if (substr($type, -1) == '^') {
+			$is_element = 1;
+			$type = substr($type, 0, -1);
+		} else {
+			$is_element = 0;
+		}
+
+		if((! $is_element) && isset($this->complexTypes[$type])){
+			$this->xdebug("in getTypeDef, found complexType $type");
+			return $this->complexTypes[$type];
+		} elseif((! $is_element) && isset($this->simpleTypes[$type])){
+			$this->xdebug("in getTypeDef, found simpleType $type");
+			if (!isset($this->simpleTypes[$type]['phpType'])) {
+				// get info for type to tack onto the simple type
+				// TODO: can this ever really apply (i.e. what is a simpleType really?)
+				$uqType = substr($this->simpleTypes[$type]['type'], strrpos($this->simpleTypes[$type]['type'], ':') + 1);
+				$ns = substr($this->simpleTypes[$type]['type'], 0, strrpos($this->simpleTypes[$type]['type'], ':'));
+				$etype = $this->getTypeDef($uqType);
+				if ($etype) {
+					$this->xdebug("in getTypeDef, found type for simpleType $type:");
+					$this->xdebug($this->varDump($etype));
+					if (isset($etype['phpType'])) {
+						$this->simpleTypes[$type]['phpType'] = $etype['phpType'];
+					}
+					if (isset($etype['elements'])) {
+						$this->simpleTypes[$type]['elements'] = $etype['elements'];
+					}
+				}
+			}
+			return $this->simpleTypes[$type];
+		} elseif(isset($this->elements[$type])){
+			$this->xdebug("in getTypeDef, found element $type");
+			if (!isset($this->elements[$type]['phpType'])) {
+				// get info for type to tack onto the element
+				$uqType = substr($this->elements[$type]['type'], strrpos($this->elements[$type]['type'], ':') + 1);
+				$ns = substr($this->elements[$type]['type'], 0, strrpos($this->elements[$type]['type'], ':'));
+				$etype = $this->getTypeDef($uqType);
+				if ($etype) {
+					$this->xdebug("in getTypeDef, found type for element $type:");
+					$this->xdebug($this->varDump($etype));
+					if (isset($etype['phpType'])) {
+						$this->elements[$type]['phpType'] = $etype['phpType'];
+					}
+					if (isset($etype['elements'])) {
+						$this->elements[$type]['elements'] = $etype['elements'];
+					}
+					if (isset($etype['extensionBase'])) {
+						$this->elements[$type]['extensionBase'] = $etype['extensionBase'];
+					}
+				} elseif ($ns == 'http://www.w3.org/2001/XMLSchema') {
+					$this->xdebug("in getTypeDef, element $type is an XSD type");
+					$this->elements[$type]['phpType'] = 'scalar';
+				}
+			}
+			return $this->elements[$type];
+		} elseif(isset($this->attributes[$type])){
+			$this->xdebug("in getTypeDef, found attribute $type");
+			return $this->attributes[$type];
+		} elseif (preg_match('/_ContainedType$/', $type)) {
+			$this->xdebug("in getTypeDef, have an untyped element $type");
+			$typeDef['typeClass'] = 'simpleType';
+			$typeDef['phpType'] = 'scalar';
+			$typeDef['type'] = 'http://www.w3.org/2001/XMLSchema:string';
+			return $typeDef;
+		}
+		$this->xdebug("in getTypeDef, did not find $type");
+		return false;
+	}
+
+	/**
+    * returns a sample serialization of a given type, or false if no type by the given name
+    *
+    * @param string $type name of type
+    * @return mixed
+    * @access public
+    * @deprecated
+    */
+    function serializeTypeDef($type){
+    	//print "in sTD() for type $type<br>";
+	if($typeDef = $this->getTypeDef($type)){
+		$str .= '<'.$type;
+	    if(is_array($typeDef['attrs'])){
+		foreach($typeDef['attrs'] as $attName => $data){
+		    $str .= " $attName=\"{type = ".$data['type']."}\"";
+		}
+	    }
+	    $str .= " xmlns=\"".$this->schema['targetNamespace']."\"";
+	    if(count($typeDef['elements']) > 0){
+		$str .= ">";
+		foreach($typeDef['elements'] as $element => $eData){
+		    $str .= $this->serializeTypeDef($element);
+		}
+		$str .= "</$type>";
+	    } elseif($typeDef['typeClass'] == 'element') {
+		$str .= "></$type>";
+	    } else {
+		$str .= "/>";
+	    }
+			return $str;
+	}
+    	return false;
+    }
+
+    /**
+    * returns HTML form elements that allow a user
+    * to enter values for creating an instance of the given type.
+    *
+    * @param string $name name for type instance
+    * @param string $type name of type
+    * @return string
+    * @access public
+    * @deprecated
+	*/
+	function typeToForm($name,$type){
+		// get typedef
+		if($typeDef = $this->getTypeDef($type)){
+			// if struct
+			if($typeDef['phpType'] == 'struct'){
+				$buffer .= '<table>';
+				foreach($typeDef['elements'] as $child => $childDef){
+					$buffer .= "
+					<tr><td align='right'>$childDef[name] (type: ".$this->getLocalPart($childDef['type'])."):</td>
+					<td><input type='text' name='parameters[".$name."][$childDef[name]]'></td></tr>";
+				}
+				$buffer .= '</table>';
+			// if array
+			} elseif($typeDef['phpType'] == 'array'){
+				$buffer .= '<table>';
+				for($i=0;$i < 3; $i++){
+					$buffer .= "
+					<tr><td align='right'>array item (type: $typeDef[arrayType]):</td>
+					<td><input type='text' name='parameters[".$name."][]'></td></tr>";
+				}
+				$buffer .= '</table>';
+			// if scalar
+			} else {
+				$buffer .= "<input type='text' name='parameters[$name]'>";
+			}
+		} else {
+			$buffer .= "<input type='text' name='parameters[$name]'>";
+		}
+		return $buffer;
+	}
+	
+	/**
+	* adds a complex type to the schema
+	* 
+	* example: array
+	* 
+	* addType(
+	* 	'ArrayOfstring',
+	* 	'complexType',
+	* 	'array',
+	* 	'',
+	* 	'SOAP-ENC:Array',
+	* 	array('ref'=>'SOAP-ENC:arrayType','wsdl:arrayType'=>'string[]'),
+	* 	'xsd:string'
+	* );
+	* 
+	* example: PHP associative array ( SOAP Struct )
+	* 
+	* addType(
+	* 	'SOAPStruct',
+	* 	'complexType',
+	* 	'struct',
+	* 	'all',
+	* 	array('myVar'=> array('name'=>'myVar','type'=>'string')
+	* );
+	* 
+	* @param name
+	* @param typeClass (complexType|simpleType|attribute)
+	* @param phpType: currently supported are array and struct (php assoc array)
+	* @param compositor (all|sequence|choice)
+	* @param restrictionBase namespace:name (http://schemas.xmlsoap.org/soap/encoding/:Array)
+	* @param elements = array ( name = array(name=>'',type=>'') )
+	* @param attrs = array(
+	* 	array(
+	*		'ref' => "http://schemas.xmlsoap.org/soap/encoding/:arrayType",
+	*		"http://schemas.xmlsoap.org/wsdl/:arrayType" => "string[]"
+	* 	)
+	* )
+	* @param arrayType: namespace:name (http://www.w3.org/2001/XMLSchema:string)
+	* @access public
+	* @see getTypeDef
+	*/
+	function addComplexType($name,$typeClass='complexType',$phpType='array',$compositor='',$restrictionBase='',$elements=array(),$attrs=array(),$arrayType=''){
+		$this->complexTypes[$name] = array(
+	    'name'		=> $name,
+	    'typeClass'	=> $typeClass,
+	    'phpType'	=> $phpType,
+		'compositor'=> $compositor,
+	    'restrictionBase' => $restrictionBase,
+		'elements'	=> $elements,
+	    'attrs'		=> $attrs,
+	    'arrayType'	=> $arrayType
+		);
+		
+		$this->xdebug("addComplexType $name:");
+		$this->appendDebug($this->varDump($this->complexTypes[$name]));
+	}
+	
+	/**
+	* adds a simple type to the schema
+	*
+	* @param string $name
+	* @param string $restrictionBase namespace:name (http://schemas.xmlsoap.org/soap/encoding/:Array)
+	* @param string $typeClass (should always be simpleType)
+	* @param string $phpType (should always be scalar)
+	* @param array $enumeration array of values
+	* @access public
+	* @see nusoap_xmlschema
+	* @see getTypeDef
+	*/
+	function addSimpleType($name, $restrictionBase='', $typeClass='simpleType', $phpType='scalar', $enumeration=array()) {
+		$this->simpleTypes[$name] = array(
+	    'name'			=> $name,
+	    'typeClass'		=> $typeClass,
+	    'phpType'		=> $phpType,
+	    'type'			=> $restrictionBase,
+	    'enumeration'	=> $enumeration
+		);
+		
+		$this->xdebug("addSimpleType $name:");
+		$this->appendDebug($this->varDump($this->simpleTypes[$name]));
+	}
+
+	/**
+	* adds an element to the schema
+	*
+	* @param array $attrs attributes that must include name and type
+	* @see nusoap_xmlschema
+	* @access public
+	*/
+	function addElement($attrs) {
+		if (! $this->getPrefix($attrs['type'])) {
+			$attrs['type'] = $this->schemaTargetNamespace . ':' . $attrs['type'];
+		}
+		$this->elements[ $attrs['name'] ] = $attrs;
+		$this->elements[ $attrs['name'] ]['typeClass'] = 'element';
+		
+		$this->xdebug("addElement " . $attrs['name']);
+		$this->appendDebug($this->varDump($this->elements[ $attrs['name'] ]));
+	}
+}
+
+/**
+ * Backward compatibility
+ */
+class XMLSchema extends nusoap_xmlschema {
+}
+
+?><?php
+
+
+
+/**
+* For creating serializable abstractions of native PHP types.  This class
+* allows element name/namespace, XSD type, and XML attributes to be
+* associated with a value.  This is extremely useful when WSDL is not
+* used, but is also useful when WSDL is used with polymorphic types, including
+* xsd:anyType and user-defined types.
+*
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @version  $Id: nusoap.php,v 1.123 2010/04/26 20:15:08 snichol Exp $
+* @access   public
+*/
+class soapval extends nusoap_base {
+	/**
+	 * The XML element name
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $name;
+	/**
+	 * The XML type name (string or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $type;
+	/**
+	 * The PHP value
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $value;
+	/**
+	 * The XML element namespace (string or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $element_ns;
+	/**
+	 * The XML type namespace (string or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $type_ns;
+	/**
+	 * The XML element attributes (array or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $attributes;
+
+	/**
+	* constructor
+	*
+	* @param    string $name optional name
+	* @param    mixed $type optional type name
+	* @param	mixed $value optional value
+	* @param	mixed $element_ns optional namespace of value
+	* @param	mixed $type_ns optional namespace of type
+	* @param	mixed $attributes associative array of attributes to add to element serialization
+	* @access   public
+	*/
+  	function soapval($name='soapval',$type=false,$value=-1,$element_ns=false,$type_ns=false,$attributes=false) {
+		parent::nusoap_base();
+		$this->name = $name;
+		$this->type = $type;
+		$this->value = $value;
+		$this->element_ns = $element_ns;
+		$this->type_ns = $type_ns;
+		$this->attributes = $attributes;
+    }
+
+	/**
+	* return serialized value
+	*
+	* @param	string $use The WSDL use value (encoded|literal)
+	* @return	string XML data
+	* @access   public
+	*/
+	function serialize($use='encoded') {
+		return $this->serialize_val($this->value, $this->name, $this->type, $this->element_ns, $this->type_ns, $this->attributes, $use, true);
+    }
+
+	/**
+	* decodes a soapval object into a PHP native type
+	*
+	* @return	mixed
+	* @access   public
+	*/
+	function decode(){
+		return $this->value;
+	}
+}
+
+
+
+?><?php
+
+
+
+/**
+* transport class for sending/receiving data via HTTP and HTTPS
+* NOTE: PHP must be compiled with the CURL extension for HTTPS support
+*
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @version  $Id: nusoap.php,v 1.123 2010/04/26 20:15:08 snichol Exp $
+* @access public
+*/
+class soap_transport_http extends nusoap_base {
+
+	var $url = '';
+	var $uri = '';
+	var $digest_uri = '';
+	var $scheme = '';
+	var $host = '';
+	var $port = '';
+	var $path = '';
+	var $request_method = 'POST';
+	var $protocol_version = '1.0';
+	var $encoding = '';
+	var $outgoing_headers = array();
+	var $incoming_headers = array();
+	var $incoming_cookies = array();
+	var $outgoing_payload = '';
+	var $incoming_payload = '';
+	var $response_status_line;	// HTTP response status line
+	var $useSOAPAction = true;
+	var $persistentConnection = false;
+	var $ch = false;	// cURL handle
+	var $ch_options = array();	// cURL custom options
+	var $use_curl = false;		// force cURL use
+	var $proxy = null;			// proxy information (associative array)
+	var $username = '';
+	var $password = '';
+	var $authtype = '';
+	var $digestRequest = array();
+	var $certRequest = array();	// keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, certpassword (optional), verifypeer (optional), verifyhost (optional)
+								// cainfofile: certificate authority file, e.g. '$pathToPemFiles/rootca.pem'
+								// sslcertfile: SSL certificate file, e.g. '$pathToPemFiles/mycert.pem'
+								// sslkeyfile: SSL key file, e.g. '$pathToPemFiles/mykey.pem'
+								// passphrase: SSL key password/passphrase
+								// certpassword: SSL certificate password
+								// verifypeer: default is 1
+								// verifyhost: default is 1
+
+	/**
+	* constructor
+	*
+	* @param string $url The URL to which to connect
+	* @param array $curl_options User-specified cURL options
+	* @param boolean $use_curl Whether to try to force cURL use
+	* @access public
+	*/
+	function soap_transport_http($url, $curl_options = NULL, $use_curl = false){
+		parent::nusoap_base();
+		$this->debug("ctor url=$url use_curl=$use_curl curl_options:");
+		$this->appendDebug($this->varDump($curl_options));
+		$this->setURL($url);
+		if (is_array($curl_options)) {
+			$this->ch_options = $curl_options;
+		}
+		$this->use_curl = $use_curl;
+		preg_match('/\$Revisio' . 'n: ([^ ]+)/', $this->revision, $rev);
+		$this->setHeader('User-Agent', $this->title.'/'.$this->version.' ('.$rev[1].')');
+	}
+
+	/**
+	* sets a cURL option
+	*
+	* @param	mixed $option The cURL option (always integer?)
+	* @param	mixed $value The cURL option value
+	* @access   private
+	*/
+	function setCurlOption($option, $value) {
+		$this->debug("setCurlOption option=$option, value=");
+		$this->appendDebug($this->varDump($value));
+		curl_setopt($this->ch, $option, $value);
+	}
+
+	/**
+	* sets an HTTP header
+	*
+	* @param string $name The name of the header
+	* @param string $value The value of the header
+	* @access private
+	*/
+	function setHeader($name, $value) {
+		$this->outgoing_headers[$name] = $value;
+		$this->debug("set header $name: $value");
+	}
+
+	/**
+	* unsets an HTTP header
+	*
+	* @param string $name The name of the header
+	* @access private
+	*/
+	function unsetHeader($name) {
+		if (isset($this->outgoing_headers[$name])) {
+			$this->debug("unset header $name");
+			unset($this->outgoing_headers[$name]);
+		}
+	}
+
+	/**
+	* sets the URL to which to connect
+	*
+	* @param string $url The URL to which to connect
+	* @access private
+	*/
+	function setURL($url) {
+		$this->url = $url;
+
+		$u = parse_url($url);
+		foreach($u as $k => $v){
+			$this->debug("parsed URL $k = $v");
+			$this->$k = $v;
+		}
+		
+		// add any GET params to path
+		if(isset($u['query']) && $u['query'] != ''){
+            $this->path .= '?' . $u['query'];
+		}
+		
+		// set default port
+		if(!isset($u['port'])){
+			if($u['scheme'] == 'https'){
+				$this->port = 443;
+			} else {
+				$this->port = 80;
+			}
+		}
+		
+		$this->uri = $this->path;
+		$this->digest_uri = $this->uri;
+		
+		// build headers
+		if (!isset($u['port'])) {
+			$this->setHeader('Host', $this->host);
+		} else {
+			$this->setHeader('Host', $this->host.':'.$this->port);
+		}
+
+		if (isset($u['user']) && $u['user'] != '') {
+			$this->setCredentials(urldecode($u['user']), isset($u['pass']) ? urldecode($u['pass']) : '');
+		}
+	}
+
+	/**
+	* gets the I/O method to use
+	*
+	* @return	string	I/O method to use (socket|curl|unknown)
+	* @access	private
+	*/
+	function io_method() {
+		if ($this->use_curl || ($this->scheme == 'https') || ($this->scheme == 'http' && $this->authtype == 'ntlm') || ($this->scheme == 'http' && is_array($this->proxy) && $this->proxy['authtype'] == 'ntlm'))
+			return 'curl';
+		if (($this->scheme == 'http' || $this->scheme == 'ssl') && $this->authtype != 'ntlm' && (!is_array($this->proxy) || $this->proxy['authtype'] != 'ntlm'))
+			return 'socket';
+		return 'unknown';
+	}
+
+	/**
+	* establish an HTTP connection
+	*
+	* @param    integer $timeout set connection timeout in seconds
+	* @param	integer $response_timeout set response timeout in seconds
+	* @return	boolean true if connected, false if not
+	* @access   private
+	*/
+	function connect($connection_timeout=0,$response_timeout=30){
+	  	// For PHP 4.3 with OpenSSL, change https scheme to ssl, then treat like
+	  	// "regular" socket.
+	  	// TODO: disabled for now because OpenSSL must be *compiled* in (not just
+	  	//       loaded), and until PHP5 stream_get_wrappers is not available.
+//	  	if ($this->scheme == 'https') {
+//		  	if (version_compare(phpversion(), '4.3.0') >= 0) {
+//		  		if (extension_loaded('openssl')) {
+//		  			$this->scheme = 'ssl';
+//		  			$this->debug('Using SSL over OpenSSL');
+//		  		}
+//		  	}
+//		}
+		$this->debug("connect connection_timeout $connection_timeout, response_timeout $response_timeout, scheme $this->scheme, host $this->host, port $this->port");
+	  if ($this->io_method() == 'socket') {
+		if (!is_array($this->proxy)) {
+			$host = $this->host;
+			$port = $this->port;
+		} else {
+			$host = $this->proxy['host'];
+			$port = $this->proxy['port'];
+		}
+
+		// use persistent connection
+		if($this->persistentConnection && isset($this->fp) && is_resource($this->fp)){
+			if (!feof($this->fp)) {
+				$this->debug('Re-use persistent connection');
+				return true;
+			}
+			fclose($this->fp);
+			$this->debug('Closed persistent connection at EOF');
+		}
+
+		// munge host if using OpenSSL
+		if ($this->scheme == 'ssl') {
+			$host = 'ssl://' . $host;
+		}
+		$this->debug('calling fsockopen with host ' . $host . ' connection_timeout ' . $connection_timeout);
+
+		// open socket
+		if($connection_timeout > 0){
+			$this->fp = @fsockopen( $host, $this->port, $this->errno, $this->error_str, $connection_timeout);
+		} else {
+			$this->fp = @fsockopen( $host, $this->port, $this->errno, $this->error_str);
+		}
+		
+		// test pointer
+		if(!$this->fp) {
+			$msg = 'Couldn\'t open socket connection to server ' . $this->url;
+			if ($this->errno) {
+				$msg .= ', Error ('.$this->errno.'): '.$this->error_str;
+			} else {
+				$msg .= ' prior to connect().  This is often a problem looking up the host name.';
+			}
+			$this->debug($msg);
+			$this->setError($msg);
+			return false;
+		}
+		
+		// set response timeout
+		$this->debug('set response timeout to ' . $response_timeout);
+		socket_set_timeout( $this->fp, $response_timeout);
+
+		$this->debug('socket connected');
+		return true;
+	  } else if ($this->io_method() == 'curl') {
+		if (!extension_loaded('curl')) {
+//			$this->setError('cURL Extension, or OpenSSL extension w/ PHP version >= 4.3 is required for HTTPS');
+			$this->setError('The PHP cURL Extension is required for HTTPS or NLTM.  You will need to re-build or update your PHP to include cURL or change php.ini to load the PHP cURL extension.');
+			return false;
+		}
+		// Avoid warnings when PHP does not have these options
+		if (defined('CURLOPT_CONNECTIONTIMEOUT'))
+			$CURLOPT_CONNECTIONTIMEOUT = CURLOPT_CONNECTIONTIMEOUT;
+		else
+			$CURLOPT_CONNECTIONTIMEOUT = 78;
+		if (defined('CURLOPT_HTTPAUTH'))
+			$CURLOPT_HTTPAUTH = CURLOPT_HTTPAUTH;
+		else
+			$CURLOPT_HTTPAUTH = 107;
+		if (defined('CURLOPT_PROXYAUTH'))
+			$CURLOPT_PROXYAUTH = CURLOPT_PROXYAUTH;
+		else
+			$CURLOPT_PROXYAUTH = 111;
+		if (defined('CURLAUTH_BASIC'))
+			$CURLAUTH_BASIC = CURLAUTH_BASIC;
+		else
+			$CURLAUTH_BASIC = 1;
+		if (defined('CURLAUTH_DIGEST'))
+			$CURLAUTH_DIGEST = CURLAUTH_DIGEST;
+		else
+			$CURLAUTH_DIGEST = 2;
+		if (defined('CURLAUTH_NTLM'))
+			$CURLAUTH_NTLM = CURLAUTH_NTLM;
+		else
+			$CURLAUTH_NTLM = 8;
+
+		$this->debug('connect using cURL');
+		// init CURL
+		$this->ch = curl_init();
+		// set url
+		$hostURL = ($this->port != '') ? "$this->scheme://$this->host:$this->port" : "$this->scheme://$this->host";
+		// add path
+		$hostURL .= $this->path;
+		$this->setCurlOption(CURLOPT_URL, $hostURL);
+		// follow location headers (re-directs)
+		if (ini_get('safe_mode') || ini_get('open_basedir')) {
+			$this->debug('safe_mode or open_basedir set, so do not set CURLOPT_FOLLOWLOCATION');
+			$this->debug('safe_mode = ');
+			$this->appendDebug($this->varDump(ini_get('safe_mode')));
+			$this->debug('open_basedir = ');
+			$this->appendDebug($this->varDump(ini_get('open_basedir')));
+		} else {
+			$this->setCurlOption(CURLOPT_FOLLOWLOCATION, 1);
+		}
+		// ask for headers in the response output
+		$this->setCurlOption(CURLOPT_HEADER, 1);
+		// ask for the response output as the return value
+		$this->setCurlOption(CURLOPT_RETURNTRANSFER, 1);
+		// encode
+		// We manage this ourselves through headers and encoding
+//		if(function_exists('gzuncompress')){
+//			$this->setCurlOption(CURLOPT_ENCODING, 'deflate');
+//		}
+		// persistent connection
+		if ($this->persistentConnection) {
+			// I believe the following comment is now bogus, having applied to
+			// the code when it used CURLOPT_CUSTOMREQUEST to send the request.
+			// The way we send data, we cannot use persistent connections, since
+			// there will be some "junk" at the end of our request.
+			//$this->setCurlOption(CURL_HTTP_VERSION_1_1, true);
+			$this->persistentConnection = false;
+			$this->setHeader('Connection', 'close');
+		}
+		// set timeouts
+		if ($connection_timeout != 0) {
+			$this->setCurlOption($CURLOPT_CONNECTIONTIMEOUT, $connection_timeout);
+		}
+		if ($response_timeout != 0) {
+			$this->setCurlOption(CURLOPT_TIMEOUT, $response_timeout);
+		}
+
+		if ($this->scheme == 'https') {
+			$this->debug('set cURL SSL verify options');
+			// recent versions of cURL turn on peer/host checking by default,
+			// while PHP binaries are not compiled with a default location for the
+			// CA cert bundle, so disable peer/host checking.
+			//$this->setCurlOption(CURLOPT_CAINFO, 'f:\php-4.3.2-win32\extensions\curl-ca-bundle.crt');		
+			$this->setCurlOption(CURLOPT_SSL_VERIFYPEER, 0);
+			$this->setCurlOption(CURLOPT_SSL_VERIFYHOST, 0);
+	
+			// support client certificates (thanks Tobias Boes, Doug Anarino, Eryan Ariobowo)
+			if ($this->authtype == 'certificate') {
+				$this->debug('set cURL certificate options');
+				if (isset($this->certRequest['cainfofile'])) {
+					$this->setCurlOption(CURLOPT_CAINFO, $this->certRequest['cainfofile']);
+				}
+				if (isset($this->certRequest['verifypeer'])) {
+					$this->setCurlOption(CURLOPT_SSL_VERIFYPEER, $this->certRequest['verifypeer']);
+				} else {
+					$this->setCurlOption(CURLOPT_SSL_VERIFYPEER, 1);
+				}
+				if (isset($this->certRequest['verifyhost'])) {
+					$this->setCurlOption(CURLOPT_SSL_VERIFYHOST, $this->certRequest['verifyhost']);
+				} else {
+					$this->setCurlOption(CURLOPT_SSL_VERIFYHOST, 1);
+				}
+				if (isset($this->certRequest['sslcertfile'])) {
+					$this->setCurlOption(CURLOPT_SSLCERT, $this->certRequest['sslcertfile']);
+				}
+				if (isset($this->certRequest['sslkeyfile'])) {
+					$this->setCurlOption(CURLOPT_SSLKEY, $this->certRequest['sslkeyfile']);
+				}
+				if (isset($this->certRequest['passphrase'])) {
+					$this->setCurlOption(CURLOPT_SSLKEYPASSWD, $this->certRequest['passphrase']);
+				}
+				if (isset($this->certRequest['certpassword'])) {
+					$this->setCurlOption(CURLOPT_SSLCERTPASSWD, $this->certRequest['certpassword']);
+				}
+			}
+		}
+		if ($this->authtype && ($this->authtype != 'certificate')) {
+			if ($this->username) {
+				$this->debug('set cURL username/password');
+				$this->setCurlOption(CURLOPT_USERPWD, "$this->username:$this->password");
+			}
+			if ($this->authtype == 'basic') {
+				$this->debug('set cURL for Basic authentication');
+				$this->setCurlOption($CURLOPT_HTTPAUTH, $CURLAUTH_BASIC);
+			}
+			if ($this->authtype == 'digest') {
+				$this->debug('set cURL for digest authentication');
+				$this->setCurlOption($CURLOPT_HTTPAUTH, $CURLAUTH_DIGEST);
+			}
+			if ($this->authtype == 'ntlm') {
+				$this->debug('set cURL for NTLM authentication');
+				$this->setCurlOption($CURLOPT_HTTPAUTH, $CURLAUTH_NTLM);
+			}
+		}
+		if (is_array($this->proxy)) {
+			$this->debug('set cURL proxy options');
+			if ($this->proxy['port'] != '') {
+				$this->setCurlOption(CURLOPT_PROXY, $this->proxy['host'].':'.$this->proxy['port']);
+			} else {
+				$this->setCurlOption(CURLOPT_PROXY, $this->proxy['host']);
+			}
+			if ($this->proxy['username'] || $this->proxy['password']) {
+				$this->debug('set cURL proxy authentication options');
+				$this->setCurlOption(CURLOPT_PROXYUSERPWD, $this->proxy['username'].':'.$this->proxy['password']);
+				if ($this->proxy['authtype'] == 'basic') {
+					$this->setCurlOption($CURLOPT_PROXYAUTH, $CURLAUTH_BASIC);
+				}
+				if ($this->proxy['authtype'] == 'ntlm') {
+					$this->setCurlOption($CURLOPT_PROXYAUTH, $CURLAUTH_NTLM);
+				}
+			}
+		}
+		$this->debug('cURL connection set up');
+		return true;
+	  } else {
+		$this->setError('Unknown scheme ' . $this->scheme);
+		$this->debug('Unknown scheme ' . $this->scheme);
+		return false;
+	  }
+	}
+
+	/**
+	* sends the SOAP request and gets the SOAP response via HTTP[S]
+	*
+	* @param    string $data message data
+	* @param    integer $timeout set connection timeout in seconds
+	* @param	integer $response_timeout set response timeout in seconds
+	* @param	array $cookies cookies to send
+	* @return	string data
+	* @access   public
+	*/
+	function send($data, $timeout=0, $response_timeout=30, $cookies=NULL) {
+		
+		$this->debug('entered send() with data of length: '.strlen($data));
+
+		$this->tryagain = true;
+		$tries = 0;
+		while ($this->tryagain) {
+			$this->tryagain = false;
+			if ($tries++ < 2) {
+				// make connnection
+				if (!$this->connect($timeout, $response_timeout)){
+					return false;
+				}
+				
+				// send request
+				if (!$this->sendRequest($data, $cookies)){
+					return false;
+				}
+				
+				// get response
+				$respdata = $this->getResponse();
+			} else {
+				$this->setError("Too many tries to get an OK response ($this->response_status_line)");
+			}
+		}		
+		$this->debug('end of send()');
+		return $respdata;
+	}
+
+
+	/**
+	* sends the SOAP request and gets the SOAP response via HTTPS using CURL
+	*
+	* @param    string $data message data
+	* @param    integer $timeout set connection timeout in seconds
+	* @param	integer $response_timeout set response timeout in seconds
+	* @param	array $cookies cookies to send
+	* @return	string data
+	* @access   public
+	* @deprecated
+	*/
+	function sendHTTPS($data, $timeout=0, $response_timeout=30, $cookies) {
+		return $this->send($data, $timeout, $response_timeout, $cookies);
+	}
+	
+	/**
+	* if authenticating, set user credentials here
+	*
+	* @param    string $username
+	* @param    string $password
+	* @param	string $authtype (basic|digest|certificate|ntlm)
+	* @param	array $digestRequest (keys must be nonce, nc, realm, qop)
+	* @param	array $certRequest (keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, certpassword (optional), verifypeer (optional), verifyhost (optional): see corresponding options in cURL docs)
+	* @access   public
+	*/
+	function setCredentials($username, $password, $authtype = 'basic', $digestRequest = array(), $certRequest = array()) {
+		$this->debug("setCredentials username=$username authtype=$authtype digestRequest=");
+		$this->appendDebug($this->varDump($digestRequest));
+		$this->debug("certRequest=");
+		$this->appendDebug($this->varDump($certRequest));
+		// cf. RFC 2617
+		if ($authtype == 'basic') {
+			$this->setHeader('Authorization', 'Basic '.base64_encode(str_replace(':','',$username).':'.$password));
+		} elseif ($authtype == 'digest') {
+			if (isset($digestRequest['nonce'])) {
+				$digestRequest['nc'] = isset($digestRequest['nc']) ? $digestRequest['nc']++ : 1;
+				
+				// calculate the Digest hashes (calculate code based on digest implementation found at: http://www.rassoc.com/gregr/weblog/stories/2002/07/09/webServicesSecurityHttpDigestAuthenticationWithoutActiveDirectory.html)
+	
+				// A1 = unq(username-value) ":" unq(realm-value) ":" passwd
+				$A1 = $username. ':' . (isset($digestRequest['realm']) ? $digestRequest['realm'] : '') . ':' . $password;
+	
+				// H(A1) = MD5(A1)
+				$HA1 = md5($A1);
+	
+				// A2 = Method ":" digest-uri-value
+				$A2 = $this->request_method . ':' . $this->digest_uri;
+	
+				// H(A2)
+				$HA2 =  md5($A2);
+	
+				// KD(secret, data) = H(concat(secret, ":", data))
+				// if qop == auth:
+				// request-digest  = <"> < KD ( H(A1),     unq(nonce-value)
+				//                              ":" nc-value
+				//                              ":" unq(cnonce-value)
+				//                              ":" unq(qop-value)
+				//                              ":" H(A2)
+				//                            ) <">
+				// if qop is missing,
+				// request-digest  = <"> < KD ( H(A1), unq(nonce-value) ":" H(A2) ) > <">
+	
+				$unhashedDigest = '';
+				$nonce = isset($digestRequest['nonce']) ? $digestRequest['nonce'] : '';
+				$cnonce = $nonce;
+				if ($digestRequest['qop'] != '') {
+					$unhashedDigest = $HA1 . ':' . $nonce . ':' . sprintf("%08d", $digestRequest['nc']) . ':' . $cnonce . ':' . $digestRequest['qop'] . ':' . $HA2;
+				} else {
+					$unhashedDigest = $HA1 . ':' . $nonce . ':' . $HA2;
+				}
+	
+				$hashedDigest = md5($unhashedDigest);
+	
+				$opaque = '';	
+				if (isset($digestRequest['opaque'])) {
+					$opaque = ', opaque="' . $digestRequest['opaque'] . '"';
+				}
+
+				$this->setHeader('Authorization', 'Digest username="' . $username . '", realm="' . $digestRequest['realm'] . '", nonce="' . $nonce . '", uri="' . $this->digest_uri . $opaque . '", cnonce="' . $cnonce . '", nc=' . sprintf("%08x", $digestRequest['nc']) . ', qop="' . $digestRequest['qop'] . '", response="' . $hashedDigest . '"');
+			}
+		} elseif ($authtype == 'certificate') {
+			$this->certRequest = $certRequest;
+			$this->debug('Authorization header not set for certificate');
+		} elseif ($authtype == 'ntlm') {
+			// do nothing
+			$this->debug('Authorization header not set for ntlm');
+		}
+		$this->username = $username;
+		$this->password = $password;
+		$this->authtype = $authtype;
+		$this->digestRequest = $digestRequest;
+	}
+	
+	/**
+	* set the soapaction value
+	*
+	* @param    string $soapaction
+	* @access   public
+	*/
+	function setSOAPAction($soapaction) {
+		$this->setHeader('SOAPAction', '"' . $soapaction . '"');
+	}
+	
+	/**
+	* use http encoding
+	*
+	* @param    string $enc encoding style. supported values: gzip, deflate, or both
+	* @access   public
+	*/
+	function setEncoding($enc='gzip, deflate') {
+		if (function_exists('gzdeflate')) {
+			$this->protocol_version = '1.1';
+			$this->setHeader('Accept-Encoding', $enc);
+			if (!isset($this->outgoing_headers['Connection'])) {
+				$this->setHeader('Connection', 'close');
+				$this->persistentConnection = false;
+			}
+			// deprecated as of PHP 5.3.0
+			//set_magic_quotes_runtime(0);
+			$this->encoding = $enc;
+		}
+	}
+	
+	/**
+	* set proxy info here
+	*
+	* @param    string $proxyhost use an empty string to remove proxy
+	* @param    string $proxyport
+	* @param	string $proxyusername
+	* @param	string $proxypassword
+	* @param	string $proxyauthtype (basic|ntlm)
+	* @access   public
+	*/
+	function setProxy($proxyhost, $proxyport, $proxyusername = '', $proxypassword = '', $proxyauthtype = 'basic') {
+		if ($proxyhost) {
+			$this->proxy = array(
+				'host' => $proxyhost,
+				'port' => $proxyport,
+				'username' => $proxyusername,
+				'password' => $proxypassword,
+				'authtype' => $proxyauthtype
+			);
+			if ($proxyusername != '' && $proxypassword != '' && $proxyauthtype = 'basic') {
+				$this->setHeader('Proxy-Authorization', ' Basic '.base64_encode($proxyusername.':'.$proxypassword));
+			}
+		} else {
+			$this->debug('remove proxy');
+			$proxy = null;
+			unsetHeader('Proxy-Authorization');
+		}
+	}
+	
+
+	/**
+	 * Test if the given string starts with a header that is to be skipped.
+	 * Skippable headers result from chunked transfer and proxy requests.
+	 *
+	 * @param	string $data The string to check.
+	 * @returns	boolean	Whether a skippable header was found.
+	 * @access	private
+	 */
+	function isSkippableCurlHeader(&$data) {
+		$skipHeaders = array(	'HTTP/1.1 100',
+								'HTTP/1.0 301',
+								'HTTP/1.1 301',
+								'HTTP/1.0 302',
+								'HTTP/1.1 302',
+								'HTTP/1.0 401',
+								'HTTP/1.1 401',
+								'HTTP/1.0 200 Connection established');
+		foreach ($skipHeaders as $hd) {
+			$prefix = substr($data, 0, strlen($hd));
+			if ($prefix == $hd) return true;
+		}
+
+		return false;
+	}
+
+	/**
+	* decode a string that is encoded w/ "chunked' transfer encoding
+ 	* as defined in RFC2068 19.4.6
+	*
+	* @param    string $buffer
+	* @param    string $lb
+	* @returns	string
+	* @access   public
+	* @deprecated
+	*/
+	function decodeChunked($buffer, $lb){
+		// length := 0
+		$length = 0;
+		$new = '';
+		
+		// read chunk-size, chunk-extension (if any) and CRLF
+		// get the position of the linebreak
+		$chunkend = strpos($buffer, $lb);
+		if ($chunkend == FALSE) {
+			$this->debug('no linebreak found in decodeChunked');
+			return $new;
+		}
+		$temp = substr($buffer,0,$chunkend);
+		$chunk_size = hexdec( trim($temp) );
+		$chunkstart = $chunkend + strlen($lb);
+		// while (chunk-size > 0) {
+		while ($chunk_size > 0) {
+			$this->debug("chunkstart: $chunkstart chunk_size: $chunk_size");
+			$chunkend = strpos( $buffer, $lb, $chunkstart + $chunk_size);
+		  	
+			// Just in case we got a broken connection
+		  	if ($chunkend == FALSE) {
+		  	    $chunk = substr($buffer,$chunkstart);
+				// append chunk-data to entity-body
+		    	$new .= $chunk;
+		  	    $length += strlen($chunk);
+		  	    break;
+			}
+			
+		  	// read chunk-data and CRLF
+		  	$chunk = substr($buffer,$chunkstart,$chunkend-$chunkstart);
+		  	// append chunk-data to entity-body
+		  	$new .= $chunk;
+		  	// length := length + chunk-size
+		  	$length += strlen($chunk);
+		  	// read chunk-size and CRLF
+		  	$chunkstart = $chunkend + strlen($lb);
+			
+		  	$chunkend = strpos($buffer, $lb, $chunkstart) + strlen($lb);
+			if ($chunkend == FALSE) {
+				break; //Just in case we got a broken connection
+			}
+			$temp = substr($buffer,$chunkstart,$chunkend-$chunkstart);
+			$chunk_size = hexdec( trim($temp) );
+			$chunkstart = $chunkend;
+		}
+		return $new;
+	}
+	
+	/**
+	 * Writes the payload, including HTTP headers, to $this->outgoing_payload.
+	 *
+	 * @param	string $data HTTP body
+	 * @param	string $cookie_str data for HTTP Cookie header
+	 * @return	void
+	 * @access	private
+	 */
+	function buildPayload($data, $cookie_str = '') {
+		// Note: for cURL connections, $this->outgoing_payload is ignored,
+		// as is the Content-Length header, but these are still created as
+		// debugging guides.
+
+		// add content-length header
+		if ($this->request_method != 'GET') {
+			$this->setHeader('Content-Length', strlen($data));
+		}
+
+		// start building outgoing payload:
+		if ($this->proxy) {
+			$uri = $this->url;
+		} else {
+			$uri = $this->uri;
+		}
+		$req = "$this->request_method $uri HTTP/$this->protocol_version";
+		$this->debug("HTTP request: $req");
+		$this->outgoing_payload = "$req\r\n";
+
+		// loop thru headers, serializing
+		foreach($this->outgoing_headers as $k => $v){
+			$hdr = $k.': '.$v;
+			$this->debug("HTTP header: $hdr");
+			$this->outgoing_payload .= "$hdr\r\n";
+		}
+
+		// add any cookies
+		if ($cookie_str != '') {
+			$hdr = 'Cookie: '.$cookie_str;
+			$this->debug("HTTP header: $hdr");
+			$this->outgoing_payload .= "$hdr\r\n";
+		}
+
+		// header/body separator
+		$this->outgoing_payload .= "\r\n";
+		
+		// add data
+		$this->outgoing_payload .= $data;
+	}
+
+	/**
+	* sends the SOAP request via HTTP[S]
+	*
+	* @param    string $data message data
+	* @param	array $cookies cookies to send
+	* @return	boolean	true if OK, false if problem
+	* @access   private
+	*/
+	function sendRequest($data, $cookies = NULL) {
+		// build cookie string
+		$cookie_str = $this->getCookiesForRequest($cookies, (($this->scheme == 'ssl') || ($this->scheme == 'https')));
+
+		// build payload
+		$this->buildPayload($data, $cookie_str);
+
+	  if ($this->io_method() == 'socket') {
+		// send payload
+		if(!fputs($this->fp, $this->outgoing_payload, strlen($this->outgoing_payload))) {
+			$this->setError('couldn\'t write message data to socket');
+			$this->debug('couldn\'t write message data to socket');
+			return false;
+		}
+		$this->debug('wrote data to socket, length = ' . strlen($this->outgoing_payload));
+		return true;
+	  } else if ($this->io_method() == 'curl') {
+		// set payload
+		// cURL does say this should only be the verb, and in fact it
+		// turns out that the URI and HTTP version are appended to this, which
+		// some servers refuse to work with (so we no longer use this method!)
+		//$this->setCurlOption(CURLOPT_CUSTOMREQUEST, $this->outgoing_payload);
+		$curl_headers = array();
+		foreach($this->outgoing_headers as $k => $v){
+			if ($k == 'Connection' || $k == 'Content-Length' || $k == 'Host' || $k == 'Authorization' || $k == 'Proxy-Authorization') {
+				$this->debug("Skip cURL header $k: $v");
+			} else {
+				$curl_headers[] = "$k: $v";
+			}
+		}
+		if ($cookie_str != '') {
+			$curl_headers[] = 'Cookie: ' . $cookie_str;
+		}
+		$this->setCurlOption(CURLOPT_HTTPHEADER, $curl_headers);
+		$this->debug('set cURL HTTP headers');
+		if ($this->request_method == "POST") {
+	  		$this->setCurlOption(CURLOPT_POST, 1);
+	  		$this->setCurlOption(CURLOPT_POSTFIELDS, $data);
+			$this->debug('set cURL POST data');
+	  	} else {
+	  	}
+		// insert custom user-set cURL options
+		foreach ($this->ch_options as $key => $val) {
+			$this->setCurlOption($key, $val);
+		}
+
+		$this->debug('set cURL payload');
+		return true;
+	  }
+	}
+
+	/**
+	* gets the SOAP response via HTTP[S]
+	*
+	* @return	string the response (also sets member variables like incoming_payload)
+	* @access   private
+	*/
+	function getResponse(){
+		$this->incoming_payload = '';
+	    
+	  if ($this->io_method() == 'socket') {
+	    // loop until headers have been retrieved
+	    $data = '';
+	    while (!isset($lb)){
+
+			// We might EOF during header read.
+			if(feof($this->fp)) {
+				$this->incoming_payload = $data;
+				$this->debug('found no headers before EOF after length ' . strlen($data));
+				$this->debug("received before EOF:\n" . $data);
+				$this->setError('server failed to send headers');
+				return false;
+			}
+
+			$tmp = fgets($this->fp, 256);
+			$tmplen = strlen($tmp);
+			$this->debug("read line of $tmplen bytes: " . trim($tmp));
+
+			if ($tmplen == 0) {
+				$this->incoming_payload = $data;
+				$this->debug('socket read of headers timed out after length ' . strlen($data));
+				$this->debug("read before timeout: " . $data);
+				$this->setError('socket read of headers timed out');
+				return false;
+			}
+
+			$data .= $tmp;
+			$pos = strpos($data,"\r\n\r\n");
+			if($pos > 1){
+				$lb = "\r\n";
+			} else {
+				$pos = strpos($data,"\n\n");
+				if($pos > 1){
+					$lb = "\n";
+				}
+			}
+			// remove 100 headers
+			if (isset($lb) && preg_match('/^HTTP\/1.1 100/',$data)) {
+				unset($lb);
+				$data = '';
+			}//
+		}
+		// store header data
+		$this->incoming_payload .= $data;
+		$this->debug('found end of headers after length ' . strlen($data));
+		// process headers
+		$header_data = trim(substr($data,0,$pos));
+		$header_array = explode($lb,$header_data);
+		$this->incoming_headers = array();
+		$this->incoming_cookies = array();
+		foreach($header_array as $header_line){
+			$arr = explode(':',$header_line, 2);
+			if(count($arr) > 1){
+				$header_name = strtolower(trim($arr[0]));
+				$this->incoming_headers[$header_name] = trim($arr[1]);
+				if ($header_name == 'set-cookie') {
+					// TODO: allow multiple cookies from parseCookie
+					$cookie = $this->parseCookie(trim($arr[1]));
+					if ($cookie) {
+						$this->incoming_cookies[] = $cookie;
+						$this->debug('found cookie: ' . $cookie['name'] . ' = ' . $cookie['value']);
+					} else {
+						$this->debug('did not find cookie in ' . trim($arr[1]));
+					}
+    			}
+			} else if (isset($header_name)) {
+				// append continuation line to previous header
+				$this->incoming_headers[$header_name] .= $lb . ' ' . $header_line;
+			}
+		}
+		
+		// loop until msg has been received
+		if (isset($this->incoming_headers['transfer-encoding']) && strtolower($this->incoming_headers['transfer-encoding']) == 'chunked') {
+			$content_length =  2147483647;	// ignore any content-length header
+			$chunked = true;
+			$this->debug("want to read chunked content");
+		} elseif (isset($this->incoming_headers['content-length'])) {
+			$content_length = $this->incoming_headers['content-length'];
+			$chunked = false;
+			$this->debug("want to read content of length $content_length");
+		} else {
+			$content_length =  2147483647;
+			$chunked = false;
+			$this->debug("want to read content to EOF");
+		}
+		$data = '';
+		do {
+			if ($chunked) {
+				$tmp = fgets($this->fp, 256);
+				$tmplen = strlen($tmp);
+				$this->debug("read chunk line of $tmplen bytes");
+				if ($tmplen == 0) {
+					$this->incoming_payload = $data;
+					$this->debug('socket read of chunk length timed out after length ' . strlen($data));
+					$this->debug("read before timeout:\n" . $data);
+					$this->setError('socket read of chunk length timed out');
+					return false;
+				}
+				$content_length = hexdec(trim($tmp));
+				$this->debug("chunk length $content_length");
+			}
+			$strlen = 0;
+		    while (($strlen < $content_length) && (!feof($this->fp))) {
+		    	$readlen = min(8192, $content_length - $strlen);
+				$tmp = fread($this->fp, $readlen);
+				$tmplen = strlen($tmp);
+				$this->debug("read buffer of $tmplen bytes");
+				if (($tmplen == 0) && (!feof($this->fp))) {
+					$this->incoming_payload = $data;
+					$this->debug('socket read of body timed out after length ' . strlen($data));
+					$this->debug("read before timeout:\n" . $data);
+					$this->setError('socket read of body timed out');
+					return false;
+				}
+				$strlen += $tmplen;
+				$data .= $tmp;
+			}
+			if ($chunked && ($content_length > 0)) {
+				$tmp = fgets($this->fp, 256);
+				$tmplen = strlen($tmp);
+				$this->debug("read chunk terminator of $tmplen bytes");
+				if ($tmplen == 0) {
+					$this->incoming_payload = $data;
+					$this->debug('socket read of chunk terminator timed out after length ' . strlen($data));
+					$this->debug("read before timeout:\n" . $data);
+					$this->setError('socket read of chunk terminator timed out');
+					return false;
+				}
+			}
+		} while ($chunked && ($content_length > 0) && (!feof($this->fp)));
+		if (feof($this->fp)) {
+			$this->debug('read to EOF');
+		}
+		$this->debug('read body of length ' . strlen($data));
+		$this->incoming_payload .= $data;
+		$this->debug('received a total of '.strlen($this->incoming_payload).' bytes of data from server');
+		
+		// close filepointer
+		if(
+			(isset($this->incoming_headers['connection']) && strtolower($this->incoming_headers['connection']) == 'close') || 
+			(! $this->persistentConnection) || feof($this->fp)){
+			fclose($this->fp);
+			$this->fp = false;
+			$this->debug('closed socket');
+		}
+		
+		// connection was closed unexpectedly
+		if($this->incoming_payload == ''){
+			$this->setError('no response from server');
+			return false;
+		}
+		
+		// decode transfer-encoding
+//		if(isset($this->incoming_headers['transfer-encoding']) && strtolower($this->incoming_headers['transfer-encoding']) == 'chunked'){
+//			if(!$data = $this->decodeChunked($data, $lb)){
+//				$this->setError('Decoding of chunked data failed');
+//				return false;
+//			}
+			//print "<pre>\nde-chunked:\n---------------\n$data\n\n---------------\n</pre>";
+			// set decoded payload
+//			$this->incoming_payload = $header_data.$lb.$lb.$data;
+//		}
+	
+	  } else if ($this->io_method() == 'curl') {
+		// send and receive
+		$this->debug('send and receive with cURL');
+		$this->incoming_payload = curl_exec($this->ch);
+		$data = $this->incoming_payload;
+
+        $cErr = curl_error($this->ch);
+		if ($cErr != '') {
+        	$err = 'cURL ERROR: '.curl_errno($this->ch).': '.$cErr.'<br>';
+        	// TODO: there is a PHP bug that can cause this to SEGV for CURLINFO_CONTENT_TYPE
+			foreach(curl_getinfo($this->ch) as $k => $v){
+				$err .= "$k: $v<br>";
+			}
+			$this->debug($err);
+			$this->setError($err);
+			curl_close($this->ch);
+	    	return false;
+		} else {
+			//echo '<pre>';
+			//var_dump(curl_getinfo($this->ch));
+			//echo '</pre>';
+		}
+		// close curl
+		$this->debug('No cURL error, closing cURL');
+		curl_close($this->ch);
+		
+		// try removing skippable headers
+		$savedata = $data;
+		while ($this->isSkippableCurlHeader($data)) {
+			$this->debug("Found HTTP header to skip");
+			if ($pos = strpos($data,"\r\n\r\n")) {
+				$data = ltrim(substr($data,$pos));
+			} elseif($pos = strpos($data,"\n\n") ) {
+				$data = ltrim(substr($data,$pos));
+			}
+		}
+
+		if ($data == '') {
+			// have nothing left; just remove 100 header(s)
+			$data = $savedata;
+			while (preg_match('/^HTTP\/1.1 100/',$data)) {
+				if ($pos = strpos($data,"\r\n\r\n")) {
+					$data = ltrim(substr($data,$pos));
+				} elseif($pos = strpos($data,"\n\n") ) {
+					$data = ltrim(substr($data,$pos));
+				}
+			}
+		}
+		
+		// separate content from HTTP headers
+		if ($pos = strpos($data,"\r\n\r\n")) {
+			$lb = "\r\n";
+		} elseif( $pos = strpos($data,"\n\n")) {
+			$lb = "\n";
+		} else {
+			$this->debug('no proper separation of headers and document');
+			$this->setError('no proper separation of headers and document');
+			return false;
+		}
+		$header_data = trim(substr($data,0,$pos));
+		$header_array = explode($lb,$header_data);
+		$data = ltrim(substr($data,$pos));
+		$this->debug('found proper separation of headers and document');
+		$this->debug('cleaned data, stringlen: '.strlen($data));
+		// clean headers
+		foreach ($header_array as $header_line) {
+			$arr = explode(':',$header_line,2);
+			if(count($arr) > 1){
+				$header_name = strtolower(trim($arr[0]));
+				$this->incoming_headers[$header_name] = trim($arr[1]);
+				if ($header_name == 'set-cookie') {
+					// TODO: allow multiple cookies from parseCookie
+					$cookie = $this->parseCookie(trim($arr[1]));
+					if ($cookie) {
+						$this->incoming_cookies[] = $cookie;
+						$this->debug('found cookie: ' . $cookie['name'] . ' = ' . $cookie['value']);
+					} else {
+						$this->debug('did not find cookie in ' . trim($arr[1]));
+					}
+    			}
+			} else if (isset($header_name)) {
+				// append continuation line to previous header
+				$this->incoming_headers[$header_name] .= $lb . ' ' . $header_line;
+			}
+		}
+	  }
+
+		$this->response_status_line = $header_array[0];
+		$arr = explode(' ', $this->response_status_line, 3);
+		$http_version = $arr[0];
+		$http_status = intval($arr[1]);
+		$http_reason = count($arr) > 2 ? $arr[2] : '';
+
+ 		// see if we need to resend the request with http digest authentication
+ 		if (isset($this->incoming_headers['location']) && ($http_status == 301 || $http_status == 302)) {
+ 			$this->debug("Got $http_status $http_reason with Location: " . $this->incoming_headers['location']);
+ 			$this->setURL($this->incoming_headers['location']);
+			$this->tryagain = true;
+			return false;
+		}
+
+ 		// see if we need to resend the request with http digest authentication
+ 		if (isset($this->incoming_headers['www-authenticate']) && $http_status == 401) {
+ 			$this->debug("Got 401 $http_reason with WWW-Authenticate: " . $this->incoming_headers['www-authenticate']);
+ 			if (strstr($this->incoming_headers['www-authenticate'], "Digest ")) {
+ 				$this->debug('Server wants digest authentication');
+ 				// remove "Digest " from our elements
+ 				$digestString = str_replace('Digest ', '', $this->incoming_headers['www-authenticate']);
+ 				
+ 				// parse elements into array
+ 				$digestElements = explode(',', $digestString);
+ 				foreach ($digestElements as $val) {
+ 					$tempElement = explode('=', trim($val), 2);
+ 					$digestRequest[$tempElement[0]] = str_replace("\"", '', $tempElement[1]);
+ 				}
+
+				// should have (at least) qop, realm, nonce
+ 				if (isset($digestRequest['nonce'])) {
+ 					$this->setCredentials($this->username, $this->password, 'digest', $digestRequest);
+ 					$this->tryagain = true;
+ 					return false;
+ 				}
+ 			}
+			$this->debug('HTTP authentication failed');
+			$this->setError('HTTP authentication failed');
+			return false;
+ 		}
+		
+		if (
+			($http_status >= 300 && $http_status <= 307) ||
+			($http_status >= 400 && $http_status <= 417) ||
+			($http_status >= 501 && $http_status <= 505)
+		   ) {
+			$this->setError("Unsupported HTTP response status $http_status $http_reason (soapclient->response has contents of the response)");
+			return false;
+		}
+
+		// decode content-encoding
+		if(isset($this->incoming_headers['content-encoding']) && $this->incoming_headers['content-encoding'] != ''){
+			if(strtolower($this->incoming_headers['content-encoding']) == 'deflate' || strtolower($this->incoming_headers['content-encoding']) == 'gzip'){
+    			// if decoding works, use it. else assume data wasn't gzencoded
+    			if(function_exists('gzinflate')){
+					//$timer->setMarker('starting decoding of gzip/deflated content');
+					// IIS 5 requires gzinflate instead of gzuncompress (similar to IE 5 and gzdeflate v. gzcompress)
+					// this means there are no Zlib headers, although there should be
+					$this->debug('The gzinflate function exists');
+					$datalen = strlen($data);
+					if ($this->incoming_headers['content-encoding'] == 'deflate') {
+						if ($degzdata = @gzinflate($data)) {
+	    					$data = $degzdata;
+	    					$this->debug('The payload has been inflated to ' . strlen($data) . ' bytes');
+	    					if (strlen($data) < $datalen) {
+	    						// test for the case that the payload has been compressed twice
+		    					$this->debug('The inflated payload is smaller than the gzipped one; try again');
+								if ($degzdata = @gzinflate($data)) {
+			    					$data = $degzdata;
+			    					$this->debug('The payload has been inflated again to ' . strlen($data) . ' bytes');
+								}
+	    					}
+	    				} else {
+	    					$this->debug('Error using gzinflate to inflate the payload');
+	    					$this->setError('Error using gzinflate to inflate the payload');
+	    				}
+					} elseif ($this->incoming_headers['content-encoding'] == 'gzip') {
+						if ($degzdata = @gzinflate(substr($data, 10))) {	// do our best
+							$data = $degzdata;
+	    					$this->debug('The payload has been un-gzipped to ' . strlen($data) . ' bytes');
+	    					if (strlen($data) < $datalen) {
+	    						// test for the case that the payload has been compressed twice
+		    					$this->debug('The un-gzipped payload is smaller than the gzipped one; try again');
+								if ($degzdata = @gzinflate(substr($data, 10))) {
+			    					$data = $degzdata;
+			    					$this->debug('The payload has been un-gzipped again to ' . strlen($data) . ' bytes');
+								}
+	    					}
+	    				} else {
+	    					$this->debug('Error using gzinflate to un-gzip the payload');
+							$this->setError('Error using gzinflate to un-gzip the payload');
+	    				}
+					}
+					//$timer->setMarker('finished decoding of gzip/deflated content');
+					//print "<xmp>\nde-inflated:\n---------------\n$data\n-------------\n</xmp>";
+					// set decoded payload
+					$this->incoming_payload = $header_data.$lb.$lb.$data;
+    			} else {
+					$this->debug('The server sent compressed data. Your php install must have the Zlib extension compiled in to support this.');
+					$this->setError('The server sent compressed data. Your php install must have the Zlib extension compiled in to support this.');
+				}
+			} else {
+				$this->debug('Unsupported Content-Encoding ' . $this->incoming_headers['content-encoding']);
+				$this->setError('Unsupported Content-Encoding ' . $this->incoming_headers['content-encoding']);
+			}
+		} else {
+			$this->debug('No Content-Encoding header');
+		}
+		
+		if(strlen($data) == 0){
+			$this->debug('no data after headers!');
+			$this->setError('no data present after HTTP headers');
+			return false;
+		}
+		
+		return $data;
+	}
+
+	/**
+	 * sets the content-type for the SOAP message to be sent
+	 *
+	 * @param	string $type the content type, MIME style
+	 * @param	mixed $charset character set used for encoding (or false)
+	 * @access	public
+	 */
+	function setContentType($type, $charset = false) {
+		$this->setHeader('Content-Type', $type . ($charset ? '; charset=' . $charset : ''));
+	}
+
+	/**
+	 * specifies that an HTTP persistent connection should be used
+	 *
+	 * @return	boolean whether the request was honored by this method.
+	 * @access	public
+	 */
+	function usePersistentConnection(){
+		if (isset($this->outgoing_headers['Accept-Encoding'])) {
+			return false;
+		}
+		$this->protocol_version = '1.1';
+		$this->persistentConnection = true;
+		$this->setHeader('Connection', 'Keep-Alive');
+		return true;
+	}
+
+	/**
+	 * parse an incoming Cookie into it's parts
+	 *
+	 * @param	string $cookie_str content of cookie
+	 * @return	array with data of that cookie
+	 * @access	private
+	 */
+	/*
+	 * TODO: allow a Set-Cookie string to be parsed into multiple cookies
+	 */
+	function parseCookie($cookie_str) {
+		$cookie_str = str_replace('; ', ';', $cookie_str) . ';';
+		$data = preg_split('/;/', $cookie_str);
+		$value_str = $data[0];
+
+		$cookie_param = 'domain=';
+		$start = strpos($cookie_str, $cookie_param);
+		if ($start > 0) {
+			$domain = substr($cookie_str, $start + strlen($cookie_param));
+			$domain = substr($domain, 0, strpos($domain, ';'));
+		} else {
+			$domain = '';
+		}
+
+		$cookie_param = 'expires=';
+		$start = strpos($cookie_str, $cookie_param);
+		if ($start > 0) {
+			$expires = substr($cookie_str, $start + strlen($cookie_param));
+			$expires = substr($expires, 0, strpos($expires, ';'));
+		} else {
+			$expires = '';
+		}
+
+		$cookie_param = 'path=';
+		$start = strpos($cookie_str, $cookie_param);
+		if ( $start > 0 ) {
+			$path = substr($cookie_str, $start + strlen($cookie_param));
+			$path = substr($path, 0, strpos($path, ';'));
+		} else {
+			$path = '/';
+		}
+						
+		$cookie_param = ';secure;';
+		if (strpos($cookie_str, $cookie_param) !== FALSE) {
+			$secure = true;
+		} else {
+			$secure = false;
+		}
+
+		$sep_pos = strpos($value_str, '=');
+
+		if ($sep_pos) {
+			$name = substr($value_str, 0, $sep_pos);
+			$value = substr($value_str, $sep_pos + 1);
+			$cookie= array(	'name' => $name,
+			                'value' => $value,
+							'domain' => $domain,
+							'path' => $path,
+							'expires' => $expires,
+							'secure' => $secure
+							);		
+			return $cookie;
+		}
+		return false;
+	}
+  
+	/**
+	 * sort out cookies for the current request
+	 *
+	 * @param	array $cookies array with all cookies
+	 * @param	boolean $secure is the send-content secure or not?
+	 * @return	string for Cookie-HTTP-Header
+	 * @access	private
+	 */
+	function getCookiesForRequest($cookies, $secure=false) {
+		$cookie_str = '';
+		if ((! is_null($cookies)) && (is_array($cookies))) {
+			foreach ($cookies as $cookie) {
+				if (! is_array($cookie)) {
+					continue;
+				}
+	    		$this->debug("check cookie for validity: ".$cookie['name'].'='.$cookie['value']);
+				if ((isset($cookie['expires'])) && (! empty($cookie['expires']))) {
+					if (strtotime($cookie['expires']) <= time()) {
+						$this->debug('cookie has expired');
+						continue;
+					}
+				}
+				if ((isset($cookie['domain'])) && (! empty($cookie['domain']))) {
+					$domain = preg_quote($cookie['domain']);
+					if (! preg_match("'.*$domain$'i", $this->host)) {
+						$this->debug('cookie has different domain');
+						continue;
+					}
+				}
+				if ((isset($cookie['path'])) && (! empty($cookie['path']))) {
+					$path = preg_quote($cookie['path']);
+					if (! preg_match("'^$path.*'i", $this->path)) {
+						$this->debug('cookie is for a different path');
+						continue;
+					}
+				}
+				if ((! $secure) && (isset($cookie['secure'])) && ($cookie['secure'])) {
+					$this->debug('cookie is secure, transport is not');
+					continue;
+				}
+				$cookie_str .= $cookie['name'] . '=' . $cookie['value'] . '; ';
+	    		$this->debug('add cookie to Cookie-String: ' . $cookie['name'] . '=' . $cookie['value']);
+			}
+		}
+		return $cookie_str;
+  }
+}
+
+?><?php
+
+
+
+/**
+*
+* nusoap_server allows the user to create a SOAP server
+* that is capable of receiving messages and returning responses
+*
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @version  $Id: nusoap.php,v 1.123 2010/04/26 20:15:08 snichol Exp $
+* @access   public
+*/
+class nusoap_server extends nusoap_base {
+	/**
+	 * HTTP headers of request
+	 * @var array
+	 * @access private
+	 */
+	var $headers = array();
+	/**
+	 * HTTP request
+	 * @var string
+	 * @access private
+	 */
+	var $request = '';
+	/**
+	 * SOAP headers from request (incomplete namespace resolution; special characters not escaped) (text)
+	 * @var string
+	 * @access public
+	 */
+	var $requestHeaders = '';
+	/**
+	 * SOAP Headers from request (parsed)
+	 * @var mixed
+	 * @access public
+	 */
+	var $requestHeader = NULL;
+	/**
+	 * SOAP body request portion (incomplete namespace resolution; special characters not escaped) (text)
+	 * @var string
+	 * @access public
+	 */
+	var $document = '';
+	/**
+	 * SOAP payload for request (text)
+	 * @var string
+	 * @access public
+	 */
+	var $requestSOAP = '';
+	/**
+	 * requested method namespace URI
+	 * @var string
+	 * @access private
+	 */
+	var $methodURI = '';
+	/**
+	 * name of method requested
+	 * @var string
+	 * @access private
+	 */
+	var $methodname = '';
+	/**
+	 * method parameters from request
+	 * @var array
+	 * @access private
+	 */
+	var $methodparams = array();
+	/**
+	 * SOAP Action from request
+	 * @var string
+	 * @access private
+	 */
+	var $SOAPAction = '';
+	/**
+	 * character set encoding of incoming (request) messages
+	 * @var string
+	 * @access public
+	 */
+	var $xml_encoding = '';
+	/**
+	 * toggles whether the parser decodes element content w/ utf8_decode()
+	 * @var boolean
+	 * @access public
+	 */
+    var $decode_utf8 = true;
+
+	/**
+	 * HTTP headers of response
+	 * @var array
+	 * @access public
+	 */
+	var $outgoing_headers = array();
+	/**
+	 * HTTP response
+	 * @var string
+	 * @access private
+	 */
+	var $response = '';
+	/**
+	 * SOAP headers for response (text or array of soapval or associative array)
+	 * @var mixed
+	 * @access public
+	 */
+	var $responseHeaders = '';
+	/**
+	 * SOAP payload for response (text)
+	 * @var string
+	 * @access private
+	 */
+	var $responseSOAP = '';
+	/**
+	 * method return value to place in response
+	 * @var mixed
+	 * @access private
+	 */
+	var $methodreturn = false;
+	/**
+	 * whether $methodreturn is a string of literal XML
+	 * @var boolean
+	 * @access public
+	 */
+	var $methodreturnisliteralxml = false;
+	/**
+	 * SOAP fault for response (or false)
+	 * @var mixed
+	 * @access private
+	 */
+	var $fault = false;
+	/**
+	 * text indication of result (for debugging)
+	 * @var string
+	 * @access private
+	 */
+	var $result = 'successful';
+
+	/**
+	 * assoc array of operations => opData; operations are added by the register()
+	 * method or by parsing an external WSDL definition
+	 * @var array
+	 * @access private
+	 */
+	var $operations = array();
+	/**
+	 * wsdl instance (if one)
+	 * @var mixed
+	 * @access private
+	 */
+	var $wsdl = false;
+	/**
+	 * URL for WSDL (if one)
+	 * @var mixed
+	 * @access private
+	 */
+	var $externalWSDLURL = false;
+	/**
+	 * whether to append debug to response as XML comment
+	 * @var boolean
+	 * @access public
+	 */
+	var $debug_flag = false;
+
+
+	/**
+	* constructor
+    * the optional parameter is a path to a WSDL file that you'd like to bind the server instance to.
+	*
+    * @param mixed $wsdl file path or URL (string), or wsdl instance (object)
+	* @access   public
+	*/
+	function nusoap_server($wsdl=false){
+		parent::nusoap_base();
+		// turn on debugging?
+		global $debug;
+		global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER)) {
+			$this->debug("_SERVER is defined:");
+			$this->appendDebug($this->varDump($_SERVER));
+		} elseif (isset($HTTP_SERVER_VARS)) {
+			$this->debug("HTTP_SERVER_VARS is defined:");
+			$this->appendDebug($this->varDump($HTTP_SERVER_VARS));
+		} else {
+			$this->debug("Neither _SERVER nor HTTP_SERVER_VARS is defined.");
+		}
+
+		if (isset($debug)) {
+			$this->debug("In nusoap_server, set debug_flag=$debug based on global flag");
+			$this->debug_flag = $debug;
+		} elseif (isset($_SERVER['QUERY_STRING'])) {
+			$qs = explode('&', $_SERVER['QUERY_STRING']);
+			foreach ($qs as $v) {
+				if (substr($v, 0, 6) == 'debug=') {
+					$this->debug("In nusoap_server, set debug_flag=" . substr($v, 6) . " based on query string #1");
+					$this->debug_flag = substr($v, 6);
+				}
+			}
+		} elseif (isset($HTTP_SERVER_VARS['QUERY_STRING'])) {
+			$qs = explode('&', $HTTP_SERVER_VARS['QUERY_STRING']);
+			foreach ($qs as $v) {
+				if (substr($v, 0, 6) == 'debug=') {
+					$this->debug("In nusoap_server, set debug_flag=" . substr($v, 6) . " based on query string #2");
+					$this->debug_flag = substr($v, 6);
+				}
+			}
+		}
+
+		// wsdl
+		if($wsdl){
+			$this->debug("In nusoap_server, WSDL is specified");
+			if (is_object($wsdl) && (get_class($wsdl) == 'wsdl')) {
+				$this->wsdl = $wsdl;
+				$this->externalWSDLURL = $this->wsdl->wsdl;
+				$this->debug('Use existing wsdl instance from ' . $this->externalWSDLURL);
+			} else {
+				$this->debug('Create wsdl from ' . $wsdl);
+				$this->wsdl = new wsdl($wsdl);
+				$this->externalWSDLURL = $wsdl;
+			}
+			$this->appendDebug($this->wsdl->getDebug());
+			$this->wsdl->clearDebug();
+			if($err = $this->wsdl->getError()){
+				die('WSDL ERROR: '.$err);
+			}
+		}
+	}
+
+	/**
+	* processes request and returns response
+	*
+	* @param    string $data usually is the value of $HTTP_RAW_POST_DATA
+	* @access   public
+	*/
+	function service($data){
+		global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER['REQUEST_METHOD'])) {
+			$rm = $_SERVER['REQUEST_METHOD'];
+		} elseif (isset($HTTP_SERVER_VARS['REQUEST_METHOD'])) {
+			$rm = $HTTP_SERVER_VARS['REQUEST_METHOD'];
+		} else {
+			$rm = '';
+		}
+
+		if (isset($_SERVER['QUERY_STRING'])) {
+			$qs = $_SERVER['QUERY_STRING'];
+		} elseif (isset($HTTP_SERVER_VARS['QUERY_STRING'])) {
+			$qs = $HTTP_SERVER_VARS['QUERY_STRING'];
+		} else {
+			$qs = '';
+		}
+		$this->debug("In service, request method=$rm query string=$qs strlen(\$data)=" . strlen($data));
+
+		if ($rm == 'POST') {
+			$this->debug("In service, invoke the request");
+			$this->parse_request($data);
+			if (! $this->fault) {
+				$this->invoke_method();
+			}
+			if (! $this->fault) {
+				$this->serialize_return();
+			}
+			$this->send_response();
+		} elseif (preg_match('/wsdl/', $qs) ){
+			$this->debug("In service, this is a request for WSDL");
+			if ($this->externalWSDLURL){
+              if (strpos($this->externalWSDLURL, "http://") !== false) { // assume URL
+				$this->debug("In service, re-direct for WSDL");
+				header('Location: '.$this->externalWSDLURL);
+              } else { // assume file
+				$this->debug("In service, use file passthru for WSDL");
+                header("Content-Type: text/xml\r\n");
+				$pos = strpos($this->externalWSDLURL, "file://");
+				if ($pos === false) {
+					$filename = $this->externalWSDLURL;
+				} else {
+					$filename = substr($this->externalWSDLURL, $pos + 7);
+				}
+                $fp = fopen($this->externalWSDLURL, 'r');
+                fpassthru($fp);
+              }
+			} elseif ($this->wsdl) {
+				$this->debug("In service, serialize WSDL");
+				header("Content-Type: text/xml; charset=ISO-8859-1\r\n");
+				print $this->wsdl->serialize($this->debug_flag);
+				if ($this->debug_flag) {
+					$this->debug('wsdl:');
+					$this->appendDebug($this->varDump($this->wsdl));
+					print $this->getDebugAsXMLComment();
+				}
+			} else {
+				$this->debug("In service, there is no WSDL");
+				header("Content-Type: text/html; charset=ISO-8859-1\r\n");
+				print "This service does not provide WSDL";
+			}
+		} elseif ($this->wsdl) {
+			$this->debug("In service, return Web description");
+			print $this->wsdl->webDescription();
+		} else {
+			$this->debug("In service, no Web description");
+			header("Content-Type: text/html; charset=ISO-8859-1\r\n");
+			print "This service does not provide a Web description";
+		}
+	}
+
+	/**
+	* parses HTTP request headers.
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* headers
+	* request
+	* xml_encoding
+	* SOAPAction
+	*
+	* @access   private
+	*/
+	function parse_http_headers() {
+		global $HTTP_SERVER_VARS;
+
+		$this->request = '';
+		$this->SOAPAction = '';
+		if(function_exists('getallheaders')){
+			$this->debug("In parse_http_headers, use getallheaders");
+			$headers = getallheaders();
+			foreach($headers as $k=>$v){
+				$k = strtolower($k);
+				$this->headers[$k] = $v;
+				$this->request .= "$k: $v\r\n";
+				$this->debug("$k: $v");
+			}
+			// get SOAPAction header
+			if(isset($this->headers['soapaction'])){
+				$this->SOAPAction = str_replace('"','',$this->headers['soapaction']);
+			}
+			// get the character encoding of the incoming request
+			if(isset($this->headers['content-type']) && strpos($this->headers['content-type'],'=')){
+				$enc = str_replace('"','',substr(strstr($this->headers["content-type"],'='),1));
+				if(preg_match('/^(ISO-8859-1|US-ASCII|UTF-8)$/i',$enc)){
+					$this->xml_encoding = strtoupper($enc);
+				} else {
+					$this->xml_encoding = 'US-ASCII';
+				}
+			} else {
+				// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+				$this->xml_encoding = 'ISO-8859-1';
+			}
+		} elseif(isset($_SERVER) && is_array($_SERVER)){
+			$this->debug("In parse_http_headers, use _SERVER");
+			foreach ($_SERVER as $k => $v) {
+				if (substr($k, 0, 5) == 'HTTP_') {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', substr($k, 5))));
+				} else {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', $k)));
+				}
+				if ($k == 'soapaction') {
+					// get SOAPAction header
+					$k = 'SOAPAction';
+					$v = str_replace('"', '', $v);
+					$v = str_replace('\\', '', $v);
+					$this->SOAPAction = $v;
+				} else if ($k == 'content-type') {
+					// get the character encoding of the incoming request
+					if (strpos($v, '=')) {
+						$enc = substr(strstr($v, '='), 1);
+						$enc = str_replace('"', '', $enc);
+						$enc = str_replace('\\', '', $enc);
+						if (preg_match('/^(ISO-8859-1|US-ASCII|UTF-8)$/i',$enc)) {
+							$this->xml_encoding = strtoupper($enc);
+						} else {
+							$this->xml_encoding = 'US-ASCII';
+						}
+					} else {
+						// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+						$this->xml_encoding = 'ISO-8859-1';
+					}
+				}
+				$this->headers[$k] = $v;
+				$this->request .= "$k: $v\r\n";
+				$this->debug("$k: $v");
+			}
+		} elseif (is_array($HTTP_SERVER_VARS)) {
+			$this->debug("In parse_http_headers, use HTTP_SERVER_VARS");
+			foreach ($HTTP_SERVER_VARS as $k => $v) {
+				if (substr($k, 0, 5) == 'HTTP_') {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', substr($k, 5)))); 	                                         $k = strtolower(substr($k, 5));
+				} else {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', $k))); 	                                         $k = strtolower($k);
+				}
+				if ($k == 'soapaction') {
+					// get SOAPAction header
+					$k = 'SOAPAction';
+					$v = str_replace('"', '', $v);
+					$v = str_replace('\\', '', $v);
+					$this->SOAPAction = $v;
+				} else if ($k == 'content-type') {
+					// get the character encoding of the incoming request
+					if (strpos($v, '=')) {
+						$enc = substr(strstr($v, '='), 1);
+						$enc = str_replace('"', '', $enc);
+						$enc = str_replace('\\', '', $enc);
+						if (preg_match('/^(ISO-8859-1|US-ASCII|UTF-8)$/i',$enc)) {
+							$this->xml_encoding = strtoupper($enc);
+						} else {
+							$this->xml_encoding = 'US-ASCII';
+						}
+					} else {
+						// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+						$this->xml_encoding = 'ISO-8859-1';
+					}
+				}
+				$this->headers[$k] = $v;
+				$this->request .= "$k: $v\r\n";
+				$this->debug("$k: $v");
+			}
+		} else {
+			$this->debug("In parse_http_headers, HTTP headers not accessible");
+			$this->setError("HTTP headers not accessible");
+		}
+	}
+
+	/**
+	* parses a request
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* headers
+	* request
+	* xml_encoding
+	* SOAPAction
+	* request
+	* requestSOAP
+	* methodURI
+	* methodname
+	* methodparams
+	* requestHeaders
+	* document
+	*
+	* This sets the fault field on error
+	*
+	* @param    string $data XML string
+	* @access   private
+	*/
+	function parse_request($data='') {
+		$this->debug('entering parse_request()');
+		$this->parse_http_headers();
+		$this->debug('got character encoding: '.$this->xml_encoding);
+		// uncompress if necessary
+		if (isset($this->headers['content-encoding']) && $this->headers['content-encoding'] != '') {
+			$this->debug('got content encoding: ' . $this->headers['content-encoding']);
+			if ($this->headers['content-encoding'] == 'deflate' || $this->headers['content-encoding'] == 'gzip') {
+		    	// if decoding works, use it. else assume data wasn't gzencoded
+				if (function_exists('gzuncompress')) {
+					if ($this->headers['content-encoding'] == 'deflate' && $degzdata = @gzuncompress($data)) {
+						$data = $degzdata;
+					} elseif ($this->headers['content-encoding'] == 'gzip' && $degzdata = gzinflate(substr($data, 10))) {
+						$data = $degzdata;
+					} else {
+						$this->fault('SOAP-ENV:Client', 'Errors occurred when trying to decode the data');
+						return;
+					}
+				} else {
+					$this->fault('SOAP-ENV:Client', 'This Server does not support compressed data');
+					return;
+				}
+			}
+		}
+		$this->request .= "\r\n".$data;
+		$data = $this->parseRequest($this->headers, $data);
+		$this->requestSOAP = $data;
+		$this->debug('leaving parse_request');
+	}
+
+	/**
+	* invokes a PHP function for the requested SOAP method
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* methodreturn
+	*
+	* Note that the PHP function that is called may also set the following
+	* fields to affect the response sent to the client
+	*
+	* responseHeaders
+	* outgoing_headers
+	*
+	* This sets the fault field on error
+	*
+	* @access   private
+	*/
+	function invoke_method() {
+		$this->debug('in invoke_method, methodname=' . $this->methodname . ' methodURI=' . $this->methodURI . ' SOAPAction=' . $this->SOAPAction);
+
+		//
+		// if you are debugging in this area of the code, your service uses a class to implement methods,
+		// you use SOAP RPC, and the client is .NET, please be aware of the following...
+		// when the .NET wsdl.exe utility generates a proxy, it will remove the '.' or '..' from the
+		// method name.  that is fine for naming the .NET methods.  it is not fine for properly constructing
+		// the XML request and reading the XML response.  you need to add the RequestElementName and
+		// ResponseElementName to the System.Web.Services.Protocols.SoapRpcMethodAttribute that wsdl.exe
+		// generates for the method.  these parameters are used to specify the correct XML element names
+		// for .NET to use, i.e. the names with the '.' in them.
+		//
+		$orig_methodname = $this->methodname;
+		if ($this->wsdl) {
+			if ($this->opData = $this->wsdl->getOperationData($this->methodname)) {
+				$this->debug('in invoke_method, found WSDL operation=' . $this->methodname);
+				$this->appendDebug('opData=' . $this->varDump($this->opData));
+			} elseif ($this->opData = $this->wsdl->getOperationDataForSoapAction($this->SOAPAction)) {
+				// Note: hopefully this case will only be used for doc/lit, since rpc services should have wrapper element
+				$this->debug('in invoke_method, found WSDL soapAction=' . $this->SOAPAction . ' for operation=' . $this->opData['name']);
+				$this->appendDebug('opData=' . $this->varDump($this->opData));
+				$this->methodname = $this->opData['name'];
+			} else {
+				$this->debug('in invoke_method, no WSDL for operation=' . $this->methodname);
+				$this->fault('SOAP-ENV:Client', "Operation '" . $this->methodname . "' is not defined in the WSDL for this service");
+				return;
+			}
+		} else {
+			$this->debug('in invoke_method, no WSDL to validate method');
+		}
+
+		// if a . is present in $this->methodname, we see if there is a class in scope,
+		// which could be referred to. We will also distinguish between two deliminators,
+		// to allow methods to be called a the class or an instance
+		if (strpos($this->methodname, '..') > 0) {
+			$delim = '..';
+		} else if (strpos($this->methodname, '.') > 0) {
+			$delim = '.';
+		} else {
+			$delim = '';
+		}
+		$this->debug("in invoke_method, delim=$delim");
+
+		$class = '';
+		$method = '';
+		if (strlen($delim) > 0 && substr_count($this->methodname, $delim) == 1) {
+			$try_class = substr($this->methodname, 0, strpos($this->methodname, $delim));
+			if (class_exists($try_class)) {
+				// get the class and method name
+				$class = $try_class;
+				$method = substr($this->methodname, strpos($this->methodname, $delim) + strlen($delim));
+				$this->debug("in invoke_method, class=$class method=$method delim=$delim");
+			} else {
+				$this->debug("in invoke_method, class=$try_class not found");
+			}
+		} else {
+			$try_class = '';
+			$this->debug("in invoke_method, no class to try");
+		}
+
+		// does method exist?
+		if ($class == '') {
+			if (!function_exists($this->methodname)) {
+				$this->debug("in invoke_method, function '$this->methodname' not found!");
+				$this->result = 'fault: method not found';
+				$this->fault('SOAP-ENV:Client',"method '$this->methodname'('$orig_methodname') not defined in service('$try_class' '$delim')");
+				return;
+			}
+		} else {
+			$method_to_compare = (substr(phpversion(), 0, 2) == '4.') ? strtolower($method) : $method;
+			if (!in_array($method_to_compare, get_class_methods($class))) {
+				$this->debug("in invoke_method, method '$this->methodname' not found in class '$class'!");
+				$this->result = 'fault: method not found';
+				$this->fault('SOAP-ENV:Client',"method '$this->methodname'/'$method_to_compare'('$orig_methodname') not defined in service/'$class'('$try_class' '$delim')");
+				return;
+			}
+		}
+
+		// evaluate message, getting back parameters
+		// verify that request parameters match the method's signature
+		if(! $this->verify_method($this->methodname,$this->methodparams)){
+			// debug
+			$this->debug('ERROR: request not verified against method signature');
+			$this->result = 'fault: request failed validation against method signature';
+			// return fault
+			$this->fault('SOAP-ENV:Client',"Operation '$this->methodname' not defined in service.");
+			return;
+		}
+
+		// if there are parameters to pass
+		$this->debug('in invoke_method, params:');
+		$this->appendDebug($this->varDump($this->methodparams));
+		$this->debug("in invoke_method, calling '$this->methodname'");
+		if (!function_exists('call_user_func_array')) {
+			if ($class == '') {
+				$this->debug('in invoke_method, calling function using eval()');
+				$funcCall = "\$this->methodreturn = $this->methodname(";
+			} else {
+				if ($delim == '..') {
+					$this->debug('in invoke_method, calling class method using eval()');
+					$funcCall = "\$this->methodreturn = ".$class."::".$method."(";
+				} else {
+					$this->debug('in invoke_method, calling instance method using eval()');
+					// generate unique instance name
+					$instname = "\$inst_".time();
+					$funcCall = $instname." = new ".$class."(); ";
+					$funcCall .= "\$this->methodreturn = ".$instname."->".$method."(";
+				}
+			}
+			if ($this->methodparams) {
+				foreach ($this->methodparams as $param) {
+					if (is_array($param) || is_object($param)) {
+						$this->fault('SOAP-ENV:Client', 'NuSOAP does not handle complexType parameters correctly when using eval; call_user_func_array must be available');
+						return;
+					}
+					$funcCall .= "\"$param\",";
+				}
+				$funcCall = substr($funcCall, 0, -1);
+			}
+			$funcCall .= ');';
+			$this->debug('in invoke_method, function call: '.$funcCall);
+			@eval($funcCall);
+		} else {
+			if ($class == '') {
+				$this->debug('in invoke_method, calling function using call_user_func_array()');
+				$call_arg = "$this->methodname";	// straight assignment changes $this->methodname to lower case after call_user_func_array()
+			} elseif ($delim == '..') {
+				$this->debug('in invoke_method, calling class method using call_user_func_array()');
+				$call_arg = array ($class, $method);
+			} else {
+				$this->debug('in invoke_method, calling instance method using call_user_func_array()');
+				$instance = new $class ();
+				$call_arg = array(&$instance, $method);
+			}
+			if (is_array($this->methodparams)) {
+				$this->methodreturn = call_user_func_array($call_arg, array_values($this->methodparams));
+			} else {
+				$this->methodreturn = call_user_func_array($call_arg, array());
+			}
+		}
+        $this->debug('in invoke_method, methodreturn:');
+        $this->appendDebug($this->varDump($this->methodreturn));
+		$this->debug("in invoke_method, called method $this->methodname, received data of type ".gettype($this->methodreturn));
+	}
+
+	/**
+	* serializes the return value from a PHP function into a full SOAP Envelope
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* responseSOAP
+	*
+	* This sets the fault field on error
+	*
+	* @access   private
+	*/
+	function serialize_return() {
+		$this->debug('Entering serialize_return methodname: ' . $this->methodname . ' methodURI: ' . $this->methodURI);
+		// if fault
+		if (isset($this->methodreturn) && is_object($this->methodreturn) && ((get_class($this->methodreturn) == 'soap_fault') || (get_class($this->methodreturn) == 'nusoap_fault'))) {
+			$this->debug('got a fault object from method');
+			$this->fault = $this->methodreturn;
+			return;
+		} elseif ($this->methodreturnisliteralxml) {
+			$return_val = $this->methodreturn;
+		// returned value(s)
+		} else {
+			$this->debug('got a(n) '.gettype($this->methodreturn).' from method');
+			$this->debug('serializing return value');
+			if($this->wsdl){
+				if (sizeof($this->opData['output']['parts']) > 1) {
+					$this->debug('more than one output part, so use the method return unchanged');
+			    	$opParams = $this->methodreturn;
+			    } elseif (sizeof($this->opData['output']['parts']) == 1) {
+					$this->debug('exactly one output part, so wrap the method return in a simple array');
+					// TODO: verify that it is not already wrapped!
+			    	//foreach ($this->opData['output']['parts'] as $name => $type) {
+					//	$this->debug('wrap in element named ' . $name);
+			    	//}
+			    	$opParams = array($this->methodreturn);
+			    }
+			    $return_val = $this->wsdl->serializeRPCParameters($this->methodname,'output',$opParams);
+			    $this->appendDebug($this->wsdl->getDebug());
+			    $this->wsdl->clearDebug();
+				if($errstr = $this->wsdl->getError()){
+					$this->debug('got wsdl error: '.$errstr);
+					$this->fault('SOAP-ENV:Server', 'unable to serialize result');
+					return;
+				}
+			} else {
+				if (isset($this->methodreturn)) {
+					$return_val = $this->serialize_val($this->methodreturn, 'return');
+				} else {
+					$return_val = '';
+					$this->debug('in absence of WSDL, assume void return for backward compatibility');
+				}
+			}
+		}
+		$this->debug('return value:');
+		$this->appendDebug($this->varDump($return_val));
+
+		$this->debug('serializing response');
+		if ($this->wsdl) {
+			$this->debug('have WSDL for serialization: style is ' . $this->opData['style']);
+			if ($this->opData['style'] == 'rpc') {
+				$this->debug('style is rpc for serialization: use is ' . $this->opData['output']['use']);
+				if ($this->opData['output']['use'] == 'literal') {
+					// http://www.ws-i.org/Profiles/BasicProfile-1.1-2004-08-24.html R2735 says rpc/literal accessor elements should not be in a namespace
+					if ($this->methodURI) {
+						$payload = '<ns1:'.$this->methodname.'Response xmlns:ns1="'.$this->methodURI.'">'.$return_val.'</ns1:'.$this->methodname."Response>";
+					} else {
+						$payload = '<'.$this->methodname.'Response>'.$return_val.'</'.$this->methodname.'Response>';
+					}
+				} else {
+					if ($this->methodURI) {
+						$payload = '<ns1:'.$this->methodname.'Response xmlns:ns1="'.$this->methodURI.'">'.$return_val.'</ns1:'.$this->methodname."Response>";
+					} else {
+						$payload = '<'.$this->methodname.'Response>'.$return_val.'</'.$this->methodname.'Response>';
+					}
+				}
+			} else {
+				$this->debug('style is not rpc for serialization: assume document');
+				$payload = $return_val;
+			}
+		} else {
+			$this->debug('do not have WSDL for serialization: assume rpc/encoded');
+			$payload = '<ns1:'.$this->methodname.'Response xmlns:ns1="'.$this->methodURI.'">'.$return_val.'</ns1:'.$this->methodname."Response>";
+		}
+		$this->result = 'successful';
+		if($this->wsdl){
+			//if($this->debug_flag){
+            	$this->appendDebug($this->wsdl->getDebug());
+            //	}
+			if (isset($this->opData['output']['encodingStyle'])) {
+				$encodingStyle = $this->opData['output']['encodingStyle'];
+			} else {
+				$encodingStyle = '';
+			}
+			// Added: In case we use a WSDL, return a serialized env. WITH the usedNamespaces.
+			$this->responseSOAP = $this->serializeEnvelope($payload,$this->responseHeaders,$this->wsdl->usedNamespaces,$this->opData['style'],$this->opData['output']['use'],$encodingStyle);
+		} else {
+			$this->responseSOAP = $this->serializeEnvelope($payload,$this->responseHeaders);
+		}
+		$this->debug("Leaving serialize_return");
+	}
+
+	/**
+	* sends an HTTP response
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* outgoing_headers
+	* response
+	*
+	* @access   private
+	*/
+	function send_response() {
+		$this->debug('Enter send_response');
+		if ($this->fault) {
+			$payload = $this->fault->serialize();
+			$this->outgoing_headers[] = "HTTP/1.0 500 Internal Server Error";
+			$this->outgoing_headers[] = "Status: 500 Internal Server Error";
+		} else {
+			$payload = $this->responseSOAP;
+			// Some combinations of PHP+Web server allow the Status
+			// to come through as a header.  Since OK is the default
+			// just do nothing.
+			// $this->outgoing_headers[] = "HTTP/1.0 200 OK";
+			// $this->outgoing_headers[] = "Status: 200 OK";
+		}
+        // add debug data if in debug mode
+		if(isset($this->debug_flag) && $this->debug_flag){
+        	$payload .= $this->getDebugAsXMLComment();
+        }
+		$this->outgoing_headers[] = "Server: $this->title Server v$this->version";
+		preg_match('/\$Revisio' . 'n: ([^ ]+)/', $this->revision, $rev);
+		$this->outgoing_headers[] = "X-SOAP-Server: $this->title/$this->version (".$rev[1].")";
+		// Let the Web server decide about this
+		//$this->outgoing_headers[] = "Connection: Close\r\n";
+		$payload = $this->getHTTPBody($payload);
+		$type = $this->getHTTPContentType();
+		$charset = $this->getHTTPContentTypeCharset();
+		$this->outgoing_headers[] = "Content-Type: $type" . ($charset ? '; charset=' . $charset : '');
+		//begin code to compress payload - by John
+		// NOTE: there is no way to know whether the Web server will also compress
+		// this data.
+		if (strlen($payload) > 1024 && isset($this->headers) && isset($this->headers['accept-encoding'])) {	
+			if (strstr($this->headers['accept-encoding'], 'gzip')) {
+				if (function_exists('gzencode')) {
+					if (isset($this->debug_flag) && $this->debug_flag) {
+						$payload .= "<!-- Content being gzipped -->";
+					}
+					$this->outgoing_headers[] = "Content-Encoding: gzip";
+					$payload = gzencode($payload);
+				} else {
+					if (isset($this->debug_flag) && $this->debug_flag) {
+						$payload .= "<!-- Content will not be gzipped: no gzencode -->";
+					}
+				}
+			} elseif (strstr($this->headers['accept-encoding'], 'deflate')) {
+				// Note: MSIE requires gzdeflate output (no Zlib header and checksum),
+				// instead of gzcompress output,
+				// which conflicts with HTTP 1.1 spec (http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.5)
+				if (function_exists('gzdeflate')) {
+					if (isset($this->debug_flag) && $this->debug_flag) {
+						$payload .= "<!-- Content being deflated -->";
+					}
+					$this->outgoing_headers[] = "Content-Encoding: deflate";
+					$payload = gzdeflate($payload);
+				} else {
+					if (isset($this->debug_flag) && $this->debug_flag) {
+						$payload .= "<!-- Content will not be deflated: no gzcompress -->";
+					}
+				}
+			}
+		}
+		//end code
+		$this->outgoing_headers[] = "Content-Length: ".strlen($payload);
+		reset($this->outgoing_headers);
+		foreach($this->outgoing_headers as $hdr){
+			header($hdr, false);
+		}
+		print $payload;
+		$this->response = join("\r\n",$this->outgoing_headers)."\r\n\r\n".$payload;
+	}
+
+	/**
+	* takes the value that was created by parsing the request
+	* and compares to the method's signature, if available.
+	*
+	* @param	string	$operation	The operation to be invoked
+	* @param	array	$request	The array of parameter values
+	* @return	boolean	Whether the operation was found
+	* @access   private
+	*/
+	function verify_method($operation,$request){
+		if(isset($this->wsdl) && is_object($this->wsdl)){
+			if($this->wsdl->getOperationData($operation)){
+				return true;
+			}
+	    } elseif(isset($this->operations[$operation])){
+			return true;
+		}
+		return false;
+	}
+
+	/**
+	* processes SOAP message received from client
+	*
+	* @param	array	$headers	The HTTP headers
+	* @param	string	$data		unprocessed request data from client
+	* @return	mixed	value of the message, decoded into a PHP type
+	* @access   private
+	*/
+    function parseRequest($headers, $data) {
+		$this->debug('Entering parseRequest() for data of length ' . strlen($data) . ' headers:');
+		$this->appendDebug($this->varDump($headers));
+    	if (!isset($headers['content-type'])) {
+			$this->setError('Request not of type text/xml (no content-type header)');
+			return false;
+    	}
+		if (!strstr($headers['content-type'], 'text/xml')) {
+			$this->setError('Request not of type text/xml');
+			return false;
+		}
+		if (strpos($headers['content-type'], '=')) {
+			$enc = str_replace('"', '', substr(strstr($headers["content-type"], '='), 1));
+			$this->debug('Got response encoding: ' . $enc);
+			if(preg_match('/^(ISO-8859-1|US-ASCII|UTF-8)$/i',$enc)){
+				$this->xml_encoding = strtoupper($enc);
+			} else {
+				$this->xml_encoding = 'US-ASCII';
+			}
+		} else {
+			// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+			$this->xml_encoding = 'ISO-8859-1';
+		}
+		$this->debug('Use encoding: ' . $this->xml_encoding . ' when creating nusoap_parser');
+		// parse response, get soap parser obj
+		$parser = new nusoap_parser($data,$this->xml_encoding,'',$this->decode_utf8);
+		// parser debug
+		$this->debug("parser debug: \n".$parser->getDebug());
+		// if fault occurred during message parsing
+		if($err = $parser->getError()){
+			$this->result = 'fault: error in msg parsing: '.$err;
+			$this->fault('SOAP-ENV:Client',"error in msg parsing:\n".$err);
+		// else successfully parsed request into soapval object
+		} else {
+			// get/set methodname
+			$this->methodURI = $parser->root_struct_namespace;
+			$this->methodname = $parser->root_struct_name;
+			$this->debug('methodname: '.$this->methodname.' methodURI: '.$this->methodURI);
+			$this->debug('calling parser->get_soapbody()');
+			$this->methodparams = $parser->get_soapbody();
+			// get SOAP headers
+			$this->requestHeaders = $parser->getHeaders();
+			// get SOAP Header
+			$this->requestHeader = $parser->get_soapheader();
+            // add document for doclit support
+            $this->document = $parser->document;
+		}
+	 }
+
+	/**
+	* gets the HTTP body for the current response.
+	*
+	* @param string $soapmsg The SOAP payload
+	* @return string The HTTP body, which includes the SOAP payload
+	* @access private
+	*/
+	function getHTTPBody($soapmsg) {
+		return $soapmsg;
+	}
+	
+	/**
+	* gets the HTTP content type for the current response.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type for the current response.
+	* @access private
+	*/
+	function getHTTPContentType() {
+		return 'text/xml';
+	}
+	
+	/**
+	* gets the HTTP content type charset for the current response.
+	* returns false for non-text content types.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type charset for the current response.
+	* @access private
+	*/
+	function getHTTPContentTypeCharset() {
+		return $this->soap_defencoding;
+	}
+
+	/**
+	* add a method to the dispatch map (this has been replaced by the register method)
+	*
+	* @param    string $methodname
+	* @param    string $in array of input values
+	* @param    string $out array of output values
+	* @access   public
+	* @deprecated
+	*/
+	function add_to_map($methodname,$in,$out){
+			$this->operations[$methodname] = array('name' => $methodname,'in' => $in,'out' => $out);
+	}
+
+	/**
+	* register a service function with the server
+	*
+	* @param    string $name the name of the PHP function, class.method or class..method
+	* @param    array $in assoc array of input values: key = param name, value = param type
+	* @param    array $out assoc array of output values: key = param name, value = param type
+	* @param	mixed $namespace the element namespace for the method or false
+	* @param	mixed $soapaction the soapaction for the method or false
+	* @param	mixed $style optional (rpc|document) or false Note: when 'document' is specified, parameter and return wrappers are created for you automatically
+	* @param	mixed $use optional (encoded|literal) or false
+	* @param	string $documentation optional Description to include in WSDL
+	* @param	string $encodingStyle optional (usually 'http://schemas.xmlsoap.org/soap/encoding/' for encoded)
+	* @access   public
+	*/
+	function register($name,$in=array(),$out=array(),$namespace=false,$soapaction=false,$style=false,$use=false,$documentation='',$encodingStyle=''){
+		global $HTTP_SERVER_VARS;
+
+		if($this->externalWSDLURL){
+			die('You cannot bind to an external WSDL file, and register methods outside of it! Please choose either WSDL or no WSDL.');
+		}
+		if (! $name) {
+			die('You must specify a name when you register an operation');
+		}
+		if (!is_array($in)) {
+			die('You must provide an array for operation inputs');
+		}
+		if (!is_array($out)) {
+			die('You must provide an array for operation outputs');
+		}
+		if(false == $namespace) {
+		}
+		if(false == $soapaction) {
+			if (isset($_SERVER)) {
+				$SERVER_NAME = $_SERVER['SERVER_NAME'];
+				$SCRIPT_NAME = isset($_SERVER['PHP_SELF']) ? $_SERVER['PHP_SELF'] : $_SERVER['SCRIPT_NAME'];
+				$HTTPS = isset($_SERVER['HTTPS']) ? $_SERVER['HTTPS'] : (isset($HTTP_SERVER_VARS['HTTPS']) ? $HTTP_SERVER_VARS['HTTPS'] : 'off');
+			} elseif (isset($HTTP_SERVER_VARS)) {
+				$SERVER_NAME = $HTTP_SERVER_VARS['SERVER_NAME'];
+				$SCRIPT_NAME = isset($HTTP_SERVER_VARS['PHP_SELF']) ? $HTTP_SERVER_VARS['PHP_SELF'] : $HTTP_SERVER_VARS['SCRIPT_NAME'];
+				$HTTPS = isset($HTTP_SERVER_VARS['HTTPS']) ? $HTTP_SERVER_VARS['HTTPS'] : 'off';
+			} else {
+				$this->setError("Neither _SERVER nor HTTP_SERVER_VARS is available");
+			}
+        	if ($HTTPS == '1' || $HTTPS == 'on') {
+        		$SCHEME = 'https';
+        	} else {
+        		$SCHEME = 'http';
+        	}
+			$soapaction = "$SCHEME://$SERVER_NAME$SCRIPT_NAME/$name";
+		}
+		if(false == $style) {
+			$style = "rpc";
+		}
+		if(false == $use) {
+			$use = "encoded";
+		}
+		if ($use == 'encoded' && $encodingStyle == '') {
+			$encodingStyle = 'http://schemas.xmlsoap.org/soap/encoding/';
+		}
+
+		$this->operations[$name] = array(
+	    'name' => $name,
+	    'in' => $in,
+	    'out' => $out,
+	    'namespace' => $namespace,
+	    'soapaction' => $soapaction,
+	    'style' => $style);
+        if($this->wsdl){
+        	$this->wsdl->addOperation($name,$in,$out,$namespace,$soapaction,$style,$use,$documentation,$encodingStyle);
+	    }
+		return true;
+	}
+
+	/**
+	* Specify a fault to be returned to the client.
+	* This also acts as a flag to the server that a fault has occured.
+	*
+	* @param	string $faultcode
+	* @param	string $faultstring
+	* @param	string $faultactor
+	* @param	string $faultdetail
+	* @access   public
+	*/
+	function fault($faultcode,$faultstring,$faultactor='',$faultdetail=''){
+		if ($faultdetail == '' && $this->debug_flag) {
+			$faultdetail = $this->getDebug();
+		}
+		$this->fault = new nusoap_fault($faultcode,$faultactor,$faultstring,$faultdetail);
+		$this->fault->soap_defencoding = $this->soap_defencoding;
+	}
+
+    /**
+    * Sets up wsdl object.
+    * Acts as a flag to enable internal WSDL generation
+    *
+    * @param string $serviceName, name of the service
+    * @param mixed $namespace optional 'tns' service namespace or false
+    * @param mixed $endpoint optional URL of service endpoint or false
+    * @param string $style optional (rpc|document) WSDL style (also specified by operation)
+    * @param string $transport optional SOAP transport
+    * @param mixed $schemaTargetNamespace optional 'types' targetNamespace for service schema or false
+    */
+    function configureWSDL($serviceName,$namespace = false,$endpoint = false,$style='rpc', $transport = 'http://schemas.xmlsoap.org/soap/http', $schemaTargetNamespace = false)
+    {
+    	global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER)) {
+			$SERVER_NAME = $_SERVER['SERVER_NAME'];
+			$SERVER_PORT = $_SERVER['SERVER_PORT'];
+			$SCRIPT_NAME = isset($_SERVER['PHP_SELF']) ? $_SERVER['PHP_SELF'] : $_SERVER['SCRIPT_NAME'];
+			$HTTPS = isset($_SERVER['HTTPS']) ? $_SERVER['HTTPS'] : (isset($HTTP_SERVER_VARS['HTTPS']) ? $HTTP_SERVER_VARS['HTTPS'] : 'off');
+		} elseif (isset($HTTP_SERVER_VARS)) {
+			$SERVER_NAME = $HTTP_SERVER_VARS['SERVER_NAME'];
+			$SERVER_PORT = $HTTP_SERVER_VARS['SERVER_PORT'];
+			$SCRIPT_NAME = isset($HTTP_SERVER_VARS['PHP_SELF']) ? $HTTP_SERVER_VARS['PHP_SELF'] : $HTTP_SERVER_VARS['SCRIPT_NAME'];
+			$HTTPS = isset($HTTP_SERVER_VARS['HTTPS']) ? $HTTP_SERVER_VARS['HTTPS'] : 'off';
+		} else {
+			$this->setError("Neither _SERVER nor HTTP_SERVER_VARS is available");
+		}
+		// If server name has port number attached then strip it (else port number gets duplicated in WSDL output) (occurred using lighttpd and FastCGI)
+		$colon = strpos($SERVER_NAME,":");
+		if ($colon) {
+		    $SERVER_NAME = substr($SERVER_NAME, 0, $colon);
+		}
+		if ($SERVER_PORT == 80) {
+			$SERVER_PORT = '';
+		} else {
+			$SERVER_PORT = ':' . $SERVER_PORT;
+		}
+        if(false == $namespace) {
+            $namespace = "http://$SERVER_NAME/soap/$serviceName";
+        }
+        
+        if(false == $endpoint) {
+        	if ($HTTPS == '1' || $HTTPS == 'on') {
+        		$SCHEME = 'https';
+        	} else {
+        		$SCHEME = 'http';
+        	}
+            $endpoint = "$SCHEME://$SERVER_NAME$SERVER_PORT$SCRIPT_NAME";
+        }
+        
+        if(false == $schemaTargetNamespace) {
+            $schemaTargetNamespace = $namespace;
+        }
+        
+		$this->wsdl = new wsdl;
+		$this->wsdl->serviceName = $serviceName;
+        $this->wsdl->endpoint = $endpoint;
+		$this->wsdl->namespaces['tns'] = $namespace;
+		$this->wsdl->namespaces['soap'] = 'http://schemas.xmlsoap.org/wsdl/soap/';
+		$this->wsdl->namespaces['wsdl'] = 'http://schemas.xmlsoap.org/wsdl/';
+		if ($schemaTargetNamespace != $namespace) {
+			$this->wsdl->namespaces['types'] = $schemaTargetNamespace;
+		}
+        $this->wsdl->schemas[$schemaTargetNamespace][0] = new nusoap_xmlschema('', '', $this->wsdl->namespaces);
+        if ($style == 'document') {
+	        $this->wsdl->schemas[$schemaTargetNamespace][0]->schemaInfo['elementFormDefault'] = 'qualified';
+        }
+        $this->wsdl->schemas[$schemaTargetNamespace][0]->schemaTargetNamespace = $schemaTargetNamespace;
+        $this->wsdl->schemas[$schemaTargetNamespace][0]->imports['http://schemas.xmlsoap.org/soap/encoding/'][0] = array('location' => '', 'loaded' => true);
+        $this->wsdl->schemas[$schemaTargetNamespace][0]->imports['http://schemas.xmlsoap.org/wsdl/'][0] = array('location' => '', 'loaded' => true);
+        $this->wsdl->bindings[$serviceName.'Binding'] = array(
+        	'name'=>$serviceName.'Binding',
+            'style'=>$style,
+            'transport'=>$transport,
+            'portType'=>$serviceName.'PortType');
+        $this->wsdl->ports[$serviceName.'Port'] = array(
+        	'binding'=>$serviceName.'Binding',
+            'location'=>$endpoint,
+            'bindingType'=>'http://schemas.xmlsoap.org/wsdl/soap/');
+    }
+}
+
+/**
+ * Backward compatibility
+ */
+class soap_server extends nusoap_server {
+}
+
+?><?php
+
+
+
+/**
+* parses a WSDL file, allows access to it's data, other utility methods.
+* also builds WSDL structures programmatically.
+* 
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @version  $Id: nusoap.php,v 1.123 2010/04/26 20:15:08 snichol Exp $
+* @access public 
+*/
+class wsdl extends nusoap_base {
+	// URL or filename of the root of this WSDL
+    var $wsdl; 
+    // define internal arrays of bindings, ports, operations, messages, etc.
+    var $schemas = array();
+    var $currentSchema;
+    var $message = array();
+    var $complexTypes = array();
+    var $messages = array();
+    var $currentMessage;
+    var $currentOperation;
+    var $portTypes = array();
+    var $currentPortType;
+    var $bindings = array();
+    var $currentBinding;
+    var $ports = array();
+    var $currentPort;
+    var $opData = array();
+    var $status = '';
+    var $documentation = false;
+    var $endpoint = ''; 
+    // array of wsdl docs to import
+    var $import = array(); 
+    // parser vars
+    var $parser;
+    var $position = 0;
+    var $depth = 0;
+    var $depth_array = array();
+	// for getting wsdl
+	var $proxyhost = '';
+    var $proxyport = '';
+	var $proxyusername = '';
+	var $proxypassword = '';
+	var $timeout = 0;
+	var $response_timeout = 30;
+	var $curl_options = array();	// User-specified cURL options
+	var $use_curl = false;			// whether to always try to use cURL
+	// for HTTP authentication
+	var $username = '';				// Username for HTTP authentication
+	var $password = '';				// Password for HTTP authentication
+	var $authtype = '';				// Type of HTTP authentication
+	var $certRequest = array();		// Certificate for HTTP SSL authentication
+
+    /**
+     * constructor
+     * 
+     * @param string $wsdl WSDL document URL
+	 * @param string $proxyhost
+	 * @param string $proxyport
+	 * @param string $proxyusername
+	 * @param string $proxypassword
+	 * @param integer $timeout set the connection timeout
+	 * @param integer $response_timeout set the response timeout
+	 * @param array $curl_options user-specified cURL options
+	 * @param boolean $use_curl try to use cURL
+     * @access public 
+     */
+    function wsdl($wsdl = '',$proxyhost=false,$proxyport=false,$proxyusername=false,$proxypassword=false,$timeout=0,$response_timeout=30,$curl_options=null,$use_curl=false){
+		parent::nusoap_base();
+		$this->debug("ctor wsdl=$wsdl timeout=$timeout response_timeout=$response_timeout");
+        $this->proxyhost = $proxyhost;
+        $this->proxyport = $proxyport;
+		$this->proxyusername = $proxyusername;
+		$this->proxypassword = $proxypassword;
+		$this->timeout = $timeout;
+		$this->response_timeout = $response_timeout;
+		if (is_array($curl_options))
+			$this->curl_options = $curl_options;
+		$this->use_curl = $use_curl;
+		$this->fetchWSDL($wsdl);
+    }
+
+	/**
+	 * fetches the WSDL document and parses it
+	 *
+	 * @access public
+	 */
+	function fetchWSDL($wsdl) {
+		$this->debug("parse and process WSDL path=$wsdl");
+		$this->wsdl = $wsdl;
+        // parse wsdl file
+        if ($this->wsdl != "") {
+            $this->parseWSDL($this->wsdl);
+        }
+        // imports
+        // TODO: handle imports more properly, grabbing them in-line and nesting them
+    	$imported_urls = array();
+    	$imported = 1;
+    	while ($imported > 0) {
+    		$imported = 0;
+    		// Schema imports
+    		foreach ($this->schemas as $ns => $list) {
+    			foreach ($list as $xs) {
+					$wsdlparts = parse_url($this->wsdl);	// this is bogusly simple!
+		            foreach ($xs->imports as $ns2 => $list2) {
+		                for ($ii = 0; $ii < count($list2); $ii++) {
+		                	if (! $list2[$ii]['loaded']) {
+		                		$this->schemas[$ns]->imports[$ns2][$ii]['loaded'] = true;
+		                		$url = $list2[$ii]['location'];
+								if ($url != '') {
+									$urlparts = parse_url($url);
+									if (!isset($urlparts['host'])) {
+										$url = $wsdlparts['scheme'] . '://' . $wsdlparts['host'] . (isset($wsdlparts['port']) ? ':' .$wsdlparts['port'] : '') .
+												substr($wsdlparts['path'],0,strrpos($wsdlparts['path'],'/') + 1) .$urlparts['path'];
+									}
+									if (! in_array($url, $imported_urls)) {
+					                	$this->parseWSDL($url);
+				                		$imported++;
+				                		$imported_urls[] = $url;
+				                	}
+								} else {
+									$this->debug("Unexpected scenario: empty URL for unloaded import");
+								}
+							}
+						}
+		            } 
+    			}
+    		}
+    		// WSDL imports
+			$wsdlparts = parse_url($this->wsdl);	// this is bogusly simple!
+            foreach ($this->import as $ns => $list) {
+                for ($ii = 0; $ii < count($list); $ii++) {
+                	if (! $list[$ii]['loaded']) {
+                		$this->import[$ns][$ii]['loaded'] = true;
+                		$url = $list[$ii]['location'];
+						if ($url != '') {
+							$urlparts = parse_url($url);
+							if (!isset($urlparts['host'])) {
+								$url = $wsdlparts['scheme'] . '://' . $wsdlparts['host'] . (isset($wsdlparts['port']) ? ':' . $wsdlparts['port'] : '') .
+										substr($wsdlparts['path'],0,strrpos($wsdlparts['path'],'/') + 1) .$urlparts['path'];
+							}
+							if (! in_array($url, $imported_urls)) {
+			                	$this->parseWSDL($url);
+		                		$imported++;
+		                		$imported_urls[] = $url;
+		                	}
+						} else {
+							$this->debug("Unexpected scenario: empty URL for unloaded import");
+						}
+					}
+				}
+            } 
+		}
+        // add new data to operation data
+        foreach($this->bindings as $binding => $bindingData) {
+            if (isset($bindingData['operations']) && is_array($bindingData['operations'])) {
+                foreach($bindingData['operations'] as $operation => $data) {
+                    $this->debug('post-parse data gathering for ' . $operation);
+                    $this->bindings[$binding]['operations'][$operation]['input'] = 
+						isset($this->bindings[$binding]['operations'][$operation]['input']) ? 
+						array_merge($this->bindings[$binding]['operations'][$operation]['input'], $this->portTypes[ $bindingData['portType'] ][$operation]['input']) :
+						$this->portTypes[ $bindingData['portType'] ][$operation]['input'];
+                    $this->bindings[$binding]['operations'][$operation]['output'] = 
+						isset($this->bindings[$binding]['operations'][$operation]['output']) ?
+						array_merge($this->bindings[$binding]['operations'][$operation]['output'], $this->portTypes[ $bindingData['portType'] ][$operation]['output']) :
+						$this->portTypes[ $bindingData['portType'] ][$operation]['output'];
+                    if(isset($this->messages[ $this->bindings[$binding]['operations'][$operation]['input']['message'] ])){
+						$this->bindings[$binding]['operations'][$operation]['input']['parts'] = $this->messages[ $this->bindings[$binding]['operations'][$operation]['input']['message'] ];
+					}
+					if(isset($this->messages[ $this->bindings[$binding]['operations'][$operation]['output']['message'] ])){
+                   		$this->bindings[$binding]['operations'][$operation]['output']['parts'] = $this->messages[ $this->bindings[$binding]['operations'][$operation]['output']['message'] ];
+                    }
+                    // Set operation style if necessary, but do not override one already provided
+					if (isset($bindingData['style']) && !isset($this->bindings[$binding]['operations'][$operation]['style'])) {
+                        $this->bindings[$binding]['operations'][$operation]['style'] = $bindingData['style'];
+                    }
+                    $this->bindings[$binding]['operations'][$operation]['transport'] = isset($bindingData['transport']) ? $bindingData['transport'] : '';
+                    $this->bindings[$binding]['operations'][$operation]['documentation'] = isset($this->portTypes[ $bindingData['portType'] ][$operation]['documentation']) ? $this->portTypes[ $bindingData['portType'] ][$operation]['documentation'] : '';
+                    $this->bindings[$binding]['operations'][$operation]['endpoint'] = isset($bindingData['endpoint']) ? $bindingData['endpoint'] : '';
+                } 
+            } 
+        }
+	}
+
+    /**
+     * parses the wsdl document
+     * 
+     * @param string $wsdl path or URL
+     * @access private 
+     */
+    function parseWSDL($wsdl = '') {
+		$this->debug("parse WSDL at path=$wsdl");
+
+        if ($wsdl == '') {
+            $this->debug('no wsdl passed to parseWSDL()!!');
+            $this->setError('no wsdl passed to parseWSDL()!!');
+            return false;
+        }
+        
+        // parse $wsdl for url format
+        $wsdl_props = parse_url($wsdl);
+
+        if (isset($wsdl_props['scheme']) && ($wsdl_props['scheme'] == 'http' || $wsdl_props['scheme'] == 'https')) {
+            $this->debug('getting WSDL http(s) URL ' . $wsdl);
+        	// get wsdl
+	        $tr = new soap_transport_http($wsdl, $this->curl_options, $this->use_curl);
+			$tr->request_method = 'GET';
+			$tr->useSOAPAction = false;
+			if($this->proxyhost && $this->proxyport){
+				$tr->setProxy($this->proxyhost,$this->proxyport,$this->proxyusername,$this->proxypassword);
+			}
+			if ($this->authtype != '') {
+				$tr->setCredentials($this->username, $this->password, $this->authtype, array(), $this->certRequest);
+			}
+			$tr->setEncoding('gzip, deflate');
+			$wsdl_string = $tr->send('', $this->timeout, $this->response_timeout);
+			//$this->debug("WSDL request\n" . $tr->outgoing_payload);
+			//$this->debug("WSDL response\n" . $tr->incoming_payload);
+			$this->appendDebug($tr->getDebug());
+			// catch errors
+			if($err = $tr->getError() ){
+				$errstr = 'Getting ' . $wsdl . ' - HTTP ERROR: '.$err;
+				$this->debug($errstr);
+	            $this->setError($errstr);
+				unset($tr);
+	            return false;
+			}
+			unset($tr);
+			$this->debug("got WSDL URL");
+        } else {
+            // $wsdl is not http(s), so treat it as a file URL or plain file path
+        	if (isset($wsdl_props['scheme']) && ($wsdl_props['scheme'] == 'file') && isset($wsdl_props['path'])) {
+        		$path = isset($wsdl_props['host']) ? ($wsdl_props['host'] . ':' . $wsdl_props['path']) : $wsdl_props['path'];
+        	} else {
+        		$path = $wsdl;
+        	}
+            $this->debug('getting WSDL file ' . $path);
+            if ($fp = @fopen($path, 'r')) {
+                $wsdl_string = '';
+                while ($data = fread($fp, 32768)) {
+                    $wsdl_string .= $data;
+                } 
+                fclose($fp);
+            } else {
+            	$errstr = "Bad path to WSDL file $path";
+            	$this->debug($errstr);
+                $this->setError($errstr);
+                return false;
+            } 
+        }
+        $this->debug('Parse WSDL');
+        // end new code added
+        // Create an XML parser.
+        $this->parser = xml_parser_create(); 
+        // Set the options for parsing the XML data.
+        // xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);
+        xml_parser_set_option($this->parser, XML_OPTION_CASE_FOLDING, 0); 
+        // Set the object for the parser.
+        xml_set_object($this->parser, $this); 
+        // Set the element handlers for the parser.
+        xml_set_element_handler($this->parser, 'start_element', 'end_element');
+        xml_set_character_data_handler($this->parser, 'character_data');
+        // Parse the XML file.
+        if (!xml_parse($this->parser, $wsdl_string, true)) {
+            // Display an error message.
+            $errstr = sprintf(
+				'XML error parsing WSDL from %s on line %d: %s',
+				$wsdl,
+                xml_get_current_line_number($this->parser),
+                xml_error_string(xml_get_error_code($this->parser))
+                );
+            $this->debug($errstr);
+			$this->debug("XML payload:\n" . $wsdl_string);
+            $this->setError($errstr);
+            return false;
+        } 
+		// free the parser
+        xml_parser_free($this->parser);
+        $this->debug('Parsing WSDL done');
+		// catch wsdl parse errors
+		if($this->getError()){
+			return false;
+		}
+        return true;
+    } 
+
+    /**
+     * start-element handler
+     * 
+     * @param string $parser XML parser object
+     * @param string $name element name
+     * @param string $attrs associative array of attributes
+     * @access private 
+     */
+    function start_element($parser, $name, $attrs)
+    {
+        if ($this->status == 'schema') {
+            $this->currentSchema->schemaStartElement($parser, $name, $attrs);
+            $this->appendDebug($this->currentSchema->getDebug());
+            $this->currentSchema->clearDebug();
+        } elseif (preg_match('/schema$/', $name)) {
+        	$this->debug('Parsing WSDL schema');
+            // $this->debug("startElement for $name ($attrs[name]). status = $this->status (".$this->getLocalPart($name).")");
+            $this->status = 'schema';
+            $this->currentSchema = new nusoap_xmlschema('', '', $this->namespaces);
+            $this->currentSchema->schemaStartElement($parser, $name, $attrs);
+            $this->appendDebug($this->currentSchema->getDebug());
+            $this->currentSchema->clearDebug();
+        } else {
+            // position in the total number of elements, starting from 0
+            $pos = $this->position++;
+            $depth = $this->depth++; 
+            // set self as current value for this depth
+            $this->depth_array[$depth] = $pos;
+            $this->message[$pos] = array('cdata' => ''); 
+            // process attributes
+            if (count($attrs) > 0) {
+				// register namespace declarations
+                foreach($attrs as $k => $v) {
+                    if (preg_match('/^xmlns/',$k)) {
+                        if ($ns_prefix = substr(strrchr($k, ':'), 1)) {
+                            $this->namespaces[$ns_prefix] = $v;
+                        } else {
+                            $this->namespaces['ns' . (count($this->namespaces) + 1)] = $v;
+                        } 
+                        if ($v == 'http://www.w3.org/2001/XMLSchema' || $v == 'http://www.w3.org/1999/XMLSchema' || $v == 'http://www.w3.org/2000/10/XMLSchema') {
+                            $this->XMLSchemaVersion = $v;
+                            $this->namespaces['xsi'] = $v . '-instance';
+                        } 
+                    }
+                }
+                // expand each attribute prefix to its namespace
+                foreach($attrs as $k => $v) {
+                    $k = strpos($k, ':') ? $this->expandQname($k) : $k;
+                    if ($k != 'location' && $k != 'soapAction' && $k != 'namespace') {
+                        $v = strpos($v, ':') ? $this->expandQname($v) : $v;
+                    } 
+                    $eAttrs[$k] = $v;
+                } 
+                $attrs = $eAttrs;
+            } else {
+                $attrs = array();
+            } 
+            // get element prefix, namespace and name
+            if (preg_match('/:/', $name)) {
+                // get ns prefix
+                $prefix = substr($name, 0, strpos($name, ':')); 
+                // get ns
+                $namespace = isset($this->namespaces[$prefix]) ? $this->namespaces[$prefix] : ''; 
+                // get unqualified name
+                $name = substr(strstr($name, ':'), 1);
+            } 
+			// process attributes, expanding any prefixes to namespaces
+            // find status, register data
+            switch ($this->status) {
+                case 'message':
+                    if ($name == 'part') {
+			            if (isset($attrs['type'])) {
+		                    $this->debug("msg " . $this->currentMessage . ": found part (with type) $attrs[name]: " . implode(',', $attrs));
+		                    $this->messages[$this->currentMessage][$attrs['name']] = $attrs['type'];
+            			} 
+			            if (isset($attrs['element'])) {
+		                    $this->debug("msg " . $this->currentMessage . ": found part (with element) $attrs[name]: " . implode(',', $attrs));
+			                $this->messages[$this->currentMessage][$attrs['name']] = $attrs['element'] . '^';
+			            } 
+        			} 
+        			break;
+			    case 'portType':
+			        switch ($name) {
+			            case 'operation':
+			                $this->currentPortOperation = $attrs['name'];
+			                $this->debug("portType $this->currentPortType operation: $this->currentPortOperation");
+			                if (isset($attrs['parameterOrder'])) {
+			                	$this->portTypes[$this->currentPortType][$attrs['name']]['parameterOrder'] = $attrs['parameterOrder'];
+			        		} 
+			        		break;
+					    case 'documentation':
+					        $this->documentation = true;
+					        break; 
+					    // merge input/output data
+					    default:
+					        $m = isset($attrs['message']) ? $this->getLocalPart($attrs['message']) : '';
+					        $this->portTypes[$this->currentPortType][$this->currentPortOperation][$name]['message'] = $m;
+					        break;
+					} 
+			    	break;
+				case 'binding':
+				    switch ($name) {
+				        case 'binding': 
+				            // get ns prefix
+				            if (isset($attrs['style'])) {
+				            $this->bindings[$this->currentBinding]['prefix'] = $prefix;
+					    	} 
+					    	$this->bindings[$this->currentBinding] = array_merge($this->bindings[$this->currentBinding], $attrs);
+					    	break;
+						case 'header':
+						    $this->bindings[$this->currentBinding]['operations'][$this->currentOperation][$this->opStatus]['headers'][] = $attrs;
+						    break;
+						case 'operation':
+						    if (isset($attrs['soapAction'])) {
+						        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation]['soapAction'] = $attrs['soapAction'];
+						    } 
+						    if (isset($attrs['style'])) {
+						        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation]['style'] = $attrs['style'];
+						    } 
+						    if (isset($attrs['name'])) {
+						        $this->currentOperation = $attrs['name'];
+						        $this->debug("current binding operation: $this->currentOperation");
+						        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation]['name'] = $attrs['name'];
+						        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation]['binding'] = $this->currentBinding;
+						        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation]['endpoint'] = isset($this->bindings[$this->currentBinding]['endpoint']) ? $this->bindings[$this->currentBinding]['endpoint'] : '';
+						    } 
+						    break;
+						case 'input':
+						    $this->opStatus = 'input';
+						    break;
+						case 'output':
+						    $this->opStatus = 'output';
+						    break;
+						case 'body':
+						    if (isset($this->bindings[$this->currentBinding]['operations'][$this->currentOperation][$this->opStatus])) {
+						        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation][$this->opStatus] = array_merge($this->bindings[$this->currentBinding]['operations'][$this->currentOperation][$this->opStatus], $attrs);
+						    } else {
+						        $this->bindings[$this->currentBinding]['operations'][$this->currentOperation][$this->opStatus] = $attrs;
+						    } 
+						    break;
+					} 
+					break;
+				case 'service':
+					switch ($name) {
+					    case 'port':
+					        $this->currentPort = $attrs['name'];
+					        $this->debug('current port: ' . $this->currentPort);
+					        $this->ports[$this->currentPort]['binding'] = $this->getLocalPart($attrs['binding']);
+					
+					        break;
+					    case 'address':
+					        $this->ports[$this->currentPort]['location'] = $attrs['location'];
+					        $this->ports[$this->currentPort]['bindingType'] = $namespace;
+					        $this->bindings[ $this->ports[$this->currentPort]['binding'] ]['bindingType'] = $namespace;
+					        $this->bindings[ $this->ports[$this->currentPort]['binding'] ]['endpoint'] = $attrs['location'];
+					        break;
+					} 
+					break;
+			} 
+		// set status
+		switch ($name) {
+			case 'import':
+			    if (isset($attrs['location'])) {
+                    $this->import[$attrs['namespace']][] = array('location' => $attrs['location'], 'loaded' => false);
+                    $this->debug('parsing import ' . $attrs['namespace']. ' - ' . $attrs['location'] . ' (' . count($this->import[$attrs['namespace']]).')');
+				} else {
+                    $this->import[$attrs['namespace']][] = array('location' => '', 'loaded' => true);
+					if (! $this->getPrefixFromNamespace($attrs['namespace'])) {
+						$this->namespaces['ns'.(count($this->namespaces)+1)] = $attrs['namespace'];
+					}
+                    $this->debug('parsing import ' . $attrs['namespace']. ' - [no location] (' . count($this->import[$attrs['namespace']]).')');
+				}
+				break;
+			//wait for schema
+			//case 'types':
+			//	$this->status = 'schema';
+			//	break;
+			case 'message':
+				$this->status = 'message';
+				$this->messages[$attrs['name']] = array();
+				$this->currentMessage = $attrs['name'];
+				break;
+			case 'portType':
+				$this->status = 'portType';
+				$this->portTypes[$attrs['name']] = array();
+				$this->currentPortType = $attrs['name'];
+				break;
+			case "binding":
+				if (isset($attrs['name'])) {
+				// get binding name
+					if (strpos($attrs['name'], ':')) {
+			    		$this->currentBinding = $this->getLocalPart($attrs['name']);
+					} else {
+			    		$this->currentBinding = $attrs['name'];
+					} 
+					$this->status = 'binding';
+					$this->bindings[$this->currentBinding]['portType'] = $this->getLocalPart($attrs['type']);
+					$this->debug("current binding: $this->currentBinding of portType: " . $attrs['type']);
+				} 
+				break;
+			case 'service':
+				$this->serviceName = $attrs['name'];
+				$this->status = 'service';
+				$this->debug('current service: ' . $this->serviceName);
+				break;
+			case 'definitions':
+				foreach ($attrs as $name => $value) {
+					$this->wsdl_info[$name] = $value;
+				} 
+				break;
+			} 
+		} 
+	} 
+
+	/**
+	* end-element handler
+	* 
+	* @param string $parser XML parser object
+	* @param string $name element name
+	* @access private 
+	*/
+	function end_element($parser, $name){ 
+		// unset schema status
+		if (/*preg_match('/types$/', $name) ||*/ preg_match('/schema$/', $name)) {
+			$this->status = "";
+            $this->appendDebug($this->currentSchema->getDebug());
+            $this->currentSchema->clearDebug();
+			$this->schemas[$this->currentSchema->schemaTargetNamespace][] = $this->currentSchema;
+        	$this->debug('Parsing WSDL schema done');
+		} 
+		if ($this->status == 'schema') {
+			$this->currentSchema->schemaEndElement($parser, $name);
+		} else {
+			// bring depth down a notch
+			$this->depth--;
+		} 
+		// end documentation
+		if ($this->documentation) {
+			//TODO: track the node to which documentation should be assigned; it can be a part, message, etc.
+			//$this->portTypes[$this->currentPortType][$this->currentPortOperation]['documentation'] = $this->documentation;
+			$this->documentation = false;
+		} 
+	} 
+
+	/**
+	 * element content handler
+	 * 
+	 * @param string $parser XML parser object
+	 * @param string $data element content
+	 * @access private 
+	 */
+	function character_data($parser, $data)
+	{
+		$pos = isset($this->depth_array[$this->depth]) ? $this->depth_array[$this->depth] : 0;
+		if (isset($this->message[$pos]['cdata'])) {
+			$this->message[$pos]['cdata'] .= $data;
+		} 
+		if ($this->documentation) {
+			$this->documentation .= $data;
+		} 
+	} 
+
+	/**
+	* if authenticating, set user credentials here
+	*
+	* @param    string $username
+	* @param    string $password
+	* @param	string $authtype (basic|digest|certificate|ntlm)
+	* @param	array $certRequest (keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, certpassword (optional), verifypeer (optional), verifyhost (optional): see corresponding options in cURL docs)
+	* @access   public
+	*/
+	function setCredentials($username, $password, $authtype = 'basic', $certRequest = array()) {
+		$this->debug("setCredentials username=$username authtype=$authtype certRequest=");
+		$this->appendDebug($this->varDump($certRequest));
+		$this->username = $username;
+		$this->password = $password;
+		$this->authtype = $authtype;
+		$this->certRequest = $certRequest;
+	}
+	
+	function getBindingData($binding)
+	{
+		if (is_array($this->bindings[$binding])) {
+			return $this->bindings[$binding];
+		} 
+	}
+	
+	/**
+	 * returns an assoc array of operation names => operation data
+	 * 
+	 * @param string $portName WSDL port name
+	 * @param string $bindingType eg: soap, smtp, dime (only soap and soap12 are currently supported)
+	 * @return array 
+	 * @access public 
+	 */
+	function getOperations($portName = '', $bindingType = 'soap') {
+		$ops = array();
+		if ($bindingType == 'soap') {
+			$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap/';
+		} elseif ($bindingType == 'soap12') {
+			$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap12/';
+		} else {
+			$this->debug("getOperations bindingType $bindingType may not be supported");
+		}
+		$this->debug("getOperations for port '$portName' bindingType $bindingType");
+		// loop thru ports
+		foreach($this->ports as $port => $portData) {
+			$this->debug("getOperations checking port $port bindingType " . $portData['bindingType']);
+			if ($portName == '' || $port == $portName) {
+				// binding type of port matches parameter
+				if ($portData['bindingType'] == $bindingType) {
+					$this->debug("getOperations found port $port bindingType $bindingType");
+					//$this->debug("port data: " . $this->varDump($portData));
+					//$this->debug("bindings: " . $this->varDump($this->bindings[ $portData['binding'] ]));
+					// merge bindings
+					if (isset($this->bindings[ $portData['binding'] ]['operations'])) {
+						$ops = array_merge ($ops, $this->bindings[ $portData['binding'] ]['operations']);
+					}
+				}
+			}
+		}
+		if (count($ops) == 0) {
+			$this->debug("getOperations found no operations for port '$portName' bindingType $bindingType");
+		}
+		return $ops;
+	} 
+	
+	/**
+	 * returns an associative array of data necessary for calling an operation
+	 * 
+	 * @param string $operation name of operation
+	 * @param string $bindingType type of binding eg: soap, soap12
+	 * @return array 
+	 * @access public 
+	 */
+	function getOperationData($operation, $bindingType = 'soap')
+	{
+		if ($bindingType == 'soap') {
+			$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap/';
+		} elseif ($bindingType == 'soap12') {
+			$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap12/';
+		}
+		// loop thru ports
+		foreach($this->ports as $port => $portData) {
+			// binding type of port matches parameter
+			if ($portData['bindingType'] == $bindingType) {
+				// get binding
+				//foreach($this->bindings[ $portData['binding'] ]['operations'] as $bOperation => $opData) {
+				foreach(array_keys($this->bindings[ $portData['binding'] ]['operations']) as $bOperation) {
+					// note that we could/should also check the namespace here
+					if ($operation == $bOperation) {
+						$opData = $this->bindings[ $portData['binding'] ]['operations'][$operation];
+					    return $opData;
+					} 
+				} 
+			}
+		} 
+	}
+	
+	/**
+	 * returns an associative array of data necessary for calling an operation
+	 * 
+	 * @param string $soapAction soapAction for operation
+	 * @param string $bindingType type of binding eg: soap, soap12
+	 * @return array 
+	 * @access public 
+	 */
+	function getOperationDataForSoapAction($soapAction, $bindingType = 'soap') {
+		if ($bindingType == 'soap') {
+			$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap/';
+		} elseif ($bindingType == 'soap12') {
+			$bindingType = 'http://schemas.xmlsoap.org/wsdl/soap12/';
+		}
+		// loop thru ports
+		foreach($this->ports as $port => $portData) {
+			// binding type of port matches parameter
+			if ($portData['bindingType'] == $bindingType) {
+				// loop through operations for the binding
+				foreach ($this->bindings[ $portData['binding'] ]['operations'] as $bOperation => $opData) {
+					if ($opData['soapAction'] == $soapAction) {
+					    return $opData;
+					} 
+				} 
+			}
+		} 
+	}
+	
+	/**
+    * returns an array of information about a given type
+    * returns false if no type exists by the given name
+    *
+	*	 typeDef = array(
+	*	 'elements' => array(), // refs to elements array
+	*	'restrictionBase' => '',
+	*	'phpType' => '',
+	*	'order' => '(sequence|all)',
+	*	'attrs' => array() // refs to attributes array
+	*	)
+    *
+    * @param string $type the type
+    * @param string $ns namespace (not prefix) of the type
+    * @return mixed
+    * @access public
+    * @see nusoap_xmlschema
+    */
+	function getTypeDef($type, $ns) {
+		$this->debug("in getTypeDef: type=$type, ns=$ns");
+		if ((! $ns) && isset($this->namespaces['tns'])) {
+			$ns = $this->namespaces['tns'];
+			$this->debug("in getTypeDef: type namespace forced to $ns");
+		}
+		if (!isset($this->schemas[$ns])) {
+			foreach ($this->schemas as $ns0 => $schema0) {
+				if (strcasecmp($ns, $ns0) == 0) {
+					$this->debug("in getTypeDef: replacing schema namespace $ns with $ns0");
+					$ns = $ns0;
+					break;
+				}
+			}
+		}
+		if (isset($this->schemas[$ns])) {
+			$this->debug("in getTypeDef: have schema for namespace $ns");
+			for ($i = 0; $i < count($this->schemas[$ns]); $i++) {
+				$xs = &$this->schemas[$ns][$i];
+				$t = $xs->getTypeDef($type);
+				$this->appendDebug($xs->getDebug());
+				$xs->clearDebug();
+				if ($t) {
+					$this->debug("in getTypeDef: found type $type");
+					if (!isset($t['phpType'])) {
+						// get info for type to tack onto the element
+						$uqType = substr($t['type'], strrpos($t['type'], ':') + 1);
+						$ns = substr($t['type'], 0, strrpos($t['type'], ':'));
+						$etype = $this->getTypeDef($uqType, $ns);
+						if ($etype) {
+							$this->debug("found type for [element] $type:");
+							$this->debug($this->varDump($etype));
+							if (isset($etype['phpType'])) {
+								$t['phpType'] = $etype['phpType'];
+							}
+							if (isset($etype['elements'])) {
+								$t['elements'] = $etype['elements'];
+							}
+							if (isset($etype['attrs'])) {
+								$t['attrs'] = $etype['attrs'];
+							}
+						} else {
+							$this->debug("did not find type for [element] $type");
+						}
+					}
+					return $t;
+				}
+			}
+			$this->debug("in getTypeDef: did not find type $type");
+		} else {
+			$this->debug("in getTypeDef: do not have schema for namespace $ns");
+		}
+		return false;
+	}
+
+    /**
+    * prints html description of services
+    *
+    * @access private
+    */
+    function webDescription(){
+    	global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER)) {
+			$PHP_SELF = $_SERVER['PHP_SELF'];
+		} elseif (isset($HTTP_SERVER_VARS)) {
+			$PHP_SELF = $HTTP_SERVER_VARS['PHP_SELF'];
+		} else {
+			$this->setError("Neither _SERVER nor HTTP_SERVER_VARS is available");
+		}
+
+		$b = '
+		<html><head><title>NuSOAP: '.$this->serviceName.'</title>
+		<style type="text/css">
+		    body    { font-family: arial; color: #000000; background-color: #ffffff; margin: 0px 0px 0px 0px; }
+		    p       { font-family: arial; color: #000000; margin-top: 0px; margin-bottom: 12px; }
+		    pre { background-color: silver; padding: 5px; font-family: Courier New; font-size: x-small; color: #000000;}
+		    ul      { margin-top: 10px; margin-left: 20px; }
+		    li      { list-style-type: none; margin-top: 10px; color: #000000; }
+		    .content{
+			margin-left: 0px; padding-bottom: 2em; }
+		    .nav {
+			padding-top: 10px; padding-bottom: 10px; padding-left: 15px; font-size: .70em;
+			margin-top: 10px; margin-left: 0px; color: #000000;
+			background-color: #ccccff; width: 20%; margin-left: 20px; margin-top: 20px; }
+		    .title {
+			font-family: arial; font-size: 26px; color: #ffffff;
+			background-color: #999999; width: 100%;
+			margin-left: 0px; margin-right: 0px;
+			padding-top: 10px; padding-bottom: 10px;}
+		    .hidden {
+			position: absolute; visibility: hidden; z-index: 200; left: 250px; top: 100px;
+			font-family: arial; overflow: hidden; width: 600;
+			padding: 20px; font-size: 10px; background-color: #999999;
+			layer-background-color:#FFFFFF; }
+		    a,a:active  { color: charcoal; font-weight: bold; }
+		    a:visited   { color: #666666; font-weight: bold; }
+		    a:hover     { color: cc3300; font-weight: bold; }
+		</style>
+		<script language="JavaScript" type="text/javascript">
+		<!--
+		// POP-UP CAPTIONS...
+		function lib_bwcheck(){ //Browsercheck (needed)
+		    this.ver=navigator.appVersion
+		    this.agent=navigator.userAgent
+		    this.dom=document.getElementById?1:0
+		    this.opera5=this.agent.indexOf("Opera 5")>-1
+		    this.ie5=(this.ver.indexOf("MSIE 5")>-1 && this.dom && !this.opera5)?1:0;
+		    this.ie6=(this.ver.indexOf("MSIE 6")>-1 && this.dom && !this.opera5)?1:0;
+		    this.ie4=(document.all && !this.dom && !this.opera5)?1:0;
+		    this.ie=this.ie4||this.ie5||this.ie6
+		    this.mac=this.agent.indexOf("Mac")>-1
+		    this.ns6=(this.dom && parseInt(this.ver) >= 5) ?1:0;
+		    this.ns4=(document.layers && !this.dom)?1:0;
+		    this.bw=(this.ie6 || this.ie5 || this.ie4 || this.ns4 || this.ns6 || this.opera5)
+		    return this
+		}
+		var bw = new lib_bwcheck()
+		//Makes crossbrowser object.
+		function makeObj(obj){
+		    this.evnt=bw.dom? document.getElementById(obj):bw.ie4?document.all[obj]:bw.ns4?document.layers[obj]:0;
+		    if(!this.evnt) return false
+		    this.css=bw.dom||bw.ie4?this.evnt.style:bw.ns4?this.evnt:0;
+		    this.wref=bw.dom||bw.ie4?this.evnt:bw.ns4?this.css.document:0;
+		    this.writeIt=b_writeIt;
+		    return this
+		}
+		// A unit of measure that will be added when setting the position of a layer.
+		//var px = bw.ns4||window.opera?"":"px";
+		function b_writeIt(text){
+		    if (bw.ns4){this.wref.write(text);this.wref.close()}
+		    else this.wref.innerHTML = text
+		}
+		//Shows the messages
+		var oDesc;
+		function popup(divid){
+		    if(oDesc = new makeObj(divid)){
+			oDesc.css.visibility = "visible"
+		    }
+		}
+		function popout(){ // Hides message
+		    if(oDesc) oDesc.css.visibility = "hidden"
+		}
+		//-->
+		</script>
+		</head>
+		<body>
+		<div class=content>
+			<br><br>
+			<div class=title>'.htmlentities($this->serviceName).'</div>
+			<div class=nav>
+				<p>View the <a href="'.htmlentities($PHP_SELF).'?wsdl">WSDL</a> for the service.
+				Click on an operation name to view it&apos;s details.</p>
+				<ul>';
+				foreach($this->getOperations() as $op => $data){
+				    $b .= "<li><a href='#' onclick=\"popout();popup('$op')\">$op</a></li>";
+				    // create hidden div
+				    $b .= "<div id='$op' class='hidden'>
+				    <a href='#' onclick='popout()'><font color='#ffffff'>Close</font></a><br><br>";
+				    foreach($data as $donnie => $marie){ // loop through opdata
+						if($donnie == 'input' || $donnie == 'output'){ // show input/output data
+						    $b .= "<font color='white'>".htmlentities(ucfirst($donnie)).':</font><br>';
+						    foreach($marie as $captain => $tenille){ // loop through data
+								if($captain == 'parts'){ // loop thru parts
+								    $b .= "&nbsp;&nbsp;".htmlentities($captain).":<br>";
+					                //if(is_array($tenille)){
+								    	foreach($tenille as $joanie => $chachi){
+											$b .= "&nbsp;&nbsp;&nbsp;&nbsp;".htmlentities($joanie).": ".htmlentities($chachi)."<br>";
+								    	}
+					        		//}
+								} else {
+								    $b .= "&nbsp;&nbsp;".htmlentities($captain).": ".htmlentities($tenille)."<br>";
+								}
+						    }
+						} else {
+						    $b .= "<font color='white'>".htmlentities(ucfirst($donnie)).":</font> ".htmlentities($marie)."<br>";
+						}
+				    }
+					$b .= '</div>';
+				}
+				$b .= '
+				<ul>
+			</div>
+		</div></body></html>';
+		return $b;
+    }
+
+	/**
+	* serialize the parsed wsdl
+	*
+	* @param mixed $debug whether to put debug=1 in endpoint URL
+	* @return string serialization of WSDL
+	* @access public 
+	*/
+	function serialize($debug = 0)
+	{
+		$xml = '<?xml version="1.0" encoding="ISO-8859-1"?>';
+		$xml .= "\n<definitions";
+		foreach($this->namespaces as $k => $v) {
+			$xml .= " xmlns:$k=\"$v\"";
+		} 
+		// 10.9.02 - add poulter fix for wsdl and tns declarations
+		if (isset($this->namespaces['wsdl'])) {
+			$xml .= " xmlns=\"" . $this->namespaces['wsdl'] . "\"";
+		} 
+		if (isset($this->namespaces['tns'])) {
+			$xml .= " targetNamespace=\"" . $this->namespaces['tns'] . "\"";
+		} 
+		$xml .= '>'; 
+		// imports
+		if (sizeof($this->import) > 0) {
+			foreach($this->import as $ns => $list) {
+				foreach ($list as $ii) {
+					if ($ii['location'] != '') {
+						$xml .= '<import location="' . $ii['location'] . '" namespace="' . $ns . '" />';
+					} else {
+						$xml .= '<import namespace="' . $ns . '" />';
+					}
+				}
+			} 
+		} 
+		// types
+		if (count($this->schemas)>=1) {
+			$xml .= "\n<types>\n";
+			foreach ($this->schemas as $ns => $list) {
+				foreach ($list as $xs) {
+					$xml .= $xs->serializeSchema();
+				}
+			}
+			$xml .= '</types>';
+		} 
+		// messages
+		if (count($this->messages) >= 1) {
+			foreach($this->messages as $msgName => $msgParts) {
+				$xml .= "\n<message name=\"" . $msgName . '">';
+				if(is_array($msgParts)){
+					foreach($msgParts as $partName => $partType) {
+						// print 'serializing '.$partType.', sv: '.$this->XMLSchemaVersion.'<br>';
+						if (strpos($partType, ':')) {
+						    $typePrefix = $this->getPrefixFromNamespace($this->getPrefix($partType));
+						} elseif (isset($this->typemap[$this->namespaces['xsd']][$partType])) {
+						    // print 'checking typemap: '.$this->XMLSchemaVersion.'<br>';
+						    $typePrefix = 'xsd';
+						} else {
+						    foreach($this->typemap as $ns => $types) {
+						        if (isset($types[$partType])) {
+						            $typePrefix = $this->getPrefixFromNamespace($ns);
+						        } 
+						    } 
+						    if (!isset($typePrefix)) {
+						        die("$partType has no namespace!");
+						    } 
+						}
+						$ns = $this->getNamespaceFromPrefix($typePrefix);
+						$localPart = $this->getLocalPart($partType);
+						$typeDef = $this->getTypeDef($localPart, $ns);
+						if ($typeDef['typeClass'] == 'element') {
+							$elementortype = 'element';
+							if (substr($localPart, -1) == '^') {
+								$localPart = substr($localPart, 0, -1);
+							}
+						} else {
+							$elementortype = 'type';
+						}
+						$xml .= "\n" . '  <part name="' . $partName . '" ' . $elementortype . '="' . $typePrefix . ':' . $localPart . '" />';
+					}
+				}
+				$xml .= '</message>';
+			} 
+		} 
+		// bindings & porttypes
+		if (count($this->bindings) >= 1) {
+			$binding_xml = '';
+			$portType_xml = '';
+			foreach($this->bindings as $bindingName => $attrs) {
+				$binding_xml .= "\n<binding name=\"" . $bindingName . '" type="tns:' . $attrs['portType'] . '">';
+				$binding_xml .= "\n" . '  <soap:binding style="' . $attrs['style'] . '" transport="' . $attrs['transport'] . '"/>';
+				$portType_xml .= "\n<portType name=\"" . $attrs['portType'] . '">';
+				foreach($attrs['operations'] as $opName => $opParts) {
+					$binding_xml .= "\n" . '  <operation name="' . $opName . '">';
+					$binding_xml .= "\n" . '    <soap:operation soapAction="' . $opParts['soapAction'] . '" style="'. $opParts['style'] . '"/>';
+					if (isset($opParts['input']['encodingStyle']) && $opParts['input']['encodingStyle'] != '') {
+						$enc_style = ' encodingStyle="' . $opParts['input']['encodingStyle'] . '"';
+					} else {
+						$enc_style = '';
+					}
+					$binding_xml .= "\n" . '    <input><soap:body use="' . $opParts['input']['use'] . '" namespace="' . $opParts['input']['namespace'] . '"' . $enc_style . '/></input>';
+					if (isset($opParts['output']['encodingStyle']) && $opParts['output']['encodingStyle'] != '') {
+						$enc_style = ' encodingStyle="' . $opParts['output']['encodingStyle'] . '"';
+					} else {
+						$enc_style = '';
+					}
+					$binding_xml .= "\n" . '    <output><soap:body use="' . $opParts['output']['use'] . '" namespace="' . $opParts['output']['namespace'] . '"' . $enc_style . '/></output>';
+					$binding_xml .= "\n" . '  </operation>';
+					$portType_xml .= "\n" . '  <operation name="' . $opParts['name'] . '"';
+					if (isset($opParts['parameterOrder'])) {
+					    $portType_xml .= ' parameterOrder="' . $opParts['parameterOrder'] . '"';
+					} 
+					$portType_xml .= '>';
+					if(isset($opParts['documentation']) && $opParts['documentation'] != '') {
+						$portType_xml .= "\n" . '    <documentation>' . htmlspecialchars($opParts['documentation']) . '</documentation>';
+					}
+					$portType_xml .= "\n" . '    <input message="tns:' . $opParts['input']['message'] . '"/>';
+					$portType_xml .= "\n" . '    <output message="tns:' . $opParts['output']['message'] . '"/>';
+					$portType_xml .= "\n" . '  </operation>';
+				} 
+				$portType_xml .= "\n" . '</portType>';
+				$binding_xml .= "\n" . '</binding>';
+			} 
+			$xml .= $portType_xml . $binding_xml;
+		} 
+		// services
+		$xml .= "\n<service name=\"" . $this->serviceName . '">';
+		if (count($this->ports) >= 1) {
+			foreach($this->ports as $pName => $attrs) {
+				$xml .= "\n" . '  <port name="' . $pName . '" binding="tns:' . $attrs['binding'] . '">';
+				$xml .= "\n" . '    <soap:address location="' . $attrs['location'] . ($debug ? '?debug=1' : '') . '"/>';
+				$xml .= "\n" . '  </port>';
+			} 
+		} 
+		$xml .= "\n" . '</service>';
+		return $xml . "\n</definitions>";
+	} 
+
+	/**
+	 * determine whether a set of parameters are unwrapped
+	 * when they are expect to be wrapped, Microsoft-style.
+	 *
+	 * @param string $type the type (element name) of the wrapper
+	 * @param array $parameters the parameter values for the SOAP call
+	 * @return boolean whether they parameters are unwrapped (and should be wrapped)
+	 * @access private
+	 */
+	function parametersMatchWrapped($type, &$parameters) {
+		$this->debug("in parametersMatchWrapped type=$type, parameters=");
+		$this->appendDebug($this->varDump($parameters));
+
+		// split type into namespace:unqualified-type
+		if (strpos($type, ':')) {
+			$uqType = substr($type, strrpos($type, ':') + 1);
+			$ns = substr($type, 0, strrpos($type, ':'));
+			$this->debug("in parametersMatchWrapped: got a prefixed type: $uqType, $ns");
+			if ($this->getNamespaceFromPrefix($ns)) {
+				$ns = $this->getNamespaceFromPrefix($ns);
+				$this->debug("in parametersMatchWrapped: expanded prefixed type: $uqType, $ns");
+			}
+		} else {
+			// TODO: should the type be compared to types in XSD, and the namespace
+			// set to XSD if the type matches?
+			$this->debug("in parametersMatchWrapped: No namespace for type $type");
+			$ns = '';
+			$uqType = $type;
+		}
+
+		// get the type information
+		if (!$typeDef = $this->getTypeDef($uqType, $ns)) {
+			$this->debug("in parametersMatchWrapped: $type ($uqType) is not a supported type.");
+			return false;
+		}
+		$this->debug("in parametersMatchWrapped: found typeDef=");
+		$this->appendDebug($this->varDump($typeDef));
+		if (substr($uqType, -1) == '^') {
+			$uqType = substr($uqType, 0, -1);
+		}
+		$phpType = $typeDef['phpType'];
+		$arrayType = (isset($typeDef['arrayType']) ? $typeDef['arrayType'] : '');
+		$this->debug("in parametersMatchWrapped: uqType: $uqType, ns: $ns, phptype: $phpType, arrayType: $arrayType");
+		
+		// we expect a complexType or element of complexType
+		if ($phpType != 'struct') {
+			$this->debug("in parametersMatchWrapped: not a struct");
+			return false;
+		}
+
+		// see whether the parameter names match the elements
+		if (isset($typeDef['elements']) && is_array($typeDef['elements'])) {
+			$elements = 0;
+			$matches = 0;
+			foreach ($typeDef['elements'] as $name => $attrs) {
+				if (isset($parameters[$name])) {
+					$this->debug("in parametersMatchWrapped: have parameter named $name");
+					$matches++;
+				} else {
+					$this->debug("in parametersMatchWrapped: do not have parameter named $name");
+				}
+				$elements++;
+			}
+
+			$this->debug("in parametersMatchWrapped: $matches parameter names match $elements wrapped parameter names");
+			if ($matches == 0) {
+				return false;
+			}
+			return true;
+		}
+
+		// since there are no elements for the type, if the user passed no
+		// parameters, the parameters match wrapped.
+		$this->debug("in parametersMatchWrapped: no elements type $ns:$uqType");
+		return count($parameters) == 0;
+	}
+
+	/**
+	 * serialize PHP values according to a WSDL message definition
+	 * contrary to the method name, this is not limited to RPC
+	 *
+	 * TODO
+	 * - multi-ref serialization
+	 * - validate PHP values against type definitions, return errors if invalid
+	 * 
+	 * @param string $operation operation name
+	 * @param string $direction (input|output)
+	 * @param mixed $parameters parameter value(s)
+	 * @param string $bindingType (soap|soap12)
+	 * @return mixed parameters serialized as XML or false on error (e.g. operation not found)
+	 * @access public
+	 */
+	function serializeRPCParameters($operation, $direction, $parameters, $bindingType = 'soap') {
+		$this->debug("in serializeRPCParameters: operation=$operation, direction=$direction, XMLSchemaVersion=$this->XMLSchemaVersion, bindingType=$bindingType");
+		$this->appendDebug('parameters=' . $this->varDump($parameters));
+		
+		if ($direction != 'input' && $direction != 'output') {
+			$this->debug('The value of the \$direction argument needs to be either "input" or "output"');
+			$this->setError('The value of the \$direction argument needs to be either "input" or "output"');
+			return false;
+		} 
+		if (!$opData = $this->getOperationData($operation, $bindingType)) {
+			$this->debug('Unable to retrieve WSDL data for operation: ' . $operation . ' bindingType: ' . $bindingType);
+			$this->setError('Unable to retrieve WSDL data for operation: ' . $operation . ' bindingType: ' . $bindingType);
+			return false;
+		}
+		$this->debug('in serializeRPCParameters: opData:');
+		$this->appendDebug($this->varDump($opData));
+
+		// Get encoding style for output and set to current
+		$encodingStyle = 'http://schemas.xmlsoap.org/soap/encoding/';
+		if(($direction == 'input') && isset($opData['output']['encodingStyle']) && ($opData['output']['encodingStyle'] != $encodingStyle)) {
+			$encodingStyle = $opData['output']['encodingStyle'];
+			$enc_style = $encodingStyle;
+		}
+
+		// set input params
+		$xml = '';
+		if (isset($opData[$direction]['parts']) && sizeof($opData[$direction]['parts']) > 0) {
+			$parts = &$opData[$direction]['parts'];
+			$part_count = sizeof($parts);
+			$style = $opData['style'];
+			$use = $opData[$direction]['use'];
+			$this->debug("have $part_count part(s) to serialize using $style/$use");
+			if (is_array($parameters)) {
+				$parametersArrayType = $this->isArraySimpleOrStruct($parameters);
+				$parameter_count = count($parameters);
+				$this->debug("have $parameter_count parameter(s) provided as $parametersArrayType to serialize");
+				// check for Microsoft-style wrapped parameters
+				if ($style == 'document' && $use == 'literal' && $part_count == 1 && isset($parts['parameters'])) {
+					$this->debug('check whether the caller has wrapped the parameters');
+					if ($direction == 'output' && $parametersArrayType == 'arraySimple' && $parameter_count == 1) {
+						// TODO: consider checking here for double-wrapping, when
+						// service function wraps, then NuSOAP wraps again
+						$this->debug("change simple array to associative with 'parameters' element");
+						$parameters['parameters'] = $parameters[0];
+						unset($parameters[0]);
+					}
+					if (($parametersArrayType == 'arrayStruct' || $parameter_count == 0) && !isset($parameters['parameters'])) {
+						$this->debug('check whether caller\'s parameters match the wrapped ones');
+						if ($this->parametersMatchWrapped($parts['parameters'], $parameters)) {
+							$this->debug('wrap the parameters for the caller');
+							$parameters = array('parameters' => $parameters);
+							$parameter_count = 1;
+						}
+					}
+				}
+				foreach ($parts as $name => $type) {
+					$this->debug("serializing part $name of type $type");
+					// Track encoding style
+					if (isset($opData[$direction]['encodingStyle']) && $encodingStyle != $opData[$direction]['encodingStyle']) {
+						$encodingStyle = $opData[$direction]['encodingStyle'];			
+						$enc_style = $encodingStyle;
+					} else {
+						$enc_style = false;
+					}
+					// NOTE: add error handling here
+					// if serializeType returns false, then catch global error and fault
+					if ($parametersArrayType == 'arraySimple') {
+						$p = array_shift($parameters);
+						$this->debug('calling serializeType w/indexed param');
+						$xml .= $this->serializeType($name, $type, $p, $use, $enc_style);
+					} elseif (isset($parameters[$name])) {
+						$this->debug('calling serializeType w/named param');
+						$xml .= $this->serializeType($name, $type, $parameters[$name], $use, $enc_style);
+					} else {
+						// TODO: only send nillable
+						$this->debug('calling serializeType w/null param');
+						$xml .= $this->serializeType($name, $type, null, $use, $enc_style);
+					}
+				}
+			} else {
+				$this->debug('no parameters passed.');
+			}
+		}
+		$this->debug("serializeRPCParameters returning: $xml");
+		return $xml;
+	} 
+	
+	/**
+	 * serialize a PHP value according to a WSDL message definition
+	 * 
+	 * TODO
+	 * - multi-ref serialization
+	 * - validate PHP values against type definitions, return errors if invalid
+	 * 
+	 * @param string $operation operation name
+	 * @param string $direction (input|output)
+	 * @param mixed $parameters parameter value(s)
+	 * @return mixed parameters serialized as XML or false on error (e.g. operation not found)
+	 * @access public
+	 * @deprecated
+	 */
+	function serializeParameters($operation, $direction, $parameters)
+	{
+		$this->debug("in serializeParameters: operation=$operation, direction=$direction, XMLSchemaVersion=$this->XMLSchemaVersion"); 
+		$this->appendDebug('parameters=' . $this->varDump($parameters));
+		
+		if ($direction != 'input' && $direction != 'output') {
+			$this->debug('The value of the \$direction argument needs to be either "input" or "output"');
+			$this->setError('The value of the \$direction argument needs to be either "input" or "output"');
+			return false;
+		} 
+		if (!$opData = $this->getOperationData($operation)) {
+			$this->debug('Unable to retrieve WSDL data for operation: ' . $operation);
+			$this->setError('Unable to retrieve WSDL data for operation: ' . $operation);
+			return false;
+		}
+		$this->debug('opData:');
+		$this->appendDebug($this->varDump($opData));
+		
+		// Get encoding style for output and set to current
+		$encodingStyle = 'http://schemas.xmlsoap.org/soap/encoding/';
+		if(($direction == 'input') && isset($opData['output']['encodingStyle']) && ($opData['output']['encodingStyle'] != $encodingStyle)) {
+			$encodingStyle = $opData['output']['encodingStyle'];
+			$enc_style = $encodingStyle;
+		}
+		
+		// set input params
+		$xml = '';
+		if (isset($opData[$direction]['parts']) && sizeof($opData[$direction]['parts']) > 0) {
+			
+			$use = $opData[$direction]['use'];
+			$this->debug("use=$use");
+			$this->debug('got ' . count($opData[$direction]['parts']) . ' part(s)');
+			if (is_array($parameters)) {
+				$parametersArrayType = $this->isArraySimpleOrStruct($parameters);
+				$this->debug('have ' . $parametersArrayType . ' parameters');
+				foreach($opData[$direction]['parts'] as $name => $type) {
+					$this->debug('serializing part "'.$name.'" of type "'.$type.'"');
+					// Track encoding style
+					if(isset($opData[$direction]['encodingStyle']) && $encodingStyle != $opData[$direction]['encodingStyle']) {
+						$encodingStyle = $opData[$direction]['encodingStyle'];			
+						$enc_style = $encodingStyle;
+					} else {
+						$enc_style = false;
+					}
+					// NOTE: add error handling here
+					// if serializeType returns false, then catch global error and fault
+					if ($parametersArrayType == 'arraySimple') {
+						$p = array_shift($parameters);
+						$this->debug('calling serializeType w/indexed param');
+						$xml .= $this->serializeType($name, $type, $p, $use, $enc_style);
+					} elseif (isset($parameters[$name])) {
+						$this->debug('calling serializeType w/named param');
+						$xml .= $this->serializeType($name, $type, $parameters[$name], $use, $enc_style);
+					} else {
+						// TODO: only send nillable
+						$this->debug('calling serializeType w/null param');
+						$xml .= $this->serializeType($name, $type, null, $use, $enc_style);
+					}
+				}
+			} else {
+				$this->debug('no parameters passed.');
+			}
+		}
+		$this->debug("serializeParameters returning: $xml");
+		return $xml;
+	} 
+	
+	/**
+	 * serializes a PHP value according a given type definition
+	 * 
+	 * @param string $name name of value (part or element)
+	 * @param string $type XML schema type of value (type or element)
+	 * @param mixed $value a native PHP value (parameter value)
+	 * @param string $use use for part (encoded|literal)
+	 * @param string $encodingStyle SOAP encoding style for the value (if different than the enclosing style)
+	 * @param boolean $unqualified a kludge for what should be XML namespace form handling
+	 * @return string value serialized as an XML string
+	 * @access private
+	 */
+	function serializeType($name, $type, $value, $use='encoded', $encodingStyle=false, $unqualified=false)
+	{
+		$this->debug("in serializeType: name=$name, type=$type, use=$use, encodingStyle=$encodingStyle, unqualified=" . ($unqualified ? "unqualified" : "qualified"));
+		$this->appendDebug("value=" . $this->varDump($value));
+		if($use == 'encoded' && $encodingStyle) {
+			$encodingStyle = ' SOAP-ENV:encodingStyle="' . $encodingStyle . '"';
+		}
+
+		// if a soapval has been supplied, let its type override the WSDL
+    	if (is_object($value) && get_class($value) == 'soapval') {
+    		if ($value->type_ns) {
+    			$type = $value->type_ns . ':' . $value->type;
+		    	$forceType = true;
+		    	$this->debug("in serializeType: soapval overrides type to $type");
+    		} elseif ($value->type) {
+	    		$type = $value->type;
+		    	$forceType = true;
+		    	$this->debug("in serializeType: soapval overrides type to $type");
+	    	} else {
+	    		$forceType = false;
+		    	$this->debug("in serializeType: soapval does not override type");
+	    	}
+	    	$attrs = $value->attributes;
+	    	$value = $value->value;
+	    	$this->debug("in serializeType: soapval overrides value to $value");
+	    	if ($attrs) {
+	    		if (!is_array($value)) {
+	    			$value['!'] = $value;
+	    		}
+	    		foreach ($attrs as $n => $v) {
+	    			$value['!' . $n] = $v;
+	    		}
+		    	$this->debug("in serializeType: soapval provides attributes");
+		    }
+        } else {
+        	$forceType = false;
+        }
+
+		$xml = '';
+		if (strpos($type, ':')) {
+			$uqType = substr($type, strrpos($type, ':') + 1);
+			$ns = substr($type, 0, strrpos($type, ':'));
+			$this->debug("in serializeType: got a prefixed type: $uqType, $ns");
+			if ($this->getNamespaceFromPrefix($ns)) {
+				$ns = $this->getNamespaceFromPrefix($ns);
+				$this->debug("in serializeType: expanded prefixed type: $uqType, $ns");
+			}
+
+			if($ns == $this->XMLSchemaVersion || $ns == 'http://schemas.xmlsoap.org/soap/encoding/'){
+				$this->debug('in serializeType: type namespace indicates XML Schema or SOAP Encoding type');
+				if ($unqualified && $use == 'literal') {
+					$elementNS = " xmlns=\"\"";
+				} else {
+					$elementNS = '';
+				}
+				if (is_null($value)) {
+					if ($use == 'literal') {
+						// TODO: depends on minOccurs
+						$xml = "<$name$elementNS/>";
+					} else {
+						// TODO: depends on nillable, which should be checked before calling this method
+						$xml = "<$name$elementNS xsi:nil=\"true\" xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\"/>";
+					}
+					$this->debug("in serializeType: returning: $xml");
+					return $xml;
+				}
+				if ($uqType == 'Array') {
+					// JBoss/Axis does this sometimes
+					return $this->serialize_val($value, $name, false, false, false, false, $use);
+				}
+		    	if ($uqType == 'boolean') {
+		    		if ((is_string($value) && $value == 'false') || (! $value)) {
+						$value = 'false';
+					} else {
+						$value = 'true';
+					}
+				} 
+				if ($uqType == 'string' && gettype($value) == 'string') {
+					$value = $this->expandEntities($value);
+				}
+				if (($uqType == 'long' || $uqType == 'unsignedLong') && gettype($value) == 'double') {
+					$value = sprintf("%.0lf", $value);
+				}
+				// it's a scalar
+				// TODO: what about null/nil values?
+				// check type isn't a custom type extending xmlschema namespace
+				if (!$this->getTypeDef($uqType, $ns)) {
+					if ($use == 'literal') {
+						if ($forceType) {
+							$xml = "<$name$elementNS xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\">$value</$name>";
+						} else {
+							$xml = "<$name$elementNS>$value</$name>";
+						}
+					} else {
+						$xml = "<$name$elementNS xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\"$encodingStyle>$value</$name>";
+					}
+					$this->debug("in serializeType: returning: $xml");
+					return $xml;
+				}
+				$this->debug('custom type extends XML Schema or SOAP Encoding namespace (yuck)');
+			} else if ($ns == 'http://xml.apache.org/xml-soap') {
+				$this->debug('in serializeType: appears to be Apache SOAP type');
+				if ($uqType == 'Map') {
+					$tt_prefix = $this->getPrefixFromNamespace('http://xml.apache.org/xml-soap');
+					if (! $tt_prefix) {
+						$this->debug('in serializeType: Add namespace for Apache SOAP type');
+						$tt_prefix = 'ns' . rand(1000, 9999);
+						$this->namespaces[$tt_prefix] = 'http://xml.apache.org/xml-soap';
+						// force this to be added to usedNamespaces
+						$tt_prefix = $this->getPrefixFromNamespace('http://xml.apache.org/xml-soap');
+					}
+					$contents = '';
+					foreach($value as $k => $v) {
+						$this->debug("serializing map element: key $k, value $v");
+						$contents .= '<item>';
+						$contents .= $this->serialize_val($k,'key',false,false,false,false,$use);
+						$contents .= $this->serialize_val($v,'value',false,false,false,false,$use);
+						$contents .= '</item>';
+					}
+					if ($use == 'literal') {
+						if ($forceType) {
+							$xml = "<$name xsi:type=\"" . $tt_prefix . ":$uqType\">$contents</$name>";
+						} else {
+							$xml = "<$name>$contents</$name>";
+						}
+					} else {
+						$xml = "<$name xsi:type=\"" . $tt_prefix . ":$uqType\"$encodingStyle>$contents</$name>";
+					}
+					$this->debug("in serializeType: returning: $xml");
+					return $xml;
+				}
+				$this->debug('in serializeType: Apache SOAP type, but only support Map');
+			}
+		} else {
+			// TODO: should the type be compared to types in XSD, and the namespace
+			// set to XSD if the type matches?
+			$this->debug("in serializeType: No namespace for type $type");
+			$ns = '';
+			$uqType = $type;
+		}
+		if(!$typeDef = $this->getTypeDef($uqType, $ns)){
+			$this->setError("$type ($uqType) is not a supported type.");
+			$this->debug("in serializeType: $type ($uqType) is not a supported type.");
+			return false;
+		} else {
+			$this->debug("in serializeType: found typeDef");
+			$this->appendDebug('typeDef=' . $this->varDump($typeDef));
+			if (substr($uqType, -1) == '^') {
+				$uqType = substr($uqType, 0, -1);
+			}
+		}
+		if (!isset($typeDef['phpType'])) {
+			$this->setError("$type ($uqType) has no phpType.");
+			$this->debug("in serializeType: $type ($uqType) has no phpType.");
+			return false;
+		}
+		$phpType = $typeDef['phpType'];
+		$this->debug("in serializeType: uqType: $uqType, ns: $ns, phptype: $phpType, arrayType: " . (isset($typeDef['arrayType']) ? $typeDef['arrayType'] : '') ); 
+		// if php type == struct, map value to the <all> element names
+		if ($phpType == 'struct') {
+			if (isset($typeDef['typeClass']) && $typeDef['typeClass'] == 'element') {
+				$elementName = $uqType;
+				if (isset($typeDef['form']) && ($typeDef['form'] == 'qualified')) {
+					$elementNS = " xmlns=\"$ns\"";
+				} else {
+					$elementNS = " xmlns=\"\"";
+				}
+			} else {
+				$elementName = $name;
+				if ($unqualified) {
+					$elementNS = " xmlns=\"\"";
+				} else {
+					$elementNS = '';
+				}
+			}
+			if (is_null($value)) {
+				if ($use == 'literal') {
+					// TODO: depends on minOccurs and nillable
+					$xml = "<$elementName$elementNS/>";
+				} else {
+					$xml = "<$elementName$elementNS xsi:nil=\"true\" xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\"/>";
+				}
+				$this->debug("in serializeType: returning: $xml");
+				return $xml;
+			}
+			if (is_object($value)) {
+				$value = get_object_vars($value);
+			}
+			if (is_array($value)) {
+				$elementAttrs = $this->serializeComplexTypeAttributes($typeDef, $value, $ns, $uqType);
+				if ($use == 'literal') {
+					if ($forceType) {
+						$xml = "<$elementName$elementNS$elementAttrs xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\">";
+					} else {
+						$xml = "<$elementName$elementNS$elementAttrs>";
+					}
+				} else {
+					$xml = "<$elementName$elementNS$elementAttrs xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\"$encodingStyle>";
+				}
+
+				if (isset($typeDef['simpleContent']) && $typeDef['simpleContent'] == 'true') {
+					if (isset($value['!'])) {
+						$xml .= $value['!'];
+						$this->debug("in serializeType: serialized simpleContent for type $type");
+					} else {
+						$this->debug("in serializeType: no simpleContent to serialize for type $type");
+					}
+				} else {
+					// complexContent
+					$xml .= $this->serializeComplexTypeElements($typeDef, $value, $ns, $uqType, $use, $encodingStyle);
+				}
+				$xml .= "</$elementName>";
+			} else {
+				$this->debug("in serializeType: phpType is struct, but value is not an array");
+				$this->setError("phpType is struct, but value is not an array: see debug output for details");
+				$xml = '';
+			}
+		} elseif ($phpType == 'array') {
+			if (isset($typeDef['form']) && ($typeDef['form'] == 'qualified')) {
+				$elementNS = " xmlns=\"$ns\"";
+			} else {
+				if ($unqualified) {
+					$elementNS = " xmlns=\"\"";
+				} else {
+					$elementNS = '';
+				}
+			}
+			if (is_null($value)) {
+				if ($use == 'literal') {
+					// TODO: depends on minOccurs
+					$xml = "<$name$elementNS/>";
+				} else {
+					$xml = "<$name$elementNS xsi:nil=\"true\" xsi:type=\"" .
+						$this->getPrefixFromNamespace('http://schemas.xmlsoap.org/soap/encoding/') .
+						":Array\" " .
+						$this->getPrefixFromNamespace('http://schemas.xmlsoap.org/soap/encoding/') .
+						':arrayType="' .
+						$this->getPrefixFromNamespace($this->getPrefix($typeDef['arrayType'])) .
+						':' .
+						$this->getLocalPart($typeDef['arrayType'])."[0]\"/>";
+				}
+				$this->debug("in serializeType: returning: $xml");
+				return $xml;
+			}
+			if (isset($typeDef['multidimensional'])) {
+				$nv = array();
+				foreach($value as $v) {
+					$cols = ',' . sizeof($v);
+					$nv = array_merge($nv, $v);
+				} 
+				$value = $nv;
+			} else {
+				$cols = '';
+			} 
+			if (is_array($value) && sizeof($value) >= 1) {
+				$rows = sizeof($value);
+				$contents = '';
+				foreach($value as $k => $v) {
+					$this->debug("serializing array element: $k, $v of type: $typeDef[arrayType]");
+					//if (strpos($typeDef['arrayType'], ':') ) {
+					if (!in_array($typeDef['arrayType'],$this->typemap['http://www.w3.org/2001/XMLSchema'])) {
+					    $contents .= $this->serializeType('item', $typeDef['arrayType'], $v, $use);
+					} else {
+					    $contents .= $this->serialize_val($v, 'item', $typeDef['arrayType'], null, $this->XMLSchemaVersion, false, $use);
+					} 
+				}
+			} else {
+				$rows = 0;
+				$contents = null;
+			}
+			// TODO: for now, an empty value will be serialized as a zero element
+			// array.  Revisit this when coding the handling of null/nil values.
+			if ($use == 'literal') {
+				$xml = "<$name$elementNS>"
+					.$contents
+					."</$name>";
+			} else {
+				$xml = "<$name$elementNS xsi:type=\"".$this->getPrefixFromNamespace('http://schemas.xmlsoap.org/soap/encoding/').':Array" '.
+					$this->getPrefixFromNamespace('http://schemas.xmlsoap.org/soap/encoding/')
+					.':arrayType="'
+					.$this->getPrefixFromNamespace($this->getPrefix($typeDef['arrayType']))
+					.":".$this->getLocalPart($typeDef['arrayType'])."[$rows$cols]\">"
+					.$contents
+					."</$name>";
+			}
+		} elseif ($phpType == 'scalar') {
+			if (isset($typeDef['form']) && ($typeDef['form'] == 'qualified')) {
+				$elementNS = " xmlns=\"$ns\"";
+			} else {
+				if ($unqualified) {
+					$elementNS = " xmlns=\"\"";
+				} else {
+					$elementNS = '';
+				}
+			}
+			if ($use == 'literal') {
+				if ($forceType) {
+					$xml = "<$name$elementNS xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\">$value</$name>";
+				} else {
+					$xml = "<$name$elementNS>$value</$name>";
+				}
+			} else {
+				$xml = "<$name$elementNS xsi:type=\"" . $this->getPrefixFromNamespace($ns) . ":$uqType\"$encodingStyle>$value</$name>";
+			}
+		}
+		$this->debug("in serializeType: returning: $xml");
+		return $xml;
+	}
+	
+	/**
+	 * serializes the attributes for a complexType
+	 *
+	 * @param array $typeDef our internal representation of an XML schema type (or element)
+	 * @param mixed $value a native PHP value (parameter value)
+	 * @param string $ns the namespace of the type
+	 * @param string $uqType the local part of the type
+	 * @return string value serialized as an XML string
+	 * @access private
+	 */
+	function serializeComplexTypeAttributes($typeDef, $value, $ns, $uqType) {
+		$this->debug("serializeComplexTypeAttributes for XML Schema type $ns:$uqType");
+		$xml = '';
+		if (isset($typeDef['extensionBase'])) {
+			$nsx = $this->getPrefix($typeDef['extensionBase']);
+			$uqTypex = $this->getLocalPart($typeDef['extensionBase']);
+			if ($this->getNamespaceFromPrefix($nsx)) {
+				$nsx = $this->getNamespaceFromPrefix($nsx);
+			}
+			if ($typeDefx = $this->getTypeDef($uqTypex, $nsx)) {
+				$this->debug("serialize attributes for extension base $nsx:$uqTypex");
+				$xml .= $this->serializeComplexTypeAttributes($typeDefx, $value, $nsx, $uqTypex);
+			} else {
+				$this->debug("extension base $nsx:$uqTypex is not a supported type");
+			}
+		}
+		if (isset($typeDef['attrs']) && is_array($typeDef['attrs'])) {
+			$this->debug("serialize attributes for XML Schema type $ns:$uqType");
+			if (is_array($value)) {
+				$xvalue = $value;
+			} elseif (is_object($value)) {
+				$xvalue = get_object_vars($value);
+			} else {
+				$this->debug("value is neither an array nor an object for XML Schema type $ns:$uqType");
+				$xvalue = array();
+			}
+			foreach ($typeDef['attrs'] as $aName => $attrs) {
+				if (isset($xvalue['!' . $aName])) {
+					$xname = '!' . $aName;
+					$this->debug("value provided for attribute $aName with key $xname");
+				} elseif (isset($xvalue[$aName])) {
+					$xname = $aName;
+					$this->debug("value provided for attribute $aName with key $xname");
+				} elseif (isset($attrs['default'])) {
+					$xname = '!' . $aName;
+					$xvalue[$xname] = $attrs['default'];
+					$this->debug('use default value of ' . $xvalue[$aName] . ' for attribute ' . $aName);
+				} else {
+					$xname = '';
+					$this->debug("no value provided for attribute $aName");
+				}
+				if ($xname) {
+					$xml .=  " $aName=\"" . $this->expandEntities($xvalue[$xname]) . "\"";
+				}
+			} 
+		} else {
+			$this->debug("no attributes to serialize for XML Schema type $ns:$uqType");
+		}
+		return $xml;
+	}
+
+	/**
+	 * serializes the elements for a complexType
+	 *
+	 * @param array $typeDef our internal representation of an XML schema type (or element)
+	 * @param mixed $value a native PHP value (parameter value)
+	 * @param string $ns the namespace of the type
+	 * @param string $uqType the local part of the type
+	 * @param string $use use for part (encoded|literal)
+	 * @param string $encodingStyle SOAP encoding style for the value (if different than the enclosing style)
+	 * @return string value serialized as an XML string
+	 * @access private
+	 */
+	function serializeComplexTypeElements($typeDef, $value, $ns, $uqType, $use='encoded', $encodingStyle=false) {
+		$this->debug("in serializeComplexTypeElements for XML Schema type $ns:$uqType");
+		$xml = '';
+		if (isset($typeDef['extensionBase'])) {
+			$nsx = $this->getPrefix($typeDef['extensionBase']);
+			$uqTypex = $this->getLocalPart($typeDef['extensionBase']);
+			if ($this->getNamespaceFromPrefix($nsx)) {
+				$nsx = $this->getNamespaceFromPrefix($nsx);
+			}
+			if ($typeDefx = $this->getTypeDef($uqTypex, $nsx)) {
+				$this->debug("serialize elements for extension base $nsx:$uqTypex");
+				$xml .= $this->serializeComplexTypeElements($typeDefx, $value, $nsx, $uqTypex, $use, $encodingStyle);
+			} else {
+				$this->debug("extension base $nsx:$uqTypex is not a supported type");
+			}
+		}
+		if (isset($typeDef['elements']) && is_array($typeDef['elements'])) {
+			$this->debug("in serializeComplexTypeElements, serialize elements for XML Schema type $ns:$uqType");
+			if (is_array($value)) {
+				$xvalue = $value;
+			} elseif (is_object($value)) {
+				$xvalue = get_object_vars($value);
+			} else {
+				$this->debug("value is neither an array nor an object for XML Schema type $ns:$uqType");
+				$xvalue = array();
+			}
+			// toggle whether all elements are present - ideally should validate against schema
+			if (count($typeDef['elements']) != count($xvalue)){
+				$optionals = true;
+			}
+			foreach ($typeDef['elements'] as $eName => $attrs) {
+				if (!isset($xvalue[$eName])) {
+					if (isset($attrs['default'])) {
+						$xvalue[$eName] = $attrs['default'];
+						$this->debug('use default value of ' . $xvalue[$eName] . ' for element ' . $eName);
+					}
+				}
+				// if user took advantage of a minOccurs=0, then only serialize named parameters
+				if (isset($optionals)
+				    && (!isset($xvalue[$eName])) 
+					&& ( (!isset($attrs['nillable'])) || $attrs['nillable'] != 'true')
+					){
+					if (isset($attrs['minOccurs']) && $attrs['minOccurs'] <> '0') {
+						$this->debug("apparent error: no value provided for element $eName with minOccurs=" . $attrs['minOccurs']);
+					}
+					// do nothing
+					$this->debug("no value provided for complexType element $eName and element is not nillable, so serialize nothing");
+				} else {
+					// get value
+					if (isset($xvalue[$eName])) {
+					    $v = $xvalue[$eName];
+					} else {
+					    $v = null;
+					}
+					if (isset($attrs['form'])) {
+						$unqualified = ($attrs['form'] == 'unqualified');
+					} else {
+						$unqualified = false;
+					}
+					if (isset($attrs['maxOccurs']) && ($attrs['maxOccurs'] == 'unbounded' || $attrs['maxOccurs'] > 1) && isset($v) && is_array($v) && $this->isArraySimpleOrStruct($v) == 'arraySimple') {
+						$vv = $v;
+						foreach ($vv as $k => $v) {
+							if (isset($attrs['type']) || isset($attrs['ref'])) {
+								// serialize schema-defined type
+							    $xml .= $this->serializeType($eName, isset($attrs['type']) ? $attrs['type'] : $attrs['ref'], $v, $use, $encodingStyle, $unqualified);
+							} else {
+								// serialize generic type (can this ever really happen?)
+							    $this->debug("calling serialize_val() for $v, $eName, false, false, false, false, $use");
+							    $xml .= $this->serialize_val($v, $eName, false, false, false, false, $use);
+							}
+						}
+					} else {
+						if (is_null($v) && isset($attrs['minOccurs']) && $attrs['minOccurs'] == '0') {
+							// do nothing
+						} elseif (is_null($v) && isset($attrs['nillable']) && $attrs['nillable'] == 'true') {
+							// TODO: serialize a nil correctly, but for now serialize schema-defined type
+						    $xml .= $this->serializeType($eName, isset($attrs['type']) ? $attrs['type'] : $attrs['ref'], $v, $use, $encodingStyle, $unqualified);
+						} elseif (isset($attrs['type']) || isset($attrs['ref'])) {
+							// serialize schema-defined type
+						    $xml .= $this->serializeType($eName, isset($attrs['type']) ? $attrs['type'] : $attrs['ref'], $v, $use, $encodingStyle, $unqualified);
+						} else {
+							// serialize generic type (can this ever really happen?)
+						    $this->debug("calling serialize_val() for $v, $eName, false, false, false, false, $use");
+						    $xml .= $this->serialize_val($v, $eName, false, false, false, false, $use);
+						}
+					}
+				}
+			} 
+		} else {
+			$this->debug("no elements to serialize for XML Schema type $ns:$uqType");
+		}
+		return $xml;
+	}
+
+	/**
+	* adds an XML Schema complex type to the WSDL types
+	*
+	* @param string	$name
+	* @param string $typeClass (complexType|simpleType|attribute)
+	* @param string $phpType currently supported are array and struct (php assoc array)
+	* @param string $compositor (all|sequence|choice)
+	* @param string $restrictionBase namespace:name (http://schemas.xmlsoap.org/soap/encoding/:Array)
+	* @param array $elements e.g. array ( name => array(name=>'',type=>'') )
+	* @param array $attrs e.g. array(array('ref'=>'SOAP-ENC:arrayType','wsdl:arrayType'=>'xsd:string[]'))
+	* @param string $arrayType as namespace:name (xsd:string)
+	* @see nusoap_xmlschema
+	* @access public
+	*/
+	function addComplexType($name,$typeClass='complexType',$phpType='array',$compositor='',$restrictionBase='',$elements=array(),$attrs=array(),$arrayType='') {
+		if (count($elements) > 0) {
+			$eElements = array();
+	    	foreach($elements as $n => $e){
+	            // expand each element
+	            $ee = array();
+	            foreach ($e as $k => $v) {
+		            $k = strpos($k,':') ? $this->expandQname($k) : $k;
+		            $v = strpos($v,':') ? $this->expandQname($v) : $v;
+		            $ee[$k] = $v;
+		    	}
+	    		$eElements[$n] = $ee;
+	    	}
+	    	$elements = $eElements;
+		}
+		
+		if (count($attrs) > 0) {
+	    	foreach($attrs as $n => $a){
+	            // expand each attribute
+	            foreach ($a as $k => $v) {
+		            $k = strpos($k,':') ? $this->expandQname($k) : $k;
+		            $v = strpos($v,':') ? $this->expandQname($v) : $v;
+		            $aa[$k] = $v;
+		    	}
+	    		$eAttrs[$n] = $aa;
+	    	}
+	    	$attrs = $eAttrs;
+		}
+
+		$restrictionBase = strpos($restrictionBase,':') ? $this->expandQname($restrictionBase) : $restrictionBase;
+		$arrayType = strpos($arrayType,':') ? $this->expandQname($arrayType) : $arrayType;
+
+		$typens = isset($this->namespaces['types']) ? $this->namespaces['types'] : $this->namespaces['tns'];
+		$this->schemas[$typens][0]->addComplexType($name,$typeClass,$phpType,$compositor,$restrictionBase,$elements,$attrs,$arrayType);
+	}
+
+	/**
+	* adds an XML Schema simple type to the WSDL types
+	*
+	* @param string $name
+	* @param string $restrictionBase namespace:name (http://schemas.xmlsoap.org/soap/encoding/:Array)
+	* @param string $typeClass (should always be simpleType)
+	* @param string $phpType (should always be scalar)
+	* @param array $enumeration array of values
+	* @see nusoap_xmlschema
+	* @access public
+	*/
+	function addSimpleType($name, $restrictionBase='', $typeClass='simpleType', $phpType='scalar', $enumeration=array()) {
+		$restrictionBase = strpos($restrictionBase,':') ? $this->expandQname($restrictionBase) : $restrictionBase;
+
+		$typens = isset($this->namespaces['types']) ? $this->namespaces['types'] : $this->namespaces['tns'];
+		$this->schemas[$typens][0]->addSimpleType($name, $restrictionBase, $typeClass, $phpType, $enumeration);
+	}
+
+	/**
+	* adds an element to the WSDL types
+	*
+	* @param array $attrs attributes that must include name and type
+	* @see nusoap_xmlschema
+	* @access public
+	*/
+	function addElement($attrs) {
+		$typens = isset($this->namespaces['types']) ? $this->namespaces['types'] : $this->namespaces['tns'];
+		$this->schemas[$typens][0]->addElement($attrs);
+	}
+
+	/**
+	* register an operation with the server
+	* 
+	* @param string $name operation (method) name
+	* @param array $in assoc array of input values: key = param name, value = param type
+	* @param array $out assoc array of output values: key = param name, value = param type
+	* @param string $namespace optional The namespace for the operation
+	* @param string $soapaction optional The soapaction for the operation
+	* @param string $style (rpc|document) optional The style for the operation Note: when 'document' is specified, parameter and return wrappers are created for you automatically
+	* @param string $use (encoded|literal) optional The use for the parameters (cannot mix right now)
+	* @param string $documentation optional The description to include in the WSDL
+	* @param string $encodingStyle optional (usually 'http://schemas.xmlsoap.org/soap/encoding/' for encoded)
+	* @access public 
+	*/
+	function addOperation($name, $in = false, $out = false, $namespace = false, $soapaction = false, $style = 'rpc', $use = 'encoded', $documentation = '', $encodingStyle = ''){
+		if ($use == 'encoded' && $encodingStyle == '') {
+			$encodingStyle = 'http://schemas.xmlsoap.org/soap/encoding/';
+		}
+
+		if ($style == 'document') {
+			$elements = array();
+			foreach ($in as $n => $t) {
+				$elements[$n] = array('name' => $n, 'type' => $t, 'form' => 'unqualified');
+			}
+			$this->addComplexType($name . 'RequestType', 'complexType', 'struct', 'all', '', $elements);
+			$this->addElement(array('name' => $name, 'type' => $name . 'RequestType'));
+			$in = array('parameters' => 'tns:' . $name . '^');
+
+			$elements = array();
+			foreach ($out as $n => $t) {
+				$elements[$n] = array('name' => $n, 'type' => $t, 'form' => 'unqualified');
+			}
+			$this->addComplexType($name . 'ResponseType', 'complexType', 'struct', 'all', '', $elements);
+			$this->addElement(array('name' => $name . 'Response', 'type' => $name . 'ResponseType', 'form' => 'qualified'));
+			$out = array('parameters' => 'tns:' . $name . 'Response' . '^');
+		}
+
+		// get binding
+		$this->bindings[ $this->serviceName . 'Binding' ]['operations'][$name] =
+		array(
+		'name' => $name,
+		'binding' => $this->serviceName . 'Binding',
+		'endpoint' => $this->endpoint,
+		'soapAction' => $soapaction,
+		'style' => $style,
+		'input' => array(
+			'use' => $use,
+			'namespace' => $namespace,
+			'encodingStyle' => $encodingStyle,
+			'message' => $name . 'Request',
+			'parts' => $in),
+		'output' => array(
+			'use' => $use,
+			'namespace' => $namespace,
+			'encodingStyle' => $encodingStyle,
+			'message' => $name . 'Response',
+			'parts' => $out),
+		'namespace' => $namespace,
+		'transport' => 'http://schemas.xmlsoap.org/soap/http',
+		'documentation' => $documentation); 
+		// add portTypes
+		// add messages
+		if($in)
+		{
+			foreach($in as $pName => $pType)
+			{
+				if(strpos($pType,':')) {
+					$pType = $this->getNamespaceFromPrefix($this->getPrefix($pType)).":".$this->getLocalPart($pType);
+				}
+				$this->messages[$name.'Request'][$pName] = $pType;
+			}
+		} else {
+            $this->messages[$name.'Request']= '0';
+        }
+		if($out)
+		{
+			foreach($out as $pName => $pType)
+			{
+				if(strpos($pType,':')) {
+					$pType = $this->getNamespaceFromPrefix($this->getPrefix($pType)).":".$this->getLocalPart($pType);
+				}
+				$this->messages[$name.'Response'][$pName] = $pType;
+			}
+		} else {
+            $this->messages[$name.'Response']= '0';
+        }
+		return true;
+	} 
+}
+?><?php
+
+
+
+/**
+*
+* nusoap_parser class parses SOAP XML messages into native PHP values
+*
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @version  $Id: nusoap.php,v 1.123 2010/04/26 20:15:08 snichol Exp $
+* @access   public
+*/
+class nusoap_parser extends nusoap_base {
+
+	var $xml = '';
+	var $xml_encoding = '';
+	var $method = '';
+	var $root_struct = '';
+	var $root_struct_name = '';
+	var $root_struct_namespace = '';
+	var $root_header = '';
+    var $document = '';			// incoming SOAP body (text)
+	// determines where in the message we are (envelope,header,body,method)
+	var $status = '';
+	var $position = 0;
+	var $depth = 0;
+	var $default_namespace = '';
+	var $namespaces = array();
+	var $message = array();
+    var $parent = '';
+	var $fault = false;
+	var $fault_code = '';
+	var $fault_str = '';
+	var $fault_detail = '';
+	var $depth_array = array();
+	var $debug_flag = true;
+	var $soapresponse = NULL;	// parsed SOAP Body
+	var $soapheader = NULL;		// parsed SOAP Header
+	var $responseHeaders = '';	// incoming SOAP headers (text)
+	var $body_position = 0;
+	// for multiref parsing:
+	// array of id => pos
+	var $ids = array();
+	// array of id => hrefs => pos
+	var $multirefs = array();
+	// toggle for auto-decoding element content
+	var $decode_utf8 = true;
+
+	/**
+	* constructor that actually does the parsing
+	*
+	* @param    string $xml SOAP message
+	* @param    string $encoding character encoding scheme of message
+	* @param    string $method method for which XML is parsed (unused?)
+	* @param    string $decode_utf8 whether to decode UTF-8 to ISO-8859-1
+	* @access   public
+	*/
+	function nusoap_parser($xml,$encoding='UTF-8',$method='',$decode_utf8=true){
+		parent::nusoap_base();
+		$this->xml = $xml;
+		$this->xml_encoding = $encoding;
+		$this->method = $method;
+		$this->decode_utf8 = $decode_utf8;
+
+		// Check whether content has been read.
+		if(!empty($xml)){
+			// Check XML encoding
+			$pos_xml = strpos($xml, '<?xml');
+			if ($pos_xml !== FALSE) {
+				$xml_decl = substr($xml, $pos_xml, strpos($xml, '?>', $pos_xml + 2) - $pos_xml + 1);
+				if (preg_match("/encoding=[\"']([^\"']*)[\"']/", $xml_decl, $res)) {
+					$xml_encoding = $res[1];
+					if (strtoupper($xml_encoding) != $encoding) {
+						$err = "Charset from HTTP Content-Type '" . $encoding . "' does not match encoding from XML declaration '" . $xml_encoding . "'";
+						$this->debug($err);
+						if ($encoding != 'ISO-8859-1' || strtoupper($xml_encoding) != 'UTF-8') {
+							$this->setError($err);
+							return;
+						}
+						// when HTTP says ISO-8859-1 (the default) and XML says UTF-8 (the typical), assume the other endpoint is just sloppy and proceed
+					} else {
+						$this->debug('Charset from HTTP Content-Type matches encoding from XML declaration');
+					}
+				} else {
+					$this->debug('No encoding specified in XML declaration');
+				}
+			} else {
+				$this->debug('No XML declaration');
+			}
+			$this->debug('Entering nusoap_parser(), length='.strlen($xml).', encoding='.$encoding);
+			// Create an XML parser - why not xml_parser_create_ns?
+			$this->parser = xml_parser_create($this->xml_encoding);
+			// Set the options for parsing the XML data.
+			//xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);
+			xml_parser_set_option($this->parser, XML_OPTION_CASE_FOLDING, 0);
+			xml_parser_set_option($this->parser, XML_OPTION_TARGET_ENCODING, $this->xml_encoding);
+			// Set the object for the parser.
+			xml_set_object($this->parser, $this);
+			// Set the element handlers for the parser.
+			xml_set_element_handler($this->parser, 'start_element','end_element');
+			xml_set_character_data_handler($this->parser,'character_data');
+
+			// Parse the XML file.
+			if(!xml_parse($this->parser,$xml,true)){
+			    // Display an error message.
+			    $err = sprintf('XML error parsing SOAP payload on line %d: %s',
+			    xml_get_current_line_number($this->parser),
+			    xml_error_string(xml_get_error_code($this->parser)));
+				$this->debug($err);
+				$this->debug("XML payload:\n" . $xml);
+				$this->setError($err);
+			} else {
+				$this->debug('in nusoap_parser ctor, message:');
+				$this->appendDebug($this->varDump($this->message));
+				$this->debug('parsed successfully, found root struct: '.$this->root_struct.' of name '.$this->root_struct_name);
+				// get final value
+				$this->soapresponse = $this->message[$this->root_struct]['result'];
+				// get header value
+				if($this->root_header != '' && isset($this->message[$this->root_header]['result'])){
+					$this->soapheader = $this->message[$this->root_header]['result'];
+				}
+				// resolve hrefs/ids
+				if(sizeof($this->multirefs) > 0){
+					foreach($this->multirefs as $id => $hrefs){
+						$this->debug('resolving multirefs for id: '.$id);
+						$idVal = $this->buildVal($this->ids[$id]);
+						if (is_array($idVal) && isset($idVal['!id'])) {
+							unset($idVal['!id']);
+						}
+						foreach($hrefs as $refPos => $ref){
+							$this->debug('resolving href at pos '.$refPos);
+							$this->multirefs[$id][$refPos] = $idVal;
+						}
+					}
+				}
+			}
+			xml_parser_free($this->parser);
+		} else {
+			$this->debug('xml was empty, didn\'t parse!');
+			$this->setError('xml was empty, didn\'t parse!');
+		}
+	}
+
+	/**
+	* start-element handler
+	*
+	* @param    resource $parser XML parser object
+	* @param    string $name element name
+	* @param    array $attrs associative array of attributes
+	* @access   private
+	*/
+	function start_element($parser, $name, $attrs) {
+		// position in a total number of elements, starting from 0
+		// update class level pos
+		$pos = $this->position++;
+		// and set mine
+		$this->message[$pos] = array('pos' => $pos,'children'=>'','cdata'=>'');
+		// depth = how many levels removed from root?
+		// set mine as current global depth and increment global depth value
+		$this->message[$pos]['depth'] = $this->depth++;
+
+		// else add self as child to whoever the current parent is
+		if($pos != 0){
+			$this->message[$this->parent]['children'] .= '|'.$pos;
+		}
+		// set my parent
+		$this->message[$pos]['parent'] = $this->parent;
+		// set self as current parent
+		$this->parent = $pos;
+		// set self as current value for this depth
+		$this->depth_array[$this->depth] = $pos;
+		// get element prefix
+		if(strpos($name,':')){
+			// get ns prefix
+			$prefix = substr($name,0,strpos($name,':'));
+			// get unqualified name
+			$name = substr(strstr($name,':'),1);
+		}
+		// set status
+		if ($name == 'Envelope' && $this->status == '') {
+			$this->status = 'envelope';
+		} elseif ($name == 'Header' && $this->status == 'envelope') {
+			$this->root_header = $pos;
+			$this->status = 'header';
+		} elseif ($name == 'Body' && $this->status == 'envelope'){
+			$this->status = 'body';
+			$this->body_position = $pos;
+		// set method
+		} elseif($this->status == 'body' && $pos == ($this->body_position+1)) {
+			$this->status = 'method';
+			$this->root_struct_name = $name;
+			$this->root_struct = $pos;
+			$this->message[$pos]['type'] = 'struct';
+			$this->debug("found root struct $this->root_struct_name, pos $this->root_struct");
+		}
+		// set my status
+		$this->message[$pos]['status'] = $this->status;
+		// set name
+		$this->message[$pos]['name'] = htmlspecialchars($name);
+		// set attrs
+		$this->message[$pos]['attrs'] = $attrs;
+
+		// loop through atts, logging ns and type declarations
+        $attstr = '';
+		foreach($attrs as $key => $value){
+        	$key_prefix = $this->getPrefix($key);
+			$key_localpart = $this->getLocalPart($key);
+			// if ns declarations, add to class level array of valid namespaces
+            if($key_prefix == 'xmlns'){
+				if(preg_match('/^http:\/\/www.w3.org\/[0-9]{4}\/XMLSchema$/',$value)){
+					$this->XMLSchemaVersion = $value;
+					$this->namespaces['xsd'] = $this->XMLSchemaVersion;
+					$this->namespaces['xsi'] = $this->XMLSchemaVersion.'-instance';
+				}
+                $this->namespaces[$key_localpart] = $value;
+				// set method namespace
+				if($name == $this->root_struct_name){
+					$this->methodNamespace = $value;
+				}
+			// if it's a type declaration, set type
+        } elseif($key_localpart == 'type'){
+        		if (isset($this->message[$pos]['type']) && $this->message[$pos]['type'] == 'array') {
+        			// do nothing: already processed arrayType
+        		} else {
+	            	$value_prefix = $this->getPrefix($value);
+	                $value_localpart = $this->getLocalPart($value);
+					$this->message[$pos]['type'] = $value_localpart;
+					$this->message[$pos]['typePrefix'] = $value_prefix;
+	                if(isset($this->namespaces[$value_prefix])){
+	                	$this->message[$pos]['type_namespace'] = $this->namespaces[$value_prefix];
+	                } else if(isset($attrs['xmlns:'.$value_prefix])) {
+						$this->message[$pos]['type_namespace'] = $attrs['xmlns:'.$value_prefix];
+	                }
+					// should do something here with the namespace of specified type?
+				}
+			} elseif($key_localpart == 'arrayType'){
+				$this->message[$pos]['type'] = 'array';
+				/* do arrayType ereg here
+				[1]    arrayTypeValue    ::=    atype asize
+				[2]    atype    ::=    QName rank*
+				[3]    rank    ::=    '[' (',')* ']'
+				[4]    asize    ::=    '[' length~ ']'
+				[5]    length    ::=    nextDimension* Digit+
+				[6]    nextDimension    ::=    Digit+ ','
+				*/
+				$expr = '/([A-Za-z0-9_]+):([A-Za-z]+[A-Za-z0-9_]+)\[([0-9]+),?([0-9]*)\]/';
+				if(preg_match($expr,$value,$regs)){
+					$this->message[$pos]['typePrefix'] = $regs[1];
+					$this->message[$pos]['arrayTypePrefix'] = $regs[1];
+	                if (isset($this->namespaces[$regs[1]])) {
+	                	$this->message[$pos]['arrayTypeNamespace'] = $this->namespaces[$regs[1]];
+	                } else if (isset($attrs['xmlns:'.$regs[1]])) {
+						$this->message[$pos]['arrayTypeNamespace'] = $attrs['xmlns:'.$regs[1]];
+	                }
+					$this->message[$pos]['arrayType'] = $regs[2];
+					$this->message[$pos]['arraySize'] = $regs[3];
+					$this->message[$pos]['arrayCols'] = $regs[4];
+				}
+			// specifies nil value (or not)
+			} elseif ($key_localpart == 'nil'){
+				$this->message[$pos]['nil'] = ($value == 'true' || $value == '1');
+			// some other attribute
+			} elseif ($key != 'href' && $key != 'xmlns' && $key_localpart != 'encodingStyle' && $key_localpart != 'root') {
+				$this->message[$pos]['xattrs']['!' . $key] = $value;
+			}
+
+			if ($key == 'xmlns') {
+				$this->default_namespace = $value;
+			}
+			// log id
+			if($key == 'id'){
+				$this->ids[$value] = $pos;
+			}
+			// root
+			if($key_localpart == 'root' && $value == 1){
+				$this->status = 'method';
+				$this->root_struct_name = $name;
+				$this->root_struct = $pos;
+				$this->debug("found root struct $this->root_struct_name, pos $pos");
+			}
+            // for doclit
+            $attstr .= " $key=\"$value\"";
+		}
+        // get namespace - must be done after namespace atts are processed
+		if(isset($prefix)){
+			$this->message[$pos]['namespace'] = $this->namespaces[$prefix];
+			$this->default_namespace = $this->namespaces[$prefix];
+		} else {
+			$this->message[$pos]['namespace'] = $this->default_namespace;
+		}
+        if($this->status == 'header'){
+        	if ($this->root_header != $pos) {
+	        	$this->responseHeaders .= "<" . (isset($prefix) ? $prefix . ':' : '') . "$name$attstr>";
+	        }
+        } elseif($this->root_struct_name != ''){
+        	$this->document .= "<" . (isset($prefix) ? $prefix . ':' : '') . "$name$attstr>";
+        }
+	}
+
+	/**
+	* end-element handler
+	*
+	* @param    resource $parser XML parser object
+	* @param    string $name element name
+	* @access   private
+	*/
+	function end_element($parser, $name) {
+		// position of current element is equal to the last value left in depth_array for my depth
+		$pos = $this->depth_array[$this->depth--];
+
+        // get element prefix
+		if(strpos($name,':')){
+			// get ns prefix
+			$prefix = substr($name,0,strpos($name,':'));
+			// get unqualified name
+			$name = substr(strstr($name,':'),1);
+		}
+		
+		// build to native type
+		if(isset($this->body_position) && $pos > $this->body_position){
+			// deal w/ multirefs
+			if(isset($this->message[$pos]['attrs']['href'])){
+				// get id
+				$id = substr($this->message[$pos]['attrs']['href'],1);
+				// add placeholder to href array
+				$this->multirefs[$id][$pos] = 'placeholder';
+				// add set a reference to it as the result value
+				$this->message[$pos]['result'] =& $this->multirefs[$id][$pos];
+            // build complexType values
+			} elseif($this->message[$pos]['children'] != ''){
+				// if result has already been generated (struct/array)
+				if(!isset($this->message[$pos]['result'])){
+					$this->message[$pos]['result'] = $this->buildVal($pos);
+				}
+			// build complexType values of attributes and possibly simpleContent
+			} elseif (isset($this->message[$pos]['xattrs'])) {
+				if (isset($this->message[$pos]['nil']) && $this->message[$pos]['nil']) {
+					$this->message[$pos]['xattrs']['!'] = null;
+				} elseif (isset($this->message[$pos]['cdata']) && trim($this->message[$pos]['cdata']) != '') {
+	            	if (isset($this->message[$pos]['type'])) {
+						$this->message[$pos]['xattrs']['!'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$pos]['type'], isset($this->message[$pos]['type_namespace']) ? $this->message[$pos]['type_namespace'] : '');
+					} else {
+						$parent = $this->message[$pos]['parent'];
+						if (isset($this->message[$parent]['type']) && ($this->message[$parent]['type'] == 'array') && isset($this->message[$parent]['arrayType'])) {
+							$this->message[$pos]['xattrs']['!'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$parent]['arrayType'], isset($this->message[$parent]['arrayTypeNamespace']) ? $this->message[$parent]['arrayTypeNamespace'] : '');
+						} else {
+							$this->message[$pos]['xattrs']['!'] = $this->message[$pos]['cdata'];
+						}
+					}
+				}
+				$this->message[$pos]['result'] = $this->message[$pos]['xattrs'];
+			// set value of simpleType (or nil complexType)
+			} else {
+            	//$this->debug('adding data for scalar value '.$this->message[$pos]['name'].' of value '.$this->message[$pos]['cdata']);
+				if (isset($this->message[$pos]['nil']) && $this->message[$pos]['nil']) {
+					$this->message[$pos]['xattrs']['!'] = null;
+				} elseif (isset($this->message[$pos]['type'])) {
+					$this->message[$pos]['result'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$pos]['type'], isset($this->message[$pos]['type_namespace']) ? $this->message[$pos]['type_namespace'] : '');
+				} else {
+					$parent = $this->message[$pos]['parent'];
+					if (isset($this->message[$parent]['type']) && ($this->message[$parent]['type'] == 'array') && isset($this->message[$parent]['arrayType'])) {
+						$this->message[$pos]['result'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$parent]['arrayType'], isset($this->message[$parent]['arrayTypeNamespace']) ? $this->message[$parent]['arrayTypeNamespace'] : '');
+					} else {
+						$this->message[$pos]['result'] = $this->message[$pos]['cdata'];
+					}
+				}
+
+				/* add value to parent's result, if parent is struct/array
+				$parent = $this->message[$pos]['parent'];
+				if($this->message[$parent]['type'] != 'map'){
+					if(strtolower($this->message[$parent]['type']) == 'array'){
+						$this->message[$parent]['result'][] = $this->message[$pos]['result'];
+					} else {
+						$this->message[$parent]['result'][$this->message[$pos]['name']] = $this->message[$pos]['result'];
+					}
+				}
+				*/
+			}
+		}
+		
+        // for doclit
+        if($this->status == 'header'){
+        	if ($this->root_header != $pos) {
+	        	$this->responseHeaders .= "</" . (isset($prefix) ? $prefix . ':' : '') . "$name>";
+	        }
+        } elseif($pos >= $this->root_struct){
+        	$this->document .= "</" . (isset($prefix) ? $prefix . ':' : '') . "$name>";
+        }
+		// switch status
+		if ($pos == $this->root_struct){
+			$this->status = 'body';
+			$this->root_struct_namespace = $this->message[$pos]['namespace'];
+		} elseif ($pos == $this->root_header) {
+			$this->status = 'envelope';
+		} elseif ($name == 'Body' && $this->status == 'body') {
+			$this->status = 'envelope';
+		} elseif ($name == 'Header' && $this->status == 'header') { // will never happen
+			$this->status = 'envelope';
+		} elseif ($name == 'Envelope' && $this->status == 'envelope') {
+			$this->status = '';
+		}
+		// set parent back to my parent
+		$this->parent = $this->message[$pos]['parent'];
+	}
+
+	/**
+	* element content handler
+	*
+	* @param    resource $parser XML parser object
+	* @param    string $data element content
+	* @access   private
+	*/
+	function character_data($parser, $data){
+		$pos = $this->depth_array[$this->depth];
+		if ($this->xml_encoding=='UTF-8'){
+			// TODO: add an option to disable this for folks who want
+			// raw UTF-8 that, e.g., might not map to iso-8859-1
+			// TODO: this can also be handled with xml_parser_set_option($this->parser, XML_OPTION_TARGET_ENCODING, "ISO-8859-1");
+			if($this->decode_utf8){
+				$data = utf8_decode($data);
+			}
+		}
+        $this->message[$pos]['cdata'] .= $data;
+        // for doclit
+        if($this->status == 'header'){
+        	$this->responseHeaders .= $data;
+        } else {
+        	$this->document .= $data;
+        }
+	}
+
+	/**
+	* get the parsed message (SOAP Body)
+	*
+	* @return	mixed
+	* @access   public
+	* @deprecated	use get_soapbody instead
+	*/
+	function get_response(){
+		return $this->soapresponse;
+	}
+
+	/**
+	* get the parsed SOAP Body (NULL if there was none)
+	*
+	* @return	mixed
+	* @access   public
+	*/
+	function get_soapbody(){
+		return $this->soapresponse;
+	}
+
+	/**
+	* get the parsed SOAP Header (NULL if there was none)
+	*
+	* @return	mixed
+	* @access   public
+	*/
+	function get_soapheader(){
+		return $this->soapheader;
+	}
+
+	/**
+	* get the unparsed SOAP Header
+	*
+	* @return	string XML or empty if no Header
+	* @access   public
+	*/
+	function getHeaders(){
+	    return $this->responseHeaders;
+	}
+
+	/**
+	* decodes simple types into PHP variables
+	*
+	* @param    string $value value to decode
+	* @param    string $type XML type to decode
+	* @param    string $typens XML type namespace to decode
+	* @return	mixed PHP value
+	* @access   private
+	*/
+	function decodeSimple($value, $type, $typens) {
+		// TODO: use the namespace!
+		if ((!isset($type)) || $type == 'string' || $type == 'long' || $type == 'unsignedLong') {
+			return (string) $value;
+		}
+		if ($type == 'int' || $type == 'integer' || $type == 'short' || $type == 'byte') {
+			return (int) $value;
+		}
+		if ($type == 'float' || $type == 'double' || $type == 'decimal') {
+			return (double) $value;
+		}
+		if ($type == 'boolean') {
+			if (strtolower($value) == 'false' || strtolower($value) == 'f') {
+				return false;
+			}
+			return (boolean) $value;
+		}
+		if ($type == 'base64' || $type == 'base64Binary') {
+			$this->debug('Decode base64 value');
+			return base64_decode($value);
+		}
+		// obscure numeric types
+		if ($type == 'nonPositiveInteger' || $type == 'negativeInteger'
+			|| $type == 'nonNegativeInteger' || $type == 'positiveInteger'
+			|| $type == 'unsignedInt'
+			|| $type == 'unsignedShort' || $type == 'unsignedByte') {
+			return (int) $value;
+		}
+		// bogus: parser treats array with no elements as a simple type
+		if ($type == 'array') {
+			return array();
+		}
+		// everything else
+		return (string) $value;
+	}
+
+	/**
+	* builds response structures for compound values (arrays/structs)
+	* and scalars
+	*
+	* @param    integer $pos position in node tree
+	* @return	mixed	PHP value
+	* @access   private
+	*/
+	function buildVal($pos){
+		if(!isset($this->message[$pos]['type'])){
+			$this->message[$pos]['type'] = '';
+		}
+		$this->debug('in buildVal() for '.$this->message[$pos]['name']."(pos $pos) of type ".$this->message[$pos]['type']);
+		// if there are children...
+		if($this->message[$pos]['children'] != ''){
+			$this->debug('in buildVal, there are children');
+			$children = explode('|',$this->message[$pos]['children']);
+			array_shift($children); // knock off empty
+			// md array
+			if(isset($this->message[$pos]['arrayCols']) && $this->message[$pos]['arrayCols'] != ''){
+            	$r=0; // rowcount
+            	$c=0; // colcount
+            	foreach($children as $child_pos){
+					$this->debug("in buildVal, got an MD array element: $r, $c");
+					$params[$r][] = $this->message[$child_pos]['result'];
+				    $c++;
+				    if($c == $this->message[$pos]['arrayCols']){
+				    	$c = 0;
+						$r++;
+				    }
+                }
+            // array
+			} elseif($this->message[$pos]['type'] == 'array' || $this->message[$pos]['type'] == 'Array'){
+                $this->debug('in buildVal, adding array '.$this->message[$pos]['name']);
+                foreach($children as $child_pos){
+                	$params[] = &$this->message[$child_pos]['result'];
+                }
+            // apache Map type: java hashtable
+            } elseif($this->message[$pos]['type'] == 'Map' && $this->message[$pos]['type_namespace'] == 'http://xml.apache.org/xml-soap'){
+                $this->debug('in buildVal, Java Map '.$this->message[$pos]['name']);
+                foreach($children as $child_pos){
+                	$kv = explode("|",$this->message[$child_pos]['children']);
+                   	$params[$this->message[$kv[1]]['result']] = &$this->message[$kv[2]]['result'];
+                }
+            // generic compound type
+            //} elseif($this->message[$pos]['type'] == 'SOAPStruct' || $this->message[$pos]['type'] == 'struct') {
+		    } else {
+	    		// Apache Vector type: treat as an array
+                $this->debug('in buildVal, adding Java Vector or generic compound type '.$this->message[$pos]['name']);
+				if ($this->message[$pos]['type'] == 'Vector' && $this->message[$pos]['type_namespace'] == 'http://xml.apache.org/xml-soap') {
+					$notstruct = 1;
+				} else {
+					$notstruct = 0;
+	            }
+            	//
+            	foreach($children as $child_pos){
+            		if($notstruct){
+            			$params[] = &$this->message[$child_pos]['result'];
+            		} else {
+            			if (isset($params[$this->message[$child_pos]['name']])) {
+            				// de-serialize repeated element name into an array
+            				if ((!is_array($params[$this->message[$child_pos]['name']])) || (!isset($params[$this->message[$child_pos]['name']][0]))) {
+            					$params[$this->message[$child_pos]['name']] = array($params[$this->message[$child_pos]['name']]);
+            				}
+            				$params[$this->message[$child_pos]['name']][] = &$this->message[$child_pos]['result'];
+            			} else {
+					    	$params[$this->message[$child_pos]['name']] = &$this->message[$child_pos]['result'];
+					    }
+                	}
+                }
+			}
+			if (isset($this->message[$pos]['xattrs'])) {
+                $this->debug('in buildVal, handling attributes');
+				foreach ($this->message[$pos]['xattrs'] as $n => $v) {
+					$params[$n] = $v;
+				}
+			}
+			// handle simpleContent
+			if (isset($this->message[$pos]['cdata']) && trim($this->message[$pos]['cdata']) != '') {
+                $this->debug('in buildVal, handling simpleContent');
+            	if (isset($this->message[$pos]['type'])) {
+					$params['!'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$pos]['type'], isset($this->message[$pos]['type_namespace']) ? $this->message[$pos]['type_namespace'] : '');
+				} else {
+					$parent = $this->message[$pos]['parent'];
+					if (isset($this->message[$parent]['type']) && ($this->message[$parent]['type'] == 'array') && isset($this->message[$parent]['arrayType'])) {
+						$params['!'] = $this->decodeSimple($this->message[$pos]['cdata'], $this->message[$parent]['arrayType'], isset($this->message[$parent]['arrayTypeNamespace']) ? $this->message[$parent]['arrayTypeNamespace'] : '');
+					} else {
+						$params['!'] = $this->message[$pos]['cdata'];
+					}
+				}
+			}
+			$ret = is_array($params) ? $params : array();
+			$this->debug('in buildVal, return:');
+			$this->appendDebug($this->varDump($ret));
+			return $ret;
+		} else {
+        	$this->debug('in buildVal, no children, building scalar');
+			$cdata = isset($this->message[$pos]['cdata']) ? $this->message[$pos]['cdata'] : '';
+        	if (isset($this->message[$pos]['type'])) {
+				$ret = $this->decodeSimple($cdata, $this->message[$pos]['type'], isset($this->message[$pos]['type_namespace']) ? $this->message[$pos]['type_namespace'] : '');
+				$this->debug("in buildVal, return: $ret");
+				return $ret;
+			}
+			$parent = $this->message[$pos]['parent'];
+			if (isset($this->message[$parent]['type']) && ($this->message[$parent]['type'] == 'array') && isset($this->message[$parent]['arrayType'])) {
+				$ret = $this->decodeSimple($cdata, $this->message[$parent]['arrayType'], isset($this->message[$parent]['arrayTypeNamespace']) ? $this->message[$parent]['arrayTypeNamespace'] : '');
+				$this->debug("in buildVal, return: $ret");
+				return $ret;
+			}
+           	$ret = $this->message[$pos]['cdata'];
+			$this->debug("in buildVal, return: $ret");
+           	return $ret;
+		}
+	}
+}
+
+/**
+ * Backward compatibility
+ */
+class soap_parser extends nusoap_parser {
+}
+
+?><?php
+
+
+
+/**
+*
+* [nu]soapclient higher level class for easy usage.
+*
+* usage:
+*
+* // instantiate client with server info
+* $soapclient = new nusoap_client( string path [ ,mixed wsdl] );
+*
+* // call method, get results
+* echo $soapclient->call( string methodname [ ,array parameters] );
+*
+* // bye bye client
+* unset($soapclient);
+*
+* @author   Dietrich Ayala <dietrich@ganx4.com>
+* @author   Scott Nichol <snichol@users.sourceforge.net>
+* @version  $Id: nusoap.php,v 1.123 2010/04/26 20:15:08 snichol Exp $
+* @access   public
+*/
+class nusoap_client extends nusoap_base  {
+
+	var $username = '';				// Username for HTTP authentication
+	var $password = '';				// Password for HTTP authentication
+	var $authtype = '';				// Type of HTTP authentication
+	var $certRequest = array();		// Certificate for HTTP SSL authentication
+	var $requestHeaders = false;	// SOAP headers in request (text)
+	var $responseHeaders = '';		// SOAP headers from response (incomplete namespace resolution) (text)
+	var $responseHeader = NULL;		// SOAP Header from response (parsed)
+	var $document = '';				// SOAP body response portion (incomplete namespace resolution) (text)
+	var $endpoint;
+	var $forceEndpoint = '';		// overrides WSDL endpoint
+    var $proxyhost = '';
+    var $proxyport = '';
+	var $proxyusername = '';
+	var $proxypassword = '';
+	var $portName = '';				// port name to use in WSDL
+    var $xml_encoding = '';			// character set encoding of incoming (response) messages
+	var $http_encoding = false;
+	var $timeout = 0;				// HTTP connection timeout
+	var $response_timeout = 30;		// HTTP response timeout
+	var $endpointType = '';			// soap|wsdl, empty for WSDL initialization error
+	var $persistentConnection = false;
+	var $defaultRpcParams = false;	// This is no longer used
+	var $request = '';				// HTTP request
+	var $response = '';				// HTTP response
+	var $responseData = '';			// SOAP payload of response
+	var $cookies = array();			// Cookies from response or for request
+    var $decode_utf8 = true;		// toggles whether the parser decodes element content w/ utf8_decode()
+	var $operations = array();		// WSDL operations, empty for WSDL initialization error
+	var $curl_options = array();	// User-specified cURL options
+	var $bindingType = '';			// WSDL operation binding type
+	var $use_curl = false;			// whether to always try to use cURL
+
+	/*
+	 * fault related variables
+	 */
+	/**
+	 * @var      fault
+	 * @access   public
+	 */
+	var $fault;
+	/**
+	 * @var      faultcode
+	 * @access   public
+	 */
+	var $faultcode;
+	/**
+	 * @var      faultstring
+	 * @access   public
+	 */
+	var $faultstring;
+	/**
+	 * @var      faultdetail
+	 * @access   public
+	 */
+	var $faultdetail;
+
+	/**
+	* constructor
+	*
+	* @param    mixed $endpoint SOAP server or WSDL URL (string), or wsdl instance (object)
+	* @param    mixed $wsdl optional, set to 'wsdl' or true if using WSDL
+	* @param    string $proxyhost optional
+	* @param    string $proxyport optional
+	* @param	string $proxyusername optional
+	* @param	string $proxypassword optional
+	* @param	integer $timeout set the connection timeout
+	* @param	integer $response_timeout set the response timeout
+	* @param	string $portName optional portName in WSDL document
+	* @access   public
+	*/
+	function nusoap_client($endpoint,$wsdl = false,$proxyhost = false,$proxyport = false,$proxyusername = false, $proxypassword = false, $timeout = 0, $response_timeout = 30, $portName = ''){
+		parent::nusoap_base();
+		$this->endpoint = $endpoint;
+		$this->proxyhost = $proxyhost;
+		$this->proxyport = $proxyport;
+		$this->proxyusername = $proxyusername;
+		$this->proxypassword = $proxypassword;
+		$this->timeout = $timeout;
+		$this->response_timeout = $response_timeout;
+		$this->portName = $portName;
+
+		$this->debug("ctor wsdl=$wsdl timeout=$timeout response_timeout=$response_timeout");
+		$this->appendDebug('endpoint=' . $this->varDump($endpoint));
+
+		// make values
+		if($wsdl){
+			if (is_object($endpoint) && (get_class($endpoint) == 'wsdl')) {
+				$this->wsdl = $endpoint;
+				$this->endpoint = $this->wsdl->wsdl;
+				$this->wsdlFile = $this->endpoint;
+				$this->debug('existing wsdl instance created from ' . $this->endpoint);
+				$this->checkWSDL();
+			} else {
+				$this->wsdlFile = $this->endpoint;
+				$this->wsdl = null;
+				$this->debug('will use lazy evaluation of wsdl from ' . $this->endpoint);
+			}
+			$this->endpointType = 'wsdl';
+		} else {
+			$this->debug("instantiate SOAP with endpoint at $endpoint");
+			$this->endpointType = 'soap';
+		}
+	}
+
+	/**
+	* calls method, returns PHP native type
+	*
+	* @param    string $operation SOAP server URL or path
+	* @param    mixed $params An array, associative or simple, of the parameters
+	*			              for the method call, or a string that is the XML
+	*			              for the call.  For rpc style, this call will
+	*			              wrap the XML in a tag named after the method, as
+	*			              well as the SOAP Envelope and Body.  For document
+	*			              style, this will only wrap with the Envelope and Body.
+	*			              IMPORTANT: when using an array with document style,
+	*			              in which case there
+	*                         is really one parameter, the root of the fragment
+	*                         used in the call, which encloses what programmers
+	*                         normally think of parameters.  A parameter array
+	*                         *must* include the wrapper.
+	* @param	string $namespace optional method namespace (WSDL can override)
+	* @param	string $soapAction optional SOAPAction value (WSDL can override)
+	* @param	mixed $headers optional string of XML with SOAP header content, or array of soapval objects for SOAP headers, or associative array
+	* @param	boolean $rpcParams optional (no longer used)
+	* @param	string	$style optional (rpc|document) the style to use when serializing parameters (WSDL can override)
+	* @param	string	$use optional (encoded|literal) the use when serializing parameters (WSDL can override)
+	* @return	mixed	response from SOAP call, normally an associative array mirroring the structure of the XML response, false for certain fatal errors
+	* @access   public
+	*/
+	function call($operation,$params=array(),$namespace='http://tempuri.org',$soapAction='',$headers=false,$rpcParams=null,$style='rpc',$use='encoded'){
+		$this->operation = $operation;
+		$this->fault = false;
+		$this->setError('');
+		$this->request = '';
+		$this->response = '';
+		$this->responseData = '';
+		$this->faultstring = '';
+		$this->faultcode = '';
+		$this->opData = array();
+		
+		$this->debug("call: operation=$operation, namespace=$namespace, soapAction=$soapAction, rpcParams=$rpcParams, style=$style, use=$use, endpointType=$this->endpointType");
+		$this->appendDebug('params=' . $this->varDump($params));
+		$this->appendDebug('headers=' . $this->varDump($headers));
+		if ($headers) {
+			$this->requestHeaders = $headers;
+		}
+		if ($this->endpointType == 'wsdl' && is_null($this->wsdl)) {
+			$this->loadWSDL();
+			if ($this->getError())
+				return false;
+		}
+		// serialize parameters
+		if($this->endpointType == 'wsdl' && $opData = $this->getOperationData($operation)){
+			// use WSDL for operation
+			$this->opData = $opData;
+			$this->debug("found operation");
+			$this->appendDebug('opData=' . $this->varDump($opData));
+			if (isset($opData['soapAction'])) {
+				$soapAction = $opData['soapAction'];
+			}
+			if (! $this->forceEndpoint) {
+				$this->endpoint = $opData['endpoint'];
+			} else {
+				$this->endpoint = $this->forceEndpoint;
+			}
+			$namespace = isset($opData['input']['namespace']) ? $opData['input']['namespace'] :	$namespace;
+			$style = $opData['style'];
+			$use = $opData['input']['use'];
+			// add ns to ns array
+			if($namespace != '' && !isset($this->wsdl->namespaces[$namespace])){
+				$nsPrefix = 'ns' . rand(1000, 9999);
+				$this->wsdl->namespaces[$nsPrefix] = $namespace;
+			}
+            $nsPrefix = $this->wsdl->getPrefixFromNamespace($namespace);
+			// serialize payload
+			if (is_string($params)) {
+				$this->debug("serializing param string for WSDL operation $operation");
+				$payload = $params;
+			} elseif (is_array($params)) {
+				$this->debug("serializing param array for WSDL operation $operation");
+				$payload = $this->wsdl->serializeRPCParameters($operation,'input',$params,$this->bindingType);
+			} else {
+				$this->debug('params must be array or string');
+				$this->setError('params must be array or string');
+				return false;
+			}
+            $usedNamespaces = $this->wsdl->usedNamespaces;
+			if (isset($opData['input']['encodingStyle'])) {
+				$encodingStyle = $opData['input']['encodingStyle'];
+			} else {
+				$encodingStyle = '';
+			}
+			$this->appendDebug($this->wsdl->getDebug());
+			$this->wsdl->clearDebug();
+			if ($errstr = $this->wsdl->getError()) {
+				$this->debug('got wsdl error: '.$errstr);
+				$this->setError('wsdl error: '.$errstr);
+				return false;
+			}
+		} elseif($this->endpointType == 'wsdl') {
+			// operation not in WSDL
+			$this->appendDebug($this->wsdl->getDebug());
+			$this->wsdl->clearDebug();
+			$this->setError('operation '.$operation.' not present in WSDL.');
+			$this->debug("operation '$operation' not present in WSDL.");
+			return false;
+		} else {
+			// no WSDL
+			//$this->namespaces['ns1'] = $namespace;
+			$nsPrefix = 'ns' . rand(1000, 9999);
+			// serialize 
+			$payload = '';
+			if (is_string($params)) {
+				$this->debug("serializing param string for operation $operation");
+				$payload = $params;
+			} elseif (is_array($params)) {
+				$this->debug("serializing param array for operation $operation");
+				foreach($params as $k => $v){
+					$payload .= $this->serialize_val($v,$k,false,false,false,false,$use);
+				}
+			} else {
+				$this->debug('params must be array or string');
+				$this->setError('params must be array or string');
+				return false;
+			}
+			$usedNamespaces = array();
+			if ($use == 'encoded') {
+				$encodingStyle = 'http://schemas.xmlsoap.org/soap/encoding/';
+			} else {
+				$encodingStyle = '';
+			}
+		}
+		// wrap RPC calls with method element
+		if ($style == 'rpc') {
+			if ($use == 'literal') {
+				$this->debug("wrapping RPC request with literal method element");
+				if ($namespace) {
+					// http://www.ws-i.org/Profiles/BasicProfile-1.1-2004-08-24.html R2735 says rpc/literal accessor elements should not be in a namespace
+					$payload = "<$nsPrefix:$operation xmlns:$nsPrefix=\"$namespace\">" .
+								$payload .
+								"</$nsPrefix:$operation>";
+				} else {
+					$payload = "<$operation>" . $payload . "</$operation>";
+				}
+			} else {
+				$this->debug("wrapping RPC request with encoded method element");
+				if ($namespace) {
+					$payload = "<$nsPrefix:$operation xmlns:$nsPrefix=\"$namespace\">" .
+								$payload .
+								"</$nsPrefix:$operation>";
+				} else {
+					$payload = "<$operation>" .
+								$payload .
+								"</$operation>";
+				}
+			}
+		}
+		// serialize envelope
+		$soapmsg = $this->serializeEnvelope($payload,$this->requestHeaders,$usedNamespaces,$style,$use,$encodingStyle);
+		$this->debug("endpoint=$this->endpoint, soapAction=$soapAction, namespace=$namespace, style=$style, use=$use, encodingStyle=$encodingStyle");
+		$this->debug('SOAP message length=' . strlen($soapmsg) . ' contents (max 1000 bytes)=' . substr($soapmsg, 0, 1000));
+		// send
+		$return = $this->send($this->getHTTPBody($soapmsg),$soapAction,$this->timeout,$this->response_timeout);
+		if($errstr = $this->getError()){
+			$this->debug('Error: '.$errstr);
+			return false;
+		} else {
+			$this->return = $return;
+			$this->debug('sent message successfully and got a(n) '.gettype($return));
+           	$this->appendDebug('return=' . $this->varDump($return));
+			
+			// fault?
+			if(is_array($return) && isset($return['faultcode'])){
+				$this->debug('got fault');
+				$this->setError($return['faultcode'].': '.$return['faultstring']);
+				$this->fault = true;
+				foreach($return as $k => $v){
+					$this->$k = $v;
+					$this->debug("$k = $v<br>");
+				}
+				return $return;
+			} elseif ($style == 'document') {
+				// NOTE: if the response is defined to have multiple parts (i.e. unwrapped),
+				// we are only going to return the first part here...sorry about that
+				return $return;
+			} else {
+				// array of return values
+				if(is_array($return)){
+					// multiple 'out' parameters, which we return wrapped up
+					// in the array
+					if(sizeof($return) > 1){
+						return $return;
+					}
+					// single 'out' parameter (normally the return value)
+					$return = array_shift($return);
+					$this->debug('return shifted value: ');
+					$this->appendDebug($this->varDump($return));
+           			return $return;
+				// nothing returned (ie, echoVoid)
+				} else {
+					return "";
+				}
+			}
+		}
+	}
+
+	/**
+	* check WSDL passed as an instance or pulled from an endpoint
+	*
+	* @access   private
+	*/
+	function checkWSDL() {
+		$this->appendDebug($this->wsdl->getDebug());
+		$this->wsdl->clearDebug();
+		$this->debug('checkWSDL');
+		// catch errors
+		if ($errstr = $this->wsdl->getError()) {
+			$this->appendDebug($this->wsdl->getDebug());
+			$this->wsdl->clearDebug();
+			$this->debug('got wsdl error: '.$errstr);
+			$this->setError('wsdl error: '.$errstr);
+		} elseif ($this->operations = $this->wsdl->getOperations($this->portName, 'soap')) {
+			$this->appendDebug($this->wsdl->getDebug());
+			$this->wsdl->clearDebug();
+			$this->bindingType = 'soap';
+			$this->debug('got '.count($this->operations).' operations from wsdl '.$this->wsdlFile.' for binding type '.$this->bindingType);
+		} elseif ($this->operations = $this->wsdl->getOperations($this->portName, 'soap12')) {
+			$this->appendDebug($this->wsdl->getDebug());
+			$this->wsdl->clearDebug();
+			$this->bindingType = 'soap12';
+			$this->debug('got '.count($this->operations).' operations from wsdl '.$this->wsdlFile.' for binding type '.$this->bindingType);
+			$this->debug('**************** WARNING: SOAP 1.2 BINDING *****************');
+		} else {
+			$this->appendDebug($this->wsdl->getDebug());
+			$this->wsdl->clearDebug();
+			$this->debug('getOperations returned false');
+			$this->setError('no operations defined in the WSDL document!');
+		}
+	}
+
+	/**
+	 * instantiate wsdl object and parse wsdl file
+	 *
+	 * @access	public
+	 */
+	function loadWSDL() {
+		$this->debug('instantiating wsdl class with doc: '.$this->wsdlFile);
+		$this->wsdl = new wsdl('',$this->proxyhost,$this->proxyport,$this->proxyusername,$this->proxypassword,$this->timeout,$this->response_timeout,$this->curl_options,$this->use_curl);
+		$this->wsdl->setCredentials($this->username, $this->password, $this->authtype, $this->certRequest);
+		$this->wsdl->fetchWSDL($this->wsdlFile);
+		$this->checkWSDL();
+	}
+
+	/**
+	* get available data pertaining to an operation
+	*
+	* @param    string $operation operation name
+	* @return	array array of data pertaining to the operation
+	* @access   public
+	*/
+	function getOperationData($operation){
+		if ($this->endpointType == 'wsdl' && is_null($this->wsdl)) {
+			$this->loadWSDL();
+			if ($this->getError())
+				return false;
+		}
+		if(isset($this->operations[$operation])){
+			return $this->operations[$operation];
+		}
+		$this->debug("No data for operation: $operation");
+	}
+
+    /**
+    * send the SOAP message
+    *
+    * Note: if the operation has multiple return values
+    * the return value of this method will be an array
+    * of those values.
+    *
+	* @param    string $msg a SOAPx4 soapmsg object
+	* @param    string $soapaction SOAPAction value
+	* @param    integer $timeout set connection timeout in seconds
+	* @param	integer $response_timeout set response timeout in seconds
+	* @return	mixed native PHP types.
+	* @access   private
+	*/
+	function send($msg, $soapaction = '', $timeout=0, $response_timeout=30) {
+		$this->checkCookies();
+		// detect transport
+		switch(true){
+			// http(s)
+			case preg_match('/^http/',$this->endpoint):
+				$this->debug('transporting via HTTP');
+				if($this->persistentConnection == true && is_object($this->persistentConnection)){
+					$http =& $this->persistentConnection;
+				} else {
+					$http = new soap_transport_http($this->endpoint, $this->curl_options, $this->use_curl);
+					if ($this->persistentConnection) {
+						$http->usePersistentConnection();
+					}
+				}
+				$http->setContentType($this->getHTTPContentType(), $this->getHTTPContentTypeCharset());
+				$http->setSOAPAction($soapaction);
+				if($this->proxyhost && $this->proxyport){
+					$http->setProxy($this->proxyhost,$this->proxyport,$this->proxyusername,$this->proxypassword);
+				}
+                if($this->authtype != '') {
+					$http->setCredentials($this->username, $this->password, $this->authtype, array(), $this->certRequest);
+				}
+				if($this->http_encoding != ''){
+					$http->setEncoding($this->http_encoding);
+				}
+				$this->debug('sending message, length='.strlen($msg));
+				if(preg_match('/^http:/',$this->endpoint)){
+				//if(strpos($this->endpoint,'http:')){
+					$this->responseData = $http->send($msg,$timeout,$response_timeout,$this->cookies);
+				} elseif(preg_match('/^https/',$this->endpoint)){
+				//} elseif(strpos($this->endpoint,'https:')){
+					//if(phpversion() == '4.3.0-dev'){
+						//$response = $http->send($msg,$timeout,$response_timeout);
+                   		//$this->request = $http->outgoing_payload;
+						//$this->response = $http->incoming_payload;
+					//} else
+					$this->responseData = $http->sendHTTPS($msg,$timeout,$response_timeout,$this->cookies);
+				} else {
+					$this->setError('no http/s in endpoint url');
+				}
+				$this->request = $http->outgoing_payload;
+				$this->response = $http->incoming_payload;		
+				$this->appendDebug($http->getDebug());
+				$this->UpdateCookies($http->incoming_cookies);
+
+				// save transport object if using persistent connections
+				if ($this->persistentConnection) {
+					$http->clearDebug();
+					if (!is_object($this->persistentConnection)) {
+						$this->persistentConnection = $http;
+					}
+				}
+				
+				if($err = $http->getError()){
+					$this->setError('HTTP Error: '.$err);
+					return false;
+				} elseif($this->getError()){
+					return false;
+				} else {
+					$this->debug('got response, length='. strlen($this->responseData).' type='.$http->incoming_headers['content-type']);
+					//@@hack  
+/*				$this->responseData = "\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><SOAP-ENV:Envelope SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\" xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\"><SOAP-ENV:Body><ns1:add_userResponse xmlns:ns1=\"http://novaforge.bull.net\"><return xsi:type=\"xsd:integer\">26</return></ns1:add_userResponse></SOAP-ENV:Body></SOAP-ENV:Envelope>"; */
+					return $this->parseResponse($http->incoming_headers, $this->responseData);
+				}
+			break;
+			default:
+				$this->setError('no transport found, or selected transport is not yet supported!');
+			return false;
+			break;
+		}
+	}
+
+	/**
+	* processes SOAP message returned from server
+	*
+	* @param	array	$headers	The HTTP headers
+	* @param	string	$data		unprocessed response data from server
+	* @return	mixed	value of the message, decoded into a PHP type
+	* @access   private
+	*/
+    function parseResponse($headers, $data) {
+		$this->debug('Entering parseResponse() for data of length ' . strlen($data) . ' headers:');
+		$this->appendDebug($this->varDump($headers));
+    	if (!isset($headers['content-type'])) {
+			$this->setError('Response not of type text/xml (no content-type header)');
+			return false;
+    	}
+		if (!strstr($headers['content-type'], 'text/xml')) {
+			$this->setError('Response not of type text/xml: ' . $headers['content-type']);
+			return false;
+		}
+		if (strpos($headers['content-type'], '=')) {
+			$enc = str_replace('"', '', substr(strstr($headers["content-type"], '='), 1));
+			$this->debug('Got response encoding: ' . $enc);
+			if(preg_match('/^(ISO-8859-1|US-ASCII|UTF-8)$/i',$enc)){
+				$this->xml_encoding = strtoupper($enc);
+			} else {
+				$this->xml_encoding = 'US-ASCII';
+			}
+		} else {
+			// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+			$this->xml_encoding = 'ISO-8859-1';
+		}
+		$this->debug('Use encoding: ' . $this->xml_encoding . ' when creating nusoap_parser');
+		$parser = new nusoap_parser($data,$this->xml_encoding,$this->operation,$this->decode_utf8);
+		// add parser debug data to our debug
+		$this->appendDebug($parser->getDebug());
+		// if parse errors
+		if($errstr = $parser->getError()){
+			$this->setError( $errstr);
+			// destroy the parser object
+			unset($parser);
+			return false;
+		} else {
+			// get SOAP headers
+			$this->responseHeaders = $parser->getHeaders();
+			// get SOAP headers
+			$this->responseHeader = $parser->get_soapheader();
+			// get decoded message
+			$return = $parser->get_soapbody();
+            // add document for doclit support
+            $this->document = $parser->document;
+			// destroy the parser object
+			unset($parser);
+			// return decode message
+			return $return;
+		}
+	 }
+
+	/**
+	* sets user-specified cURL options
+	*
+	* @param	mixed $option The cURL option (always integer?)
+	* @param	mixed $value The cURL option value
+	* @access   public
+	*/
+	function setCurlOption($option, $value) {
+		$this->debug("setCurlOption option=$option, value=");
+		$this->appendDebug($this->varDump($value));
+		$this->curl_options[$option] = $value;
+	}
+
+	/**
+	* sets the SOAP endpoint, which can override WSDL
+	*
+	* @param	string $endpoint The endpoint URL to use, or empty string or false to prevent override
+	* @access   public
+	*/
+	function setEndpoint($endpoint) {
+		$this->debug("setEndpoint(\"$endpoint\")");
+		$this->forceEndpoint = $endpoint;
+	}
+
+	/**
+	* set the SOAP headers
+	*
+	* @param	mixed $headers String of XML with SOAP header content, or array of soapval objects for SOAP headers
+	* @access   public
+	*/
+	function setHeaders($headers){
+		$this->debug("setHeaders headers=");
+		$this->appendDebug($this->varDump($headers));
+		$this->requestHeaders = $headers;
+	}
+
+	/**
+	* get the SOAP response headers (namespace resolution incomplete)
+	*
+	* @return	string
+	* @access   public
+	*/
+	function getHeaders(){
+		return $this->responseHeaders;
+	}
+
+	/**
+	* get the SOAP response Header (parsed)
+	*
+	* @return	mixed
+	* @access   public
+	*/
+	function getHeader(){
+		return $this->responseHeader;
+	}
+
+	/**
+	* set proxy info here
+	*
+	* @param    string $proxyhost
+	* @param    string $proxyport
+	* @param	string $proxyusername
+	* @param	string $proxypassword
+	* @access   public
+	*/
+	function setHTTPProxy($proxyhost, $proxyport, $proxyusername = '', $proxypassword = '') {
+		$this->proxyhost = $proxyhost;
+		$this->proxyport = $proxyport;
+		$this->proxyusername = $proxyusername;
+		$this->proxypassword = $proxypassword;
+	}
+
+	/**
+	* if authenticating, set user credentials here
+	*
+	* @param    string $username
+	* @param    string $password
+	* @param	string $authtype (basic|digest|certificate|ntlm)
+	* @param	array $certRequest (keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, verifypeer (optional), verifyhost (optional): see corresponding options in cURL docs)
+	* @access   public
+	*/
+	function setCredentials($username, $password, $authtype = 'basic', $certRequest = array()) {
+		$this->debug("setCredentials username=$username authtype=$authtype certRequest=");
+		$this->appendDebug($this->varDump($certRequest));
+		$this->username = $username;
+		$this->password = $password;
+		$this->authtype = $authtype;
+		$this->certRequest = $certRequest;
+	}
+	
+	/**
+	* use HTTP encoding
+	*
+	* @param    string $enc HTTP encoding
+	* @access   public
+	*/
+	function setHTTPEncoding($enc='gzip, deflate'){
+		$this->debug("setHTTPEncoding(\"$enc\")");
+		$this->http_encoding = $enc;
+	}
+	
+	/**
+	* Set whether to try to use cURL connections if possible
+	*
+	* @param	boolean $use Whether to try to use cURL
+	* @access   public
+	*/
+	function setUseCURL($use) {
+		$this->debug("setUseCURL($use)");
+		$this->use_curl = $use;
+	}
+
+	/**
+	* use HTTP persistent connections if possible
+	*
+	* @access   public
+	*/
+	function useHTTPPersistentConnection(){
+		$this->debug("useHTTPPersistentConnection");
+		$this->persistentConnection = true;
+	}
+	
+	/**
+	* gets the default RPC parameter setting.
+	* If true, default is that call params are like RPC even for document style.
+	* Each call() can override this value.
+	*
+	* This is no longer used.
+	*
+	* @return boolean
+	* @access public
+	* @deprecated
+	*/
+	function getDefaultRpcParams() {
+		return $this->defaultRpcParams;
+	}
+
+	/**
+	* sets the default RPC parameter setting.
+	* If true, default is that call params are like RPC even for document style
+	* Each call() can override this value.
+	*
+	* This is no longer used.
+	*
+	* @param    boolean $rpcParams
+	* @access public
+	* @deprecated
+	*/
+	function setDefaultRpcParams($rpcParams) {
+		$this->defaultRpcParams = $rpcParams;
+	}
+	
+	/**
+	* dynamically creates an instance of a proxy class,
+	* allowing user to directly call methods from wsdl
+	*
+	* @return   object soap_proxy object
+	* @access   public
+	*/
+	function getProxy() {
+		$r = rand();
+		$evalStr = $this->_getProxyClassCode($r);
+		//$this->debug("proxy class: $evalStr");
+		if ($this->getError()) {
+			$this->debug("Error from _getProxyClassCode, so return NULL");
+			return null;
+		}
+		// eval the class
+		eval($evalStr);
+		// instantiate proxy object
+		eval("\$proxy = new nusoap_proxy_$r('');");
+		// transfer current wsdl data to the proxy thereby avoiding parsing the wsdl twice
+		$proxy->endpointType = 'wsdl';
+		$proxy->wsdlFile = $this->wsdlFile;
+		$proxy->wsdl = $this->wsdl;
+		$proxy->operations = $this->operations;
+		$proxy->defaultRpcParams = $this->defaultRpcParams;
+		// transfer other state
+		$proxy->soap_defencoding = $this->soap_defencoding;
+		$proxy->username = $this->username;
+		$proxy->password = $this->password;
+		$proxy->authtype = $this->authtype;
+		$proxy->certRequest = $this->certRequest;
+		$proxy->requestHeaders = $this->requestHeaders;
+		$proxy->endpoint = $this->endpoint;
+		$proxy->forceEndpoint = $this->forceEndpoint;
+		$proxy->proxyhost = $this->proxyhost;
+		$proxy->proxyport = $this->proxyport;
+		$proxy->proxyusername = $this->proxyusername;
+		$proxy->proxypassword = $this->proxypassword;
+		$proxy->http_encoding = $this->http_encoding;
+		$proxy->timeout = $this->timeout;
+		$proxy->response_timeout = $this->response_timeout;
+		$proxy->persistentConnection = &$this->persistentConnection;
+		$proxy->decode_utf8 = $this->decode_utf8;
+		$proxy->curl_options = $this->curl_options;
+		$proxy->bindingType = $this->bindingType;
+		$proxy->use_curl = $this->use_curl;
+		return $proxy;
+	}
+
+	/**
+	* dynamically creates proxy class code
+	*
+	* @return   string PHP/NuSOAP code for the proxy class
+	* @access   private
+	*/
+	function _getProxyClassCode($r) {
+		$this->debug("in getProxy endpointType=$this->endpointType");
+		$this->appendDebug("wsdl=" . $this->varDump($this->wsdl));
+		if ($this->endpointType != 'wsdl') {
+			$evalStr = 'A proxy can only be created for a WSDL client';
+			$this->setError($evalStr);
+			$evalStr = "echo \"$evalStr\";";
+			return $evalStr;
+		}
+		if ($this->endpointType == 'wsdl' && is_null($this->wsdl)) {
+			$this->loadWSDL();
+			if ($this->getError()) {
+				return "echo \"" . $this->getError() . "\";";
+			}
+		}
+		$evalStr = '';
+		foreach ($this->operations as $operation => $opData) {
+			if ($operation != '') {
+				// create param string and param comment string
+				if (sizeof($opData['input']['parts']) > 0) {
+					$paramStr = '';
+					$paramArrayStr = '';
+					$paramCommentStr = '';
+					foreach ($opData['input']['parts'] as $name => $type) {
+						$paramStr .= "\$$name, ";
+						$paramArrayStr .= "'$name' => \$$name, ";
+						$paramCommentStr .= "$type \$$name, ";
+					}
+					$paramStr = substr($paramStr, 0, strlen($paramStr)-2);
+					$paramArrayStr = substr($paramArrayStr, 0, strlen($paramArrayStr)-2);
+					$paramCommentStr = substr($paramCommentStr, 0, strlen($paramCommentStr)-2);
+				} else {
+					$paramStr = '';
+					$paramArrayStr = '';
+					$paramCommentStr = 'void';
+				}
+				$opData['namespace'] = !isset($opData['namespace']) ? 'http://testuri.com' : $opData['namespace'];
+				$evalStr .= "// $paramCommentStr
+	function " . str_replace('.', '__', $operation) . "($paramStr) {
+		\$params = array($paramArrayStr);
+		return \$this->call('$operation', \$params, '".$opData['namespace']."', '".(isset($opData['soapAction']) ? $opData['soapAction'] : '')."');
+	}
+	";
+				unset($paramStr);
+				unset($paramCommentStr);
+			}
+		}
+		$evalStr = 'class nusoap_proxy_'.$r.' extends nusoap_client {
+	'.$evalStr.'
+}';
+		return $evalStr;
+	}
+
+	/**
+	* dynamically creates proxy class code
+	*
+	* @return   string PHP/NuSOAP code for the proxy class
+	* @access   public
+	*/
+	function getProxyClassCode() {
+		$r = rand();
+		return $this->_getProxyClassCode($r);
+	}
+
+	/**
+	* gets the HTTP body for the current request.
+	*
+	* @param string $soapmsg The SOAP payload
+	* @return string The HTTP body, which includes the SOAP payload
+	* @access private
+	*/
+	function getHTTPBody($soapmsg) {
+		return $soapmsg;
+	}
+	
+	/**
+	* gets the HTTP content type for the current request.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type for the current request.
+	* @access private
+	*/
+	function getHTTPContentType() {
+		return 'text/xml';
+	}
+	
+	/**
+	* gets the HTTP content type charset for the current request.
+	* returns false for non-text content types.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type charset for the current request.
+	* @access private
+	*/
+	function getHTTPContentTypeCharset() {
+		return $this->soap_defencoding;
+	}
+
+	/*
+	* whether or not parser should decode utf8 element content
+    *
+    * @return   always returns true
+    * @access   public
+    */
+    function decodeUTF8($bool){
+		$this->decode_utf8 = $bool;
+		return true;
+    }
+
+	/**
+	 * adds a new Cookie into $this->cookies array
+	 *
+	 * @param	string $name Cookie Name
+	 * @param	string $value Cookie Value
+	 * @return	boolean if cookie-set was successful returns true, else false
+	 * @access	public
+	 */
+	function setCookie($name, $value) {
+		if (strlen($name) == 0) {
+			return false;
+		}
+		$this->cookies[] = array('name' => $name, 'value' => $value);
+		return true;
+	}
+
+	/**
+	 * gets all Cookies
+	 *
+	 * @return   array with all internal cookies
+	 * @access   public
+	 */
+	function getCookies() {
+		return $this->cookies;
+	}
+
+	/**
+	 * checks all Cookies and delete those which are expired
+	 *
+	 * @return   boolean always return true
+	 * @access   private
+	 */
+	function checkCookies() {
+		if (sizeof($this->cookies) == 0) {
+			return true;
+		}
+		$this->debug('checkCookie: check ' . sizeof($this->cookies) . ' cookies');
+		$curr_cookies = $this->cookies;
+		$this->cookies = array();
+		foreach ($curr_cookies as $cookie) {
+			if (! is_array($cookie)) {
+				$this->debug('Remove cookie that is not an array');
+				continue;
+			}
+			if ((isset($cookie['expires'])) && (! empty($cookie['expires']))) {
+				if (strtotime($cookie['expires']) > time()) {
+					$this->cookies[] = $cookie;
+				} else {
+					$this->debug('Remove expired cookie ' . $cookie['name']);
+				}
+			} else {
+				$this->cookies[] = $cookie;
+			}
+		}
+		$this->debug('checkCookie: '.sizeof($this->cookies).' cookies left in array');
+		return true;
+	}
+
+	/**
+	 * updates the current cookies with a new set
+	 *
+	 * @param	array $cookies new cookies with which to update current ones
+	 * @return	boolean always return true
+	 * @access	private
+	 */
+	function UpdateCookies($cookies) {
+		if (sizeof($this->cookies) == 0) {
+			// no existing cookies: take whatever is new
+			if (sizeof($cookies) > 0) {
+				$this->debug('Setting new cookie(s)');
+				$this->cookies = $cookies;
+			}
+			return true;
+		}
+		if (sizeof($cookies) == 0) {
+			// no new cookies: keep what we've got
+			return true;
+		}
+		// merge
+		foreach ($cookies as $newCookie) {
+			if (!is_array($newCookie)) {
+				continue;
+			}
+			if ((!isset($newCookie['name'])) || (!isset($newCookie['value']))) {
+				continue;
+			}
+			$newName = $newCookie['name'];
+
+			$found = false;
+			for ($i = 0; $i < count($this->cookies); $i++) {
+				$cookie = $this->cookies[$i];
+				if (!is_array($cookie)) {
+					continue;
+				}
+				if (!isset($cookie['name'])) {
+					continue;
+				}
+				if ($newName != $cookie['name']) {
+					continue;
+				}
+				$newDomain = isset($newCookie['domain']) ? $newCookie['domain'] : 'NODOMAIN';
+				$domain = isset($cookie['domain']) ? $cookie['domain'] : 'NODOMAIN';
+				if ($newDomain != $domain) {
+					continue;
+				}
+				$newPath = isset($newCookie['path']) ? $newCookie['path'] : 'NOPATH';
+				$path = isset($cookie['path']) ? $cookie['path'] : 'NOPATH';
+				if ($newPath != $path) {
+					continue;
+				}
+				$this->cookies[$i] = $newCookie;
+				$found = true;
+				$this->debug('Update cookie ' . $newName . '=' . $newCookie['value']);
+				break;
+			}
+			if (! $found) {
+				$this->debug('Add cookie ' . $newName . '=' . $newCookie['value']);
+				$this->cookies[] = $newCookie;
+			}
+		}
+		return true;
+	}
+}
+
+if (!extension_loaded('soap')) {
+	/**
+	 *	For backwards compatiblity, define soapclient unless the PHP SOAP extension is loaded.
+	 */
+	class soapclient extends nusoap_client {
+	}
+}
+?>
diff -rNU5 spip-ori/ecrire/nusoap/readme_mantis.txt spip/ecrire/nusoap/readme_mantis.txt
--- spip-ori/ecrire/nusoap/readme_mantis.txt	1970-01-01 01:00:00.000000000 +0100
+++ spip/ecrire/nusoap/readme_mantis.txt	2013-04-05 11:06:41.165923140 +0200
@@ -0,0 +1,13 @@
+Description of nusoap import into mantis.
+
+See ../readme.libs for summary of all libraries
+
+Removed:
+
+Added:
+	readme_mantis.txt - this file ;-)
+	index.html - prevent directory browsing on misconfigured servers
+
+Changes:
+	none
+
diff -rNU5 spip-ori/ecrire/public.php spip/ecrire/public.php
--- spip-ori/ecrire/public.php	2011-04-06 22:30:57.000000000 +0200
+++ spip/ecrire/public.php	2013-04-05 11:06:41.165923140 +0200
@@ -257,7 +257,6 @@
 	if (($GLOBALS['meta']["activer_statistiques"] != "non")
 	AND $spip_compter_visites!='non'
 	AND $stats = charger_fonction('stats', 'public', true))
 		$stats();
 }
-
 ?>
diff -rNU5 spip-ori/extensions/cicas/action/logout.php spip/extensions/cicas/action/logout.php
--- spip-ori/extensions/cicas/action/logout.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/action/logout.php	2013-04-05 11:06:41.165923140 +0200
@@ -0,0 +1,113 @@
+<?php
+/**
+ * Plugin Authentification CAS
+ * Copyright (c) Christophe IMBERTI
+ * Licence Creative commons by-nc-sa
+ */
+
+if (!defined('_ECRIRE_INC_VERSION')) return;
+
+include_spip('inc/cookie');
+
+// http://doc.spip.org/@action_logout_dist
+function action_logout_dist()
+{
+	global $visiteur_session, $ignore_auth_http;
+	$logout =_request('logout');
+	$url = _request('url');
+	// cas particulier, logout dans l'espace public
+	if ($logout == 'public' AND !$url)
+		$url = url_de_base();
+
+//------- Debut ajout CI -----
+	include_spip('inc/cicas_commun');
+	
+	// lire la configuration du plugin
+	cicas_lire_meta();
+	
+	$ciauthcas= false;
+	if ($GLOBALS['ciconfig']['cicas']=="oui" OR isset($_COOKIE['cicas_sso'])) {
+		if ($GLOBALS['ciconfig']['cicasurldefaut'])
+			$ciauthcas= true;
+	}
+//------- Fin ajout CI -----
+
+	// seul le loge peut se deloger (mais id_auteur peut valoir 0 apres une restauration avortee)
+	if (is_numeric($visiteur_session['id_auteur'])) {
+		include_spip('inc/auth');
+		auth_trace($visiteur_session, '0000-00-00 00:00:00');
+	// le logout explicite vaut destruction de toutes les sessions
+		if (isset($_COOKIE['spip_session'])) {
+			$session = charger_fonction('session', 'inc');
+			$session($visiteur_session['id_auteur']);
+			spip_setcookie('spip_session', $_COOKIE['spip_session'], time()-3600);
+		}
+		// si authentification http, et que la personne est loge,
+		// pour se deconnecter, il faut proposer un nouveau formulaire de connexion http
+		if (isset($_SERVER['PHP_AUTH_USER']) AND !$ignore_auth_http AND $GLOBALS['auth_can_disconnect']) {
+			  ask_php_auth(_T('login_deconnexion_ok'),
+				       _T('login_verifiez_navigateur'),
+				       _T('login_retour_public'),
+				       	"redirect=". _DIR_RESTREINT_ABS, 
+				       _T('login_test_navigateur'),
+				       true);
+			
+		}
+//------- Debut ajout CI -----
+		if ($ciauthcas) {
+	
+			include_spip('inc/cicas_commun');
+			// import phpCAS lib
+			include_spip('CAS');
+
+			// Pour la solution hybride utilisation d'un cookie
+			if(isset($_COOKIE['cicas_sso']))
+				spip_setcookie('cicas_sso', '', time() - 3600);
+			
+			// D�terminer l'origine de l'appel (intranet, internet, ...)
+			// .i2 ou .ader.gouv.fr ou .gouv.fr ou .agri
+			$ciurlcas=cicas_url_serveur_cas();	
+		
+			// initialize phpCAS
+			$cirep='';
+			$ciport=intval($GLOBALS['ciconfig']['cicasport']);
+			if (isset($GLOBALS['ciconfig']['cicasrepertoire'])) $cirep=$GLOBALS['ciconfig']['cicasrepertoire'];
+			
+			phpCAS::client(CAS_VERSION_2_0,$ciurlcas,$ciport,$cirep);
+			
+			phpCAS::setLang(cicas_lang_phpcas($_GET['lang']));
+	
+			// D�terminer l'url retour
+			$ci_url_retour = cicas_url_retour($url);
+			
+			// deconnexion de CAS avec l'url retour	
+/*			
+			if (method_exists('phpCAS','logoutWithUrl')) {
+				// Compatibilit� avec les versions r�centes de phpCAS
+				phpCAS::logoutWithUrl(urlencode($ci_url_retour));
+			} else {
+				phpCAS::logout(urlencode($ci_url_retour));
+			}
+*/
+//			phpCAS::logoutWithUrl(urlencode($ci_url_retour));
+			phpCAS::logoutWithRedirectService($ci_url_retour);
+			
+		}
+//------- Fin ajout CI -----
+		
+	}
+
+//------- Debut ajout CI -----
+	if (!$ciauthcas) {
+//------- Fin ajout CI -----
+		// Rediriger en contrant le cache navigateur (Safari3)
+		include_spip('inc/headers');
+		redirige_par_entete($url
+			? parametre_url($url, 'var_hasard', uniqid(rand()), '&')
+			: generer_url_public('login'));
+//------- Debut ajout CI -----
+	}
+//------- Fin ajout CI -----
+}
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/CAS/AuthenticationException.php spip/extensions/cicas/CAS/AuthenticationException.php
--- spip-ori/extensions/cicas/CAS/AuthenticationException.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/AuthenticationException.php	2013-04-05 11:06:41.165923140 +0200
@@ -0,0 +1,107 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/AuthenticationException.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Joachim Fritschi <jfritschi@freenet.de>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * This interface defines methods that allow proxy-authenticated service handlers
+ * to interact with phpCAS.
+ *
+ * Proxy service handlers must implement this interface as well as call
+ * phpCAS::initializeProxiedService($this) at some point in their implementation.
+ *
+ * While not required, proxy-authenticated service handlers are encouraged to
+ * implement the CAS_ProxiedService_Testable interface to facilitate unit testing.
+ *
+ * @class    CAS_AuthenticationException
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Joachim Fritschi <jfritschi@freenet.de>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+class CAS_AuthenticationException
+extends RuntimeException
+implements CAS_Exception
+{
+
+    /**
+     * This method is used to print the HTML output when the user was not
+     * authenticated.
+     *
+     * @param CAS_Client $client       phpcas client
+     * @param string     $failure      the failure that occured
+     * @param string     $cas_url      the URL the CAS server was asked for
+     * @param bool       $no_response  the response from the CAS server (other
+     * parameters are ignored if TRUE)
+     * @param bool       $bad_response bad response from the CAS server ($err_code
+     * and $err_msg ignored if TRUE)
+     * @param string     $cas_response the response of the CAS server
+     * @param int        $err_code     the error code given by the CAS server
+     * @param string     $err_msg      the error message given by the CAS server
+     */
+    public function __construct($client,$failure,$cas_url,$no_response,
+        $bad_response='',$cas_response='',$err_code='',$err_msg=''
+    ) {
+        phpCAS::traceBegin();
+        $lang = $client->getLangObj();
+        $client->printHTMLHeader($lang->getAuthenticationFailed());
+        printf(
+            $lang->getYouWereNotAuthenticated(),
+            htmlentities($client->getURL()),
+            $_SERVER['SERVER_ADMIN']
+        );
+        phpCAS::trace('CAS URL: '.$cas_url);
+        phpCAS::trace('Authentication failure: '.$failure);
+        if ( $no_response ) {
+            phpCAS::trace('Reason: no response from the CAS server');
+        } else {
+            if ( $bad_response ) {
+                phpCAS::trace('Reason: bad response from the CAS server');
+            } else {
+                switch ($client->getServerVersion()) {
+                case CAS_VERSION_1_0:
+                    phpCAS::trace('Reason: CAS error');
+                    break;
+                case CAS_VERSION_2_0:
+                    if ( empty($err_code) ) {
+                        phpCAS::trace('Reason: no CAS error');
+                    } else {
+                        phpCAS::trace('Reason: ['.$err_code.'] CAS error: '.$err_msg);
+                    }
+                    break;
+                }
+            }
+            phpCAS::trace('CAS response: '.$cas_response);
+        }
+        $client->printHTMLFooter();
+        phpCAS::traceExit();
+    }
+
+}
+?>
diff -rNU5 spip-ori/extensions/cicas/CAS/Autoload.php spip/extensions/cicas/CAS/Autoload.php
--- spip-ori/extensions/cicas/CAS/Autoload.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Autoload.php	2013-04-05 11:06:41.165923140 +0200
@@ -0,0 +1,104 @@
+<?php
+
+/**
+ * Autoloader Class
+ *
+ *  PHP Version 5
+ *
+ * @file      CAS/Autoload.php
+ * @category  Authentication
+ * @package   SimpleCAS
+ * @author    Brett Bieber <brett.bieber@gmail.com>
+ * @copyright 2008 Regents of the University of Nebraska
+ * @license   http://www1.unl.edu/wdn/wiki/Software_License BSD License
+ * @link      http://code.google.com/p/simplecas/
+ **/
+
+/**
+ * Autoload a class
+ *
+ * @param string $class Classname to load
+ *
+ * @return bool
+ */
+function CAS_autoload($class)
+{
+    if (substr($class, 0, 4) !== 'CAS_') {
+        return false;
+    }
+    $fp = @fopen(str_replace('_', '/', $class) . '.php', 'r', true);
+    if ($fp) {
+        fclose($fp);
+        include str_replace('_', '/', $class) . '.php';
+        if (!class_exists($class, false) && !interface_exists($class, false)) {
+            die(
+                new Exception(
+                    'Class ' . $class . ' was not present in ' .
+                    str_replace('_', '/', $class) . '.php (include_path="' .
+                    get_include_path() .'") [CAS_autoload]'
+                )
+            );
+        }
+        return true;
+    }
+    $e = new Exception(
+        'Class ' . $class . ' could not be loaded from ' .
+        str_replace('_', '/', $class) . '.php, file does not exist (include_path="'
+        . get_include_path() .'") [CAS_autoload]'
+    );
+    $trace = $e->getTrace();
+    if (isset($trace[2]) && isset($trace[2]['function'])
+        && in_array($trace[2]['function'], array('class_exists', 'interface_exists'))
+    ) {
+        return false;
+    }
+    if (isset($trace[1]) && isset($trace[1]['function'])
+        && in_array($trace[1]['function'], array('class_exists', 'interface_exists'))
+    ) {
+        return false;
+    }
+    die ((string) $e);
+}
+
+// set up __autoload
+if (function_exists('spl_autoload_register')) {
+    if (!(spl_autoload_functions()) || !in_array('CAS_autoload', spl_autoload_functions())) {
+        spl_autoload_register('CAS_autoload');
+        if (function_exists('__autoload') && !in_array('__autoload', spl_autoload_functions())) {
+            // __autoload() was being used, but now would be ignored, add
+            // it to the autoload stack
+            spl_autoload_register('__autoload');
+        }
+    }
+} elseif (!function_exists('__autoload')) {
+
+    /**
+     * Autoload a class
+     *
+     * @param string $class Class name
+     *
+     * @return bool
+     */
+    function __autoload($class)
+    {
+        return CAS_autoload($class);
+    }
+}
+
+// set up include_path if it doesn't register our current location
+$____paths = explode(PATH_SEPARATOR, get_include_path());
+$____found = false;
+foreach ($____paths as $____path) {
+    if ($____path == dirname(dirname(__FILE__))) {
+        $____found = true;
+        break;
+    }
+}
+if (!$____found) {
+    set_include_path(dirname(dirname(__FILE__)) . PATH_SEPARATOR . get_include_path());
+}
+unset($____paths);
+unset($____path);
+unset($____found);
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/CAS/Client.php spip/extensions/cicas/CAS/Client.php
--- spip-ori/extensions/cicas/CAS/Client.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Client.php	2013-04-05 11:06:41.169923140 +0200
@@ -0,0 +1,3389 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Client.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Pascal Aubry <pascal.aubry@univ-rennes1.fr>
+ * @author   Olivier Berger <olivier.berger@it-sudparis.eu>
+ * @author   Brett Bieber <brett.bieber@gmail.com>
+ * @author   Joachim Fritschi <jfritschi@freenet.de>
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * The CAS_Client class is a client interface that provides CAS authentication
+ * to PHP applications.
+ *
+ * @class    CAS_Client
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Pascal Aubry <pascal.aubry@univ-rennes1.fr>
+ * @author   Olivier Berger <olivier.berger@it-sudparis.eu>
+ * @author   Brett Bieber <brett.bieber@gmail.com>
+ * @author   Joachim Fritschi <jfritschi@freenet.de>
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ *
+ */
+
+class CAS_Client
+{
+
+    // ########################################################################
+    //  HTML OUTPUT
+    // ########################################################################
+    /**
+    * @addtogroup internalOutput
+    * @{
+    */
+
+    /**
+     * This method filters a string by replacing special tokens by appropriate values
+     * and prints it. The corresponding tokens are taken into account:
+     * - __CAS_VERSION__
+     * - __PHPCAS_VERSION__
+     * - __SERVER_BASE_URL__
+     *
+     * Used by CAS_Client::PrintHTMLHeader() and CAS_Client::printHTMLFooter().
+     *
+     * @param string $str the string to filter and output
+     *
+     * @return void
+     */
+    private function _htmlFilterOutput($str)
+    {
+        $str = str_replace('__CAS_VERSION__', $this->getServerVersion(), $str);
+        $str = str_replace('__PHPCAS_VERSION__', phpCAS::getVersion(), $str);
+        $str = str_replace('__SERVER_BASE_URL__', $this->_getServerBaseURL(), $str);
+        echo $str;
+    }
+
+    /**
+     * A string used to print the header of HTML pages. Written by
+     * CAS_Client::setHTMLHeader(), read by CAS_Client::printHTMLHeader().
+     *
+     * @hideinitializer
+     * @see CAS_Client::setHTMLHeader, CAS_Client::printHTMLHeader()
+     */
+    private $_output_header = '';
+
+    /**
+     * This method prints the header of the HTML output (after filtering). If
+     * CAS_Client::setHTMLHeader() was not used, a default header is output.
+     *
+     * @param string $title the title of the page
+     *
+     * @return void
+     * @see _htmlFilterOutput()
+     */
+    public function printHTMLHeader($title)
+    {
+        $this->_htmlFilterOutput(
+            str_replace(
+                '__TITLE__', $title,
+                (empty($this->_output_header)
+                ? '<html><head><title>__TITLE__</title></head><body><h1>__TITLE__</h1>'
+                : $this->_output_header)
+            )
+        );
+    }
+
+    /**
+     * A string used to print the footer of HTML pages. Written by
+     * CAS_Client::setHTMLFooter(), read by printHTMLFooter().
+     *
+     * @hideinitializer
+     * @see CAS_Client::setHTMLFooter, CAS_Client::printHTMLFooter()
+     */
+    private $_output_footer = '';
+
+    /**
+     * This method prints the footer of the HTML output (after filtering). If
+     * CAS_Client::setHTMLFooter() was not used, a default footer is output.
+     *
+     * @return void
+     * @see _htmlFilterOutput()
+     */
+    public function printHTMLFooter()
+    {
+        $lang = $this->getLangObj();
+        $this->_htmlFilterOutput(
+            empty($this->_output_footer)?
+            ('<hr><address>phpCAS __PHPCAS_VERSION__ '
+            .$lang->getUsingServer()
+            .' <a href="__SERVER_BASE_URL__">__SERVER_BASE_URL__</a> (CAS __CAS_VERSION__)</a></address></body></html>')
+            :$this->_output_footer
+        );
+    }
+
+    /**
+     * This method set the HTML header used for all outputs.
+     *
+     * @param string $header the HTML header.
+     *
+     * @return void
+     */
+    public function setHTMLHeader($header)
+    {
+        $this->_output_header = $header;
+    }
+
+    /**
+     * This method set the HTML footer used for all outputs.
+     *
+     * @param string $footer the HTML footer.
+     *
+     * @return void
+     */
+    public function setHTMLFooter($footer)
+    {
+        $this->_output_footer = $footer;
+    }
+
+
+    /** @} */
+
+
+    // ########################################################################
+    //  INTERNATIONALIZATION
+    // ########################################################################
+    /**
+    * @addtogroup internalLang
+    * @{
+    */
+    /**
+     * A string corresponding to the language used by phpCAS. Written by
+     * CAS_Client::setLang(), read by CAS_Client::getLang().
+
+     * @note debugging information is always in english (debug purposes only).
+     */
+    private $_lang = PHPCAS_LANG_DEFAULT;
+
+    /**
+     * This method is used to set the language used by phpCAS.
+     *
+     * @param string $lang representing the language.
+     *
+     * @return void
+     */
+    public function setLang($lang)
+    {
+        $obj = new $lang();
+        if (!($obj instanceof CAS_Languages_LanguageInterface)) {
+            throw new CAS_InvalidArgumentException('$className must implement the CAS_Languages_LanguageInterface');
+        }
+        $this->_lang = $lang;
+    }
+    /**
+     * Create the language
+     *
+     * @return CAS_Languages_LanguageInterface object implementing the class
+     */
+    public function getLangObj()
+    {
+        $classname = $this->_lang;
+        return new $classname();
+    }
+
+    /** @} */
+    // ########################################################################
+    //  CAS SERVER CONFIG
+    // ########################################################################
+    /**
+    * @addtogroup internalConfig
+    * @{
+    */
+
+    /**
+     * a record to store information about the CAS server.
+     * - $_server['version']: the version of the CAS server
+     * - $_server['hostname']: the hostname of the CAS server
+     * - $_server['port']: the port the CAS server is running on
+     * - $_server['uri']: the base URI the CAS server is responding on
+     * - $_server['base_url']: the base URL of the CAS server
+     * - $_server['login_url']: the login URL of the CAS server
+     * - $_server['service_validate_url']: the service validating URL of the
+     *   CAS server
+     * - $_server['proxy_url']: the proxy URL of the CAS server
+     * - $_server['proxy_validate_url']: the proxy validating URL of the CAS server
+     * - $_server['logout_url']: the logout URL of the CAS server
+     *
+     * $_server['version'], $_server['hostname'], $_server['port'] and
+     * $_server['uri'] are written by CAS_Client::CAS_Client(), read by
+     * CAS_Client::getServerVersion(), CAS_Client::_getServerHostname(),
+     * CAS_Client::_getServerPort() and CAS_Client::_getServerURI().
+     *
+     * The other fields are written and read by CAS_Client::_getServerBaseURL(),
+     * CAS_Client::getServerLoginURL(), CAS_Client::getServerServiceValidateURL(),
+     * CAS_Client::getServerProxyValidateURL() and CAS_Client::getServerLogoutURL().
+     *
+     * @hideinitializer
+     */
+    private $_server = array(
+        'version' => -1,
+        'hostname' => 'none',
+        'port' => -1,
+        'uri' => 'none');
+
+    /**
+     * This method is used to retrieve the version of the CAS server.
+     *
+     * @return string the version of the CAS server.
+     */
+    public function getServerVersion()
+    {
+        return $this->_server['version'];
+    }
+
+    /**
+     * This method is used to retrieve the hostname of the CAS server.
+     *
+     * @return string the hostname of the CAS server.
+     */
+    private function _getServerHostname()
+    {
+        return $this->_server['hostname'];
+    }
+
+    /**
+     * This method is used to retrieve the port of the CAS server.
+     *
+     * @return string the port of the CAS server.
+     */
+    private function _getServerPort()
+    {
+        return $this->_server['port'];
+    }
+
+    /**
+     * This method is used to retrieve the URI of the CAS server.
+     *
+     * @return string a URI.
+     */
+    private function _getServerURI()
+    {
+        return $this->_server['uri'];
+    }
+
+    /**
+     * This method is used to retrieve the base URL of the CAS server.
+     *
+     * @return string a URL.
+     */
+    private function _getServerBaseURL()
+    {
+        // the URL is build only when needed
+        if ( empty($this->_server['base_url']) ) {
+            $this->_server['base_url'] = 'https://' . $this->_getServerHostname();
+            if ($this->_getServerPort()!=443) {
+                $this->_server['base_url'] .= ':'
+                .$this->_getServerPort();
+            }
+            $this->_server['base_url'] .= $this->_getServerURI();
+        }
+        return $this->_server['base_url'];
+    }
+
+    /**
+     * This method is used to retrieve the login URL of the CAS server.
+     *
+     * @param bool $gateway true to check authentication, false to force it
+     * @param bool $renew   true to force the authentication with the CAS server
+     *
+     * @return a URL.
+     * @note It is recommended that CAS implementations ignore the "gateway"
+     * parameter if "renew" is set
+     */
+    public function getServerLoginURL($gateway=false,$renew=false)
+    {
+        phpCAS::traceBegin();
+        // the URL is build only when needed
+        if ( empty($this->_server['login_url']) ) {
+            $this->_server['login_url'] = $this->_getServerBaseURL();
+            $this->_server['login_url'] .= 'login?service=';
+            $this->_server['login_url'] .= urlencode($this->getURL());
+        }
+        $url = $this->_server['login_url'];
+        if ($renew) {
+            // It is recommended that when the "renew" parameter is set, its
+            // value be "true"
+            $url = $this->_buildQueryUrl($url, 'renew=true');
+        } elseif ($gateway) {
+            // It is recommended that when the "gateway" parameter is set, its
+            // value be "true"
+            $url = $this->_buildQueryUrl($url, 'gateway=true');
+        }
+        phpCAS::traceEnd($url);
+        return $url;
+    }
+
+    /**
+     * This method sets the login URL of the CAS server.
+     *
+     * @param string $url the login URL
+     *
+     * @return string login url
+     */
+    public function setServerLoginURL($url)
+    {
+        return $this->_server['login_url'] = $url;
+    }
+
+
+    /**
+     * This method sets the serviceValidate URL of the CAS server.
+     *
+     * @param string $url the serviceValidate URL
+     *
+     * @return string serviceValidate URL
+     */
+    public function setServerServiceValidateURL($url)
+    {
+        return $this->_server['service_validate_url'] = $url;
+    }
+
+
+    /**
+     * This method sets the proxyValidate URL of the CAS server.
+     *
+     * @param string $url the proxyValidate URL
+     *
+     * @return string proxyValidate URL
+     */
+    public function setServerProxyValidateURL($url)
+    {
+        return $this->_server['proxy_validate_url'] = $url;
+    }
+
+
+    /**
+     * This method sets the samlValidate URL of the CAS server.
+     *
+     * @param string $url the samlValidate URL
+     *
+     * @return string samlValidate URL
+     */
+    public function setServerSamlValidateURL($url)
+    {
+        return $this->_server['saml_validate_url'] = $url;
+    }
+
+
+    /**
+     * This method is used to retrieve the service validating URL of the CAS server.
+     *
+     * @return string serviceValidate URL.
+     */
+    public function getServerServiceValidateURL()
+    {
+        phpCAS::traceBegin();
+        // the URL is build only when needed
+        if ( empty($this->_server['service_validate_url']) ) {
+            switch ($this->getServerVersion()) {
+            case CAS_VERSION_1_0:
+                $this->_server['service_validate_url'] = $this->_getServerBaseURL()
+                .'validate';
+                break;
+            case CAS_VERSION_2_0:
+                $this->_server['service_validate_url'] = $this->_getServerBaseURL()
+                .'serviceValidate';
+                break;
+            }
+        }
+        $url = $this->_buildQueryUrl($this->_server['service_validate_url'], 'service='.urlencode($this->getURL()));
+        phpCAS::traceEnd($url);
+        return $url;
+    }
+    /**
+     * This method is used to retrieve the SAML validating URL of the CAS server.
+     *
+     * @return string samlValidate URL.
+     */
+    public function getServerSamlValidateURL()
+    {
+        phpCAS::traceBegin();
+        // the URL is build only when needed
+        if ( empty($this->_server['saml_validate_url']) ) {
+            switch ($this->getServerVersion()) {
+            case SAML_VERSION_1_1:
+                $this->_server['saml_validate_url'] = $this->_getServerBaseURL().'samlValidate';
+                break;
+            }
+        }
+
+        $url = $this->_buildQueryUrl($this->_server['saml_validate_url'], 'TARGET='.urlencode($this->getURL()));
+        phpCAS::traceEnd($url);
+        return $url;
+    }
+
+    /**
+     * This method is used to retrieve the proxy validating URL of the CAS server.
+     *
+     * @return string proxyValidate URL.
+     */
+    public function getServerProxyValidateURL()
+    {
+        phpCAS::traceBegin();
+        // the URL is build only when needed
+        if ( empty($this->_server['proxy_validate_url']) ) {
+            switch ($this->getServerVersion()) {
+            case CAS_VERSION_1_0:
+                $this->_server['proxy_validate_url'] = '';
+                break;
+            case CAS_VERSION_2_0:
+                $this->_server['proxy_validate_url'] = $this->_getServerBaseURL().'proxyValidate';
+                break;
+            }
+        }
+        $url = $this->_buildQueryUrl($this->_server['proxy_validate_url'], 'service='.urlencode($this->getURL()));
+        phpCAS::traceEnd($url);
+        return $url;
+    }
+
+
+    /**
+     * This method is used to retrieve the proxy URL of the CAS server.
+     *
+     * @return  string proxy URL.
+     */
+    public function getServerProxyURL()
+    {
+        // the URL is build only when needed
+        if ( empty($this->_server['proxy_url']) ) {
+            switch ($this->getServerVersion()) {
+            case CAS_VERSION_1_0:
+                $this->_server['proxy_url'] = '';
+                break;
+            case CAS_VERSION_2_0:
+                $this->_server['proxy_url'] = $this->_getServerBaseURL().'proxy';
+                break;
+            }
+        }
+        return $this->_server['proxy_url'];
+    }
+
+    /**
+     * This method is used to retrieve the logout URL of the CAS server.
+     *
+     * @return string logout URL.
+     */
+    public function getServerLogoutURL()
+    {
+        // the URL is build only when needed
+        if ( empty($this->_server['logout_url']) ) {
+            $this->_server['logout_url'] = $this->_getServerBaseURL().'logout';
+        }
+        return $this->_server['logout_url'];
+    }
+
+    /**
+     * This method sets the logout URL of the CAS server.
+     *
+     * @param string $url the logout URL
+     *
+     * @return string logout url
+     */
+    public function setServerLogoutURL($url)
+    {
+        return $this->_server['logout_url'] = $url;
+    }
+
+    /**
+     * An array to store extra curl options.
+     */
+    private $_curl_options = array();
+
+    /**
+     * This method is used to set additional user curl options.
+     *
+     * @param string $key   name of the curl option
+     * @param string $value value of the curl option
+     *
+     * @return void
+     */
+    public function setExtraCurlOption($key, $value)
+    {
+        $this->_curl_options[$key] = $value;
+    }
+
+    /** @} */
+
+    // ########################################################################
+    //  Change the internal behaviour of phpcas
+    // ########################################################################
+
+    /**
+     * @addtogroup internalBehave
+     * @{
+     */
+
+    /**
+     * The class to instantiate for making web requests in readUrl().
+     * The class specified must implement the CAS_Request_RequestInterface.
+     * By default CAS_Request_CurlRequest is used, but this may be overridden to
+     * supply alternate request mechanisms for testing.
+     */
+    private $_requestImplementation = 'CAS_Request_CurlRequest';
+
+    /**
+     * Override the default implementation used to make web requests in readUrl().
+     * This class must implement the CAS_Request_RequestInterface.
+     *
+     * @param string $className name of the RequestImplementation class
+     *
+     * @return void
+     */
+    public function setRequestImplementation ($className)
+    {
+        $obj = new $className;
+        if (!($obj instanceof CAS_Request_RequestInterface)) {
+            throw new CAS_InvalidArgumentException('$className must implement the CAS_Request_RequestInterface');
+        }
+        $this->_requestImplementation = $className;
+    }
+
+    /**
+     * @var boolean $_clearTicketsFromUrl; If true, phpCAS will clear session
+     * tickets from the URL after a successful authentication.
+     */
+    private $_clearTicketsFromUrl = true;
+
+    /**
+     * Configure the client to not send redirect headers and call exit() on
+     * authentication success. The normal redirect is used to remove the service
+     * ticket from the client's URL, but for running unit tests we need to
+     * continue without exiting.
+     *
+     * Needed for testing authentication
+     *
+     * @return void
+     */
+    public function setNoClearTicketsFromUrl ()
+    {
+        $this->_clearTicketsFromUrl = false;
+    }
+
+    /**
+     * @var callback $_postAuthenticateCallbackFunction;
+     */
+    private $_postAuthenticateCallbackFunction = null;
+
+    /**
+     * @var array $_postAuthenticateCallbackArgs;
+     */
+    private $_postAuthenticateCallbackArgs = array();
+
+    /**
+     * Set a callback function to be run when a user authenticates.
+     *
+     * The callback function will be passed a $logoutTicket as its first parameter,
+     * followed by any $additionalArgs you pass. The $logoutTicket parameter is an
+     * opaque string that can be used to map a session-id to the logout request
+     * in order to support single-signout in applications that manage their own
+     * sessions (rather than letting phpCAS start the session).
+     *
+     * phpCAS::forceAuthentication() will always exit and forward client unless
+     * they are already authenticated. To perform an action at the moment the user
+     * logs in (such as registering an account, performing logging, etc), register
+     * a callback function here.
+     *
+     * @param string $function       callback function to call
+     * @param array  $additionalArgs optional array of arguments
+     *
+     * @return void
+     */
+    public function setPostAuthenticateCallback ($function, array $additionalArgs = array())
+    {
+        $this->_postAuthenticateCallbackFunction = $function;
+        $this->_postAuthenticateCallbackArgs = $additionalArgs;
+    }
+
+    /**
+     * @var callback $_signoutCallbackFunction;
+     */
+    private $_signoutCallbackFunction = null;
+
+    /**
+     * @var array $_signoutCallbackArgs;
+     */
+    private $_signoutCallbackArgs = array();
+
+    /**
+     * Set a callback function to be run when a single-signout request is received.
+     *
+     * The callback function will be passed a $logoutTicket as its first parameter,
+     * followed by any $additionalArgs you pass. The $logoutTicket parameter is an
+     * opaque string that can be used to map a session-id to the logout request in
+     * order to support single-signout in applications that manage their own sessions
+     * (rather than letting phpCAS start and destroy the session).
+     *
+     * @param string $function       callback function to call
+     * @param array  $additionalArgs optional array of arguments
+     *
+     * @return void
+     */
+    public function setSingleSignoutCallback ($function, array $additionalArgs = array())
+    {
+        $this->_signoutCallbackFunction = $function;
+        $this->_signoutCallbackArgs = $additionalArgs;
+    }
+
+    // ########################################################################
+    //  Methods for supplying code-flow feedback to integrators.
+    // ########################################################################
+
+    /**
+     * Mark the caller of authentication. This will help client integraters determine
+     * problems with their code flow if they call a function such as getUser() before
+     * authentication has occurred.
+     *
+     * @param bool $auth True if authentication was successful, false otherwise.
+     *
+     * @return null
+     */
+    public function markAuthenticationCall ($auth)
+    {
+        // store where the authentication has been checked and the result
+        $dbg = debug_backtrace();
+        $this->_authentication_caller = array (
+            'file' => $dbg[1]['file'],
+            'line' => $dbg[1]['line'],
+            'method' => $dbg[1]['class'] . '::' . $dbg[1]['function'],
+            'result' => (boolean)$auth
+        );
+    }
+    private $_authentication_caller;
+
+    /**
+     * Answer true if authentication has been checked.
+     *
+     * @return bool
+     */
+    public function wasAuthenticationCalled ()
+    {
+        return !empty($this->_authentication_caller);
+    }
+
+    /**
+     * Answer the result of the authentication call.
+     *
+     * Throws a CAS_OutOfSequenceException if wasAuthenticationCalled() is false
+     * and markAuthenticationCall() didn't happen.
+     *
+     * @return bool
+     */
+    public function wasAuthenticationCallSuccessful ()
+    {
+        if (empty($this->_authentication_caller)) {
+            throw new CAS_OutOfSequenceException('markAuthenticationCall() hasn\'t happened.');
+        }
+        return $this->_authentication_caller['result'];
+    }
+
+    /**
+     * Answer information about the authentication caller.
+     *
+     * Throws a CAS_OutOfSequenceException if wasAuthenticationCalled() is false
+     * and markAuthenticationCall() didn't happen.
+     *
+     * @return array Keys are 'file', 'line', and 'method'
+     */
+    public function getAuthenticationCallerFile ()
+    {
+        if (empty($this->_authentication_caller)) {
+            throw new CAS_OutOfSequenceException('markAuthenticationCall() hasn\'t happened.');
+        }
+        return $this->_authentication_caller['file'];
+    }
+
+    /**
+     * Answer information about the authentication caller.
+     *
+     * Throws a CAS_OutOfSequenceException if wasAuthenticationCalled() is false
+     * and markAuthenticationCall() didn't happen.
+     *
+     * @return array Keys are 'file', 'line', and 'method'
+     */
+    public function getAuthenticationCallerLine ()
+    {
+        if (empty($this->_authentication_caller)) {
+            throw new CAS_OutOfSequenceException('markAuthenticationCall() hasn\'t happened.');
+        }
+        return $this->_authentication_caller['line'];
+    }
+
+    /**
+     * Answer information about the authentication caller.
+     *
+     * Throws a CAS_OutOfSequenceException if wasAuthenticationCalled() is false
+     * and markAuthenticationCall() didn't happen.
+     *
+     * @return array Keys are 'file', 'line', and 'method'
+     */
+    public function getAuthenticationCallerMethod ()
+    {
+        if (empty($this->_authentication_caller)) {
+            throw new CAS_OutOfSequenceException('markAuthenticationCall() hasn\'t happened.');
+        }
+        return $this->_authentication_caller['method'];
+    }
+
+    /** @} */
+
+    // ########################################################################
+    //  CONSTRUCTOR
+    // ########################################################################
+    /**
+    * @addtogroup internalConfig
+    * @{
+    */
+
+    /**
+     * CAS_Client constructor.
+     *
+     * @param string $server_version  the version of the CAS server
+     * @param bool   $proxy           true if the CAS client is a CAS proxy
+     * @param string $server_hostname the hostname of the CAS server
+     * @param int    $server_port     the port the CAS server is running on
+     * @param string $server_uri      the URI the CAS server is responding on
+     * @param bool   $changeSessionID Allow phpCAS to change the session_id (Single Sign Out/handleLogoutRequests is based on that change)
+     *
+     * @return a newly created CAS_Client object
+     */
+    public function __construct(
+        $server_version,
+        $proxy,
+        $server_hostname,
+        $server_port,
+        $server_uri,
+        $changeSessionID = true
+    ) {
+
+        phpCAS::traceBegin();
+
+        $this->_setChangeSessionID($changeSessionID); // true : allow to change the session_id(), false session_id won't be change and logout won't be handle because of that
+
+        // skip Session Handling for logout requests and if don't want it'
+        if (session_id()=="" && !$this->_isLogoutRequest()) {
+            phpCAS :: trace("Starting a new session");
+            session_start();
+        }
+
+        // are we in proxy mode ?
+        $this->_proxy = $proxy;
+
+        // Make cookie handling available.
+        if ($this->isProxy()) {
+            if (!isset($_SESSION['phpCAS'])) {
+                $_SESSION['phpCAS'] = array();
+            }
+            if (!isset($_SESSION['phpCAS']['service_cookies'])) {
+                $_SESSION['phpCAS']['service_cookies'] = array();
+            }
+            $this->_serviceCookieJar = new CAS_CookieJar($_SESSION['phpCAS']['service_cookies']);
+        }
+
+        //check version
+        switch ($server_version) {
+        case CAS_VERSION_1_0:
+            if ( $this->isProxy() ) {
+                phpCAS::error(
+                    'CAS proxies are not supported in CAS '.$server_version
+                );
+            }
+            break;
+        case CAS_VERSION_2_0:
+            break;
+        case SAML_VERSION_1_1:
+            break;
+        default:
+            phpCAS::error(
+                'this version of CAS (`'.$server_version
+                .'\') is not supported by phpCAS '.phpCAS::getVersion()
+            );
+        }
+        $this->_server['version'] = $server_version;
+
+        // check hostname
+        if ( empty($server_hostname)
+            || !preg_match('/[\.\d\-abcdefghijklmnopqrstuvwxyz]*/', $server_hostname)
+        ) {
+            phpCAS::error('bad CAS server hostname (`'.$server_hostname.'\')');
+        }
+        $this->_server['hostname'] = $server_hostname;
+
+        // check port
+        if ( $server_port == 0
+            || !is_int($server_port)
+        ) {
+            phpCAS::error('bad CAS server port (`'.$server_hostname.'\')');
+        }
+        $this->_server['port'] = $server_port;
+
+        // check URI
+        if ( !preg_match('/[\.\d\-_abcdefghijklmnopqrstuvwxyz\/]*/', $server_uri) ) {
+            phpCAS::error('bad CAS server URI (`'.$server_uri.'\')');
+        }
+        // add leading and trailing `/' and remove doubles
+        $server_uri = preg_replace('/\/\//', '/', '/'.$server_uri.'/');
+        $this->_server['uri'] = $server_uri;
+
+        // set to callback mode if PgtIou and PgtId CGI GET parameters are provided
+        if ( $this->isProxy() ) {
+            $this->_setCallbackMode(!empty($_GET['pgtIou'])&&!empty($_GET['pgtId']));
+        }
+
+        if ( $this->_isCallbackMode() ) {
+            //callback mode: check that phpCAS is secured
+            if ( !$this->_isHttps() ) {
+                phpCAS::error('CAS proxies must be secured to use phpCAS; PGT\'s will not be received from the CAS server');
+            }
+        } else {
+            //normal mode: get ticket and remove it from CGI parameters for
+            // developers
+            $ticket = (isset($_GET['ticket']) ? $_GET['ticket'] : null);
+            if (preg_match('/^[SP]T-/', $ticket) ) {
+                phpCAS::trace('Ticket \''.$ticket.'\' found');
+                $this->setTicket($ticket);
+                unset($_GET['ticket']);
+            } else if ( !empty($ticket) ) {
+                //ill-formed ticket, halt
+                phpCAS::error('ill-formed ticket found in the URL (ticket=`'.htmlentities($ticket).'\')');
+            }
+
+        }
+        phpCAS::traceEnd();
+    }
+
+    /** @} */
+
+    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+    // XX                                                                    XX
+    // XX                           Session Handling                         XX
+    // XX                                                                    XX
+    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+
+    /**
+     * @addtogroup internalConfig
+     * @{
+     */
+
+
+    /**
+     * A variable to whether phpcas will use its own session handling. Default = true
+     * @hideinitializer
+     */
+    private $_change_session_id = true;
+
+    /**
+     * Set a parameter whether to allow phpCas to change session_id
+     *
+     * @param bool $allowed allow phpCas to change session_id
+     *
+     * @return void
+     */
+    private function _setChangeSessionID($allowed)
+    {
+        $this->_change_session_id = $allowed;
+    }
+
+    /**
+     * Get whether phpCas is allowed to change session_id
+     *
+     * @return bool
+     */
+    public function getChangeSessionID()
+    {
+        return $this->_change_session_id;
+    }
+
+    /** @} */
+
+    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+    // XX                                                                    XX
+    // XX                           AUTHENTICATION                           XX
+    // XX                                                                    XX
+    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+
+    /**
+     * @addtogroup internalAuthentication
+     * @{
+     */
+
+    /**
+     * The Authenticated user. Written by CAS_Client::_setUser(), read by
+     * CAS_Client::getUser().
+     *
+     * @hideinitializer
+     */
+    private $_user = '';
+
+    /**
+     * This method sets the CAS user's login name.
+     *
+     * @param string $user the login name of the authenticated user.
+     *
+     * @return void
+     */
+    private function _setUser($user)
+    {
+        $this->_user = $user;
+    }
+
+    /**
+     * This method returns the CAS user's login name.
+     *
+     * @return string the login name of the authenticated user
+     *
+     * @warning should be called only after CAS_Client::forceAuthentication() or
+     * CAS_Client::isAuthenticated(), otherwise halt with an error.
+     */
+    public function getUser()
+    {
+        if ( empty($this->_user) ) {
+            phpCAS::error(
+                'this method should be used only after '.__CLASS__
+                .'::forceAuthentication() or '.__CLASS__.'::isAuthenticated()'
+            );
+        }
+        return $this->_user;
+    }
+
+    /**
+     * The Authenticated users attributes. Written by
+     * CAS_Client::setAttributes(), read by CAS_Client::getAttributes().
+     * @attention client applications should use phpCAS::getAttributes().
+     *
+     * @hideinitializer
+     */
+    private $_attributes = array();
+
+    /**
+     * Set an array of attributes
+     *
+     * @param array $attributes a key value array of attributes
+     *
+     * @return void
+     */
+    public function setAttributes($attributes)
+    {
+        $this->_attributes = $attributes;
+    }
+
+    /**
+     * Get an key values arry of attributes
+     *
+     * @return arry of attributes
+     */
+    public function getAttributes()
+    {
+        if ( empty($this->_user) ) {
+            // if no user is set, there shouldn't be any attributes also...
+            phpCAS::error(
+                'this method should be used only after '.__CLASS__
+                .'::forceAuthentication() or '.__CLASS__.'::isAuthenticated()'
+            );
+        }
+        return $this->_attributes;
+    }
+
+    /**
+     * Check whether attributes are available
+     *
+     * @return bool attributes available
+     */
+    public function hasAttributes()
+    {
+        return !empty($this->_attributes);
+    }
+    /**
+     * Check whether a specific attribute with a name is available
+     *
+     * @param string $key name of attribute
+     *
+     * @return bool is attribute available
+     */
+    public function hasAttribute($key)
+    {
+        return (is_array($this->_attributes)
+            && array_key_exists($key, $this->_attributes));
+    }
+
+    /**
+     * Get a specific attribute by name
+     *
+     * @param string $key name of attribute
+     *
+     * @return string attribute values
+     */
+    public function getAttribute($key)
+    {
+        if ($this->hasAttribute($key)) {
+            return $this->_attributes[$key];
+        }
+    }
+
+    /**
+     * This method is called to renew the authentication of the user
+     * If the user is authenticated, renew the connection
+     * If not, redirect to CAS
+     *
+     * @return  void
+     */
+    public function renewAuthentication()
+    {
+        phpCAS::traceBegin();
+        // Either way, the user is authenticated by CAS
+        if (isset( $_SESSION['phpCAS']['auth_checked'])) {
+            unset($_SESSION['phpCAS']['auth_checked']);
+        }
+        if ( $this->isAuthenticated() ) {
+            phpCAS::trace('user already authenticated; renew');
+            $this->redirectToCas(false, true);
+        } else {
+            $this->redirectToCas();
+        }
+        phpCAS::traceEnd();
+    }
+
+    /**
+     * This method is called to be sure that the user is authenticated. When not
+     * authenticated, halt by redirecting to the CAS server; otherwise return true.
+     *
+     * @return true when the user is authenticated; otherwise halt.
+     */
+    public function forceAuthentication()
+    {
+        phpCAS::traceBegin();
+
+        if ( $this->isAuthenticated() ) {
+            // the user is authenticated, nothing to be done.
+            phpCAS::trace('no need to authenticate');
+            $res = true;
+        } else {
+            // the user is not authenticated, redirect to the CAS server
+            if (isset($_SESSION['phpCAS']['auth_checked'])) {
+                unset($_SESSION['phpCAS']['auth_checked']);
+            }
+            $this->redirectToCas(false/* no gateway */);
+            // never reached
+            $res = false;
+        }
+        phpCAS::traceEnd($res);
+        return $res;
+    }
+
+    /**
+     * An integer that gives the number of times authentication will be cached
+     * before rechecked.
+     *
+     * @hideinitializer
+     */
+    private $_cache_times_for_auth_recheck = 0;
+
+    /**
+     * Set the number of times authentication will be cached before rechecked.
+     *
+     * @param int $n number of times to wait for a recheck
+     *
+     * @return void
+     */
+    public function setCacheTimesForAuthRecheck($n)
+    {
+        $this->_cache_times_for_auth_recheck = $n;
+    }
+
+    /**
+     * This method is called to check whether the user is authenticated or not.
+     *
+     * @return true when the user is authenticated, false when a previous
+     * gateway login failed or  the function will not return if the user is
+     * redirected to the cas server for a gateway login attempt
+     */
+    public function checkAuthentication()
+    {
+        phpCAS::traceBegin();
+        $res = false;
+        if ( $this->isAuthenticated() ) {
+            phpCAS::trace('user is authenticated');
+            /* The 'auth_checked' variable is removed just in case it's set. */
+            unset($_SESSION['phpCAS']['auth_checked']);
+            $res = true;
+        } else if (isset($_SESSION['phpCAS']['auth_checked'])) {
+            // the previous request has redirected the client to the CAS server
+            // with gateway=true
+            unset($_SESSION['phpCAS']['auth_checked']);
+            $res = false;
+        } else {
+            // avoid a check against CAS on every request
+            if (!isset($_SESSION['phpCAS']['unauth_count'])) {
+                $_SESSION['phpCAS']['unauth_count'] = -2; // uninitialized
+            }
+
+            if (($_SESSION['phpCAS']['unauth_count'] != -2
+                && $this->_cache_times_for_auth_recheck == -1)
+                || ($_SESSION['phpCAS']['unauth_count'] >= 0
+                && $_SESSION['phpCAS']['unauth_count'] < $this->_cache_times_for_auth_recheck)
+            ) {
+                $res = false;
+
+                if ($this->_cache_times_for_auth_recheck != -1) {
+                    $_SESSION['phpCAS']['unauth_count']++;
+                    phpCAS::trace(
+                        'user is not authenticated (cached for '
+                        .$_SESSION['phpCAS']['unauth_count'].' times of '
+                        .$this->_cache_times_for_auth_recheck.')'
+                    );
+                } else {
+                    phpCAS::trace('user is not authenticated (cached for until login pressed)');
+                }
+            } else {
+                $_SESSION['phpCAS']['unauth_count'] = 0;
+                $_SESSION['phpCAS']['auth_checked'] = true;
+                phpCAS::trace('user is not authenticated (cache reset)');
+                $this->redirectToCas(true/* gateway */);
+                // never reached
+                $res = false;
+            }
+        }
+        phpCAS::traceEnd($res);
+        return $res;
+    }
+
+    /**
+     * This method is called to check if the user is authenticated (previously or by
+     * tickets given in the URL).
+     *
+     * @return true when the user is authenticated. Also may redirect to the
+     * same URL without the ticket.
+     */
+    public function isAuthenticated()
+    {
+        phpCAS::traceBegin();
+        $res = false;
+        $validate_url = '';
+        if ( $this->_wasPreviouslyAuthenticated() ) {
+            if ($this->hasTicket()) {
+                // User has a additional ticket but was already authenticated
+                phpCAS::trace('ticket was present and will be discarded, use renewAuthenticate()');
+                if ($this->_clearTicketsFromUrl) {
+                    phpCAS::trace("Prepare redirect to : ".$this->getURL());
+                    header('Location: '.$this->getURL());
+                    flush();
+                    phpCAS::traceExit();
+                    throw new CAS_GracefullTerminationException();
+                } else {
+                    phpCAS::trace('Already authenticated, but skipping ticket clearing since setNoClearTicketsFromUrl() was used.');
+                    $res = true;
+                }
+            } else {
+                // the user has already (previously during the session) been
+                // authenticated, nothing to be done.
+                phpCAS::trace('user was already authenticated, no need to look for tickets');
+                $res = true;
+            }
+        } else {
+            if ($this->hasTicket()) {
+                switch ($this->getServerVersion()) {
+                case CAS_VERSION_1_0:
+                    // if a Service Ticket was given, validate it
+                    phpCAS::trace('CAS 1.0 ticket `'.$this->getTicket().'\' is present');
+                    $this->validateCAS10($validate_url, $text_response, $tree_response); // if it fails, it halts
+                    phpCAS::trace('CAS 1.0 ticket `'.$this->getTicket().'\' was validated');
+                    $_SESSION['phpCAS']['user'] = $this->getUser();
+                    $res = true;
+                    $logoutTicket = $this->getTicket();
+                    break;
+                case CAS_VERSION_2_0:
+                    // if a Proxy Ticket was given, validate it
+                    phpCAS::trace('CAS 2.0 ticket `'.$this->getTicket().'\' is present');
+                    $this->validateCAS20($validate_url, $text_response, $tree_response); // note: if it fails, it halts
+                    phpCAS::trace('CAS 2.0 ticket `'.$this->getTicket().'\' was validated');
+                    if ( $this->isProxy() ) {
+                        $this->_validatePGT($validate_url, $text_response, $tree_response); // idem
+                        phpCAS::trace('PGT `'.$this->_getPGT().'\' was validated');
+                        $_SESSION['phpCAS']['pgt'] = $this->_getPGT();
+                    }
+                    $_SESSION['phpCAS']['user'] = $this->getUser();
+                    if ($this->hasAttributes()) {
+                        $_SESSION['phpCAS']['attributes'] = $this->getAttributes();
+                    }
+                    $proxies = $this->getProxies();
+                    if (!empty($proxies)) {
+                        $_SESSION['phpCAS']['proxies'] = $this->getProxies();
+                    }
+                    $res = true;
+                    $logoutTicket = $this->getTicket();
+                    break;
+                case SAML_VERSION_1_1:
+                    // if we have a SAML ticket, validate it.
+                    phpCAS::trace('SAML 1.1 ticket `'.$this->getTicket().'\' is present');
+                    $this->validateSA($validate_url, $text_response, $tree_response); // if it fails, it halts
+                    phpCAS::trace('SAML 1.1 ticket `'.$this->getTicket().'\' was validated');
+                    $_SESSION['phpCAS']['user'] = $this->getUser();
+                    $_SESSION['phpCAS']['attributes'] = $this->getAttributes();
+                    $res = true;
+                    $logoutTicket = $this->getTicket();
+                    break;
+                default:
+                    phpCAS::trace('Protocoll error');
+                    break;
+                }
+            } else {
+                // no ticket given, not authenticated
+                phpCAS::trace('no ticket found');
+            }
+            if ($res) {
+                // Mark the auth-check as complete to allow post-authentication
+                // callbacks to make use of phpCAS::getUser() and similar methods
+                $this->markAuthenticationCall($res);
+
+                // call the post-authenticate callback if registered.
+                if ($this->_postAuthenticateCallbackFunction) {
+                    $args = $this->_postAuthenticateCallbackArgs;
+                    array_unshift($args, $logoutTicket);
+                    call_user_func_array($this->_postAuthenticateCallbackFunction, $args);
+                }
+
+                // if called with a ticket parameter, we need to redirect to the
+                // app without the ticket so that CAS-ification is transparent
+                // to the browser (for later POSTS) most of the checks and
+                // errors should have been made now, so we're safe for redirect
+                // without masking error messages. remove the ticket as a
+                // security precaution to prevent a ticket in the HTTP_REFERRER
+                if ($this->_clearTicketsFromUrl) {
+                    phpCAS::trace("Prepare redirect to : ".$this->getURL());
+                    header('Location: '.$this->getURL());
+                    flush();
+                    phpCAS::traceExit();
+                    throw new CAS_GracefullTerminationException();
+                }
+            }
+        }
+
+        phpCAS::traceEnd($res);
+        return $res;
+    }
+
+    /**
+     * This method tells if the current session is authenticated.
+     *
+     * @return true if authenticated based soley on $_SESSION variable
+     */
+    public function isSessionAuthenticated ()
+    {
+        return !empty($_SESSION['phpCAS']['user']);
+    }
+
+    /**
+     * This method tells if the user has already been (previously) authenticated
+     * by looking into the session variables.
+     *
+     * @note This function switches to callback mode when needed.
+     *
+     * @return true when the user has already been authenticated; false otherwise.
+     */
+    private function _wasPreviouslyAuthenticated()
+    {
+        phpCAS::traceBegin();
+
+        if ( $this->_isCallbackMode() ) {
+            // Rebroadcast the pgtIou and pgtId to all nodes
+            if ($this->rebroadcast&&!isset($_POST['rebroadcast'])) {
+                $this->_rebroadcast(self::PGTIOU);
+            }
+            $this->_callback();
+        }
+
+        $auth = false;
+
+        if ( $this->isProxy() ) {
+            // CAS proxy: username and PGT must be present
+            if ( $this->isSessionAuthenticated() && !empty($_SESSION['phpCAS']['pgt']) ) {
+                // authentication already done
+                $this->_setUser($_SESSION['phpCAS']['user']);
+                if (isset($_SESSION['phpCAS']['attributes'])) {
+                    $this->setAttributes($_SESSION['phpCAS']['attributes']);
+                }
+                $this->_setPGT($_SESSION['phpCAS']['pgt']);
+                phpCAS::trace('user = `'.$_SESSION['phpCAS']['user'].'\', PGT = `'.$_SESSION['phpCAS']['pgt'].'\'');
+
+                // Include the list of proxies
+                if (isset($_SESSION['phpCAS']['proxies'])) {
+                    $this->_setProxies($_SESSION['phpCAS']['proxies']);
+                    phpCAS::trace('proxies = "'.implode('", "', $_SESSION['phpCAS']['proxies']).'"');
+                }
+
+                $auth = true;
+            } elseif ( $this->isSessionAuthenticated() && empty($_SESSION['phpCAS']['pgt']) ) {
+                // these two variables should be empty or not empty at the same time
+                phpCAS::trace('username found (`'.$_SESSION['phpCAS']['user'].'\') but PGT is empty');
+                // unset all tickets to enforce authentication
+                unset($_SESSION['phpCAS']);
+                $this->setTicket('');
+            } elseif ( !$this->isSessionAuthenticated() && !empty($_SESSION['phpCAS']['pgt']) ) {
+                // these two variables should be empty or not empty at the same time
+                phpCAS::trace('PGT found (`'.$_SESSION['phpCAS']['pgt'].'\') but username is empty');
+                // unset all tickets to enforce authentication
+                unset($_SESSION['phpCAS']);
+                $this->setTicket('');
+            } else {
+                phpCAS::trace('neither user nor PGT found');
+            }
+        } else {
+            // `simple' CAS client (not a proxy): username must be present
+            if ( $this->isSessionAuthenticated() ) {
+                // authentication already done
+                $this->_setUser($_SESSION['phpCAS']['user']);
+                if (isset($_SESSION['phpCAS']['attributes'])) {
+                    $this->setAttributes($_SESSION['phpCAS']['attributes']);
+                }
+                phpCAS::trace('user = `'.$_SESSION['phpCAS']['user'].'\'');
+
+                // Include the list of proxies
+                if (isset($_SESSION['phpCAS']['proxies'])) {
+                    $this->_setProxies($_SESSION['phpCAS']['proxies']);
+                    phpCAS::trace('proxies = "'.implode('", "', $_SESSION['phpCAS']['proxies']).'"');
+                }
+
+                $auth = true;
+            } else {
+                phpCAS::trace('no user found');
+            }
+        }
+
+        phpCAS::traceEnd($auth);
+        return $auth;
+    }
+
+    /**
+     * This method is used to redirect the client to the CAS server.
+     * It is used by CAS_Client::forceAuthentication() and
+     * CAS_Client::checkAuthentication().
+     *
+     * @param bool $gateway true to check authentication, false to force it
+     * @param bool $renew   true to force the authentication with the CAS server
+     *
+     * @return void
+     */
+    public function redirectToCas($gateway=false,$renew=false)
+    {
+        phpCAS::traceBegin();
+        $cas_url = $this->getServerLoginURL($gateway, $renew);
+        if (php_sapi_name() === 'cli') {
+            @header('Location: '.$cas_url);
+        } else {
+            header('Location: '.$cas_url);
+        }
+        phpCAS::trace("Redirect to : ".$cas_url);
+        $lang = $this->getLangObj();
+        $this->printHTMLHeader($lang->getAuthenticationWanted());
+        printf('<p>'. $lang->getShouldHaveBeenRedirected(). '</p>', $cas_url);
+        $this->printHTMLFooter();
+        phpCAS::traceExit();
+        throw new CAS_GracefullTerminationException();
+    }
+
+
+    /**
+     * This method is used to logout from CAS.
+     *
+     * @param array $params an array that contains the optional url and service
+     * parameters that will be passed to the CAS server
+     *
+     * @return void
+     */
+    public function logout($params)
+    {
+        phpCAS::traceBegin();
+        $cas_url = $this->getServerLogoutURL();
+        $paramSeparator = '?';
+        if (isset($params['url'])) {
+            $cas_url = $cas_url . $paramSeparator . "url=" . urlencode($params['url']);
+            $paramSeparator = '&';
+        }
+        if (isset($params['service'])) {
+            $cas_url = $cas_url . $paramSeparator . "service=" . urlencode($params['service']);
+        }
+        header('Location: '.$cas_url);
+        phpCAS::trace("Prepare redirect to : ".$cas_url);
+
+        session_unset();
+        session_destroy();
+        $lang = $this->getLangObj();
+        $this->printHTMLHeader($lang->getLogout());
+        printf('<p>'.$lang->getShouldHaveBeenRedirected(). '</p>', $cas_url);
+        $this->printHTMLFooter();
+        phpCAS::traceExit();
+        throw new CAS_GracefullTerminationException();
+    }
+
+    /**
+     * Check of the current request is a logout request
+     *
+     * @return bool is logout request.
+     */
+    private function _isLogoutRequest()
+    {
+        return !empty($_POST['logoutRequest']);
+    }
+
+    /**
+     * This method handles logout requests.
+     *
+     * @param bool $check_client    true to check the client bofore handling
+     * the request, false not to perform any access control. True by default.
+     * @param bool $allowed_clients an array of host names allowed to send
+     * logout requests.
+     *
+     * @return void
+     */
+    public function handleLogoutRequests($check_client=true, $allowed_clients=false)
+    {
+        phpCAS::traceBegin();
+        if (!$this->_isLogoutRequest()) {
+            phpCAS::trace("Not a logout request");
+            phpCAS::traceEnd();
+            return;
+        }
+        if (!$this->getChangeSessionID() && is_null($this->_signoutCallbackFunction)) {
+            phpCAS::trace("phpCAS can't handle logout requests if it is not allowed to change session_id.");
+        }
+        phpCAS::trace("Logout requested");
+        $decoded_logout_rq = urldecode($_POST['logoutRequest']);
+        phpCAS::trace("SAML REQUEST: ".$decoded_logout_rq);
+        $allowed = false;
+        if ($check_client) {
+            if (!$allowed_clients) {
+                $allowed_clients = array( $this->_getServerHostname() );
+            }
+            $client_ip = $_SERVER['REMOTE_ADDR'];
+            $client = gethostbyaddr($client_ip);
+            phpCAS::trace("Client: ".$client."/".$client_ip);
+            foreach ($allowed_clients as $allowed_client) {
+                if (($client == $allowed_client) or ($client_ip == $allowed_client)) {
+                    phpCAS::trace("Allowed client '".$allowed_client."' matches, logout request is allowed");
+                    $allowed = true;
+                    break;
+                } else {
+                    phpCAS::trace("Allowed client '".$allowed_client."' does not match");
+                }
+            }
+        } else {
+            phpCAS::trace("No access control set");
+            $allowed = true;
+        }
+        // If Logout command is permitted proceed with the logout
+        if ($allowed) {
+            phpCAS::trace("Logout command allowed");
+            // Rebroadcast the logout request
+            if ($this->_rebroadcast && !isset($_POST['rebroadcast'])) {
+                $this->_rebroadcast(self::LOGOUT);
+            }
+            // Extract the ticket from the SAML Request
+            preg_match("|<samlp:SessionIndex>(.*)</samlp:SessionIndex>|", $decoded_logout_rq, $tick, PREG_OFFSET_CAPTURE, 3);
+            $wrappedSamlSessionIndex = preg_replace('|<samlp:SessionIndex>|', '', $tick[0][0]);
+            $ticket2logout = preg_replace('|</samlp:SessionIndex>|', '', $wrappedSamlSessionIndex);
+            phpCAS::trace("Ticket to logout: ".$ticket2logout);
+
+            // call the post-authenticate callback if registered.
+            if ($this->_signoutCallbackFunction) {
+                $args = $this->_signoutCallbackArgs;
+                array_unshift($args, $ticket2logout);
+                call_user_func_array($this->_signoutCallbackFunction, $args);
+            }
+
+            // If phpCAS is managing the session_id, destroy session thanks to session_id.
+            if ($this->getChangeSessionID()) {
+                $session_id = preg_replace('/[^a-zA-Z0-9\-]/', '', $ticket2logout);
+                phpCAS::trace("Session id: ".$session_id);
+
+                // destroy a possible application session created before phpcas
+                if (session_id() !== "") {
+                    session_unset();
+                    session_destroy();
+                }
+                // fix session ID
+                session_id($session_id);
+                $_COOKIE[session_name()]=$session_id;
+                $_GET[session_name()]=$session_id;
+
+                // Overwrite session
+                session_start();
+                session_unset();
+                session_destroy();
+                phpCAS::trace("Session ". $session_id . " destroyed");
+            }
+        } else {
+            phpCAS::error("Unauthorized logout request from client '".$client."'");
+            phpCAS::trace("Unauthorized logout request from client '".$client."'");
+        }
+        flush();
+        phpCAS::traceExit();
+        throw new CAS_GracefullTerminationException();
+
+    }
+
+    /** @} */
+
+    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+    // XX                                                                    XX
+    // XX                  BASIC CLIENT FEATURES (CAS 1.0)                   XX
+    // XX                                                                    XX
+    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+
+    // ########################################################################
+    //  ST
+    // ########################################################################
+    /**
+    * @addtogroup internalBasic
+    * @{
+    */
+
+    /**
+     * The Ticket provided in the URL of the request if present
+     * (empty otherwise). Written by CAS_Client::CAS_Client(), read by
+     * CAS_Client::getTicket() and CAS_Client::_hasPGT().
+     *
+     * @hideinitializer
+     */
+    private $_ticket = '';
+
+    /**
+     * This method returns the Service Ticket provided in the URL of the request.
+     *
+     * @return string service ticket.
+     */
+    public  function getTicket()
+    {
+        return $this->_ticket;
+    }
+
+    /**
+     * This method stores the Service Ticket.
+     *
+     * @param string $st The Service Ticket.
+     *
+     * @return void
+     */
+    public function setTicket($st)
+    {
+        $this->_ticket = $st;
+    }
+
+    /**
+     * This method tells if a Service Ticket was stored.
+     *
+     * @return bool if a Service Ticket has been stored.
+     */
+    public function hasTicket()
+    {
+        return !empty($this->_ticket);
+    }
+
+    /** @} */
+
+    // ########################################################################
+    //  ST VALIDATION
+    // ########################################################################
+    /**
+    * @addtogroup internalBasic
+    * @{
+    */
+
+    /**
+     * the certificate of the CAS server CA.
+     *
+     * @hideinitializer
+     */
+    private $_cas_server_ca_cert = '';
+
+    /**
+     * Set to true not to validate the CAS server.
+     *
+     * @hideinitializer
+     */
+    private $_no_cas_server_validation = false;
+
+
+    /**
+     * Set the CA certificate of the CAS server.
+     *
+     * @param string $cert the PEM certificate file name of the CA that emited
+     * the cert of the server
+     *
+     * @return void
+     */
+    public function setCasServerCACert($cert)
+    {
+        $this->_cas_server_ca_cert = $cert;
+    }
+
+    /**
+     * Set no SSL validation for the CAS server.
+     *
+     * @return void
+     */
+    public function setNoCasServerValidation()
+    {
+        $this->_no_cas_server_validation = true;
+    }
+
+    /**
+     * This method is used to validate a CAS 1,0 ticket; halt on failure, and
+     * sets $validate_url, $text_reponse and $tree_response on success.
+     *
+     * @param string &$validate_url  reference to the the URL of the request to
+     * the CAS server.
+     * @param string &$text_response reference to the response of the CAS
+     * server, as is (XML text).
+     * @param string &$tree_response reference to the response of the CAS
+     * server, as a DOM XML tree.
+     *
+     * @return bool true when successfull and issue a CAS_AuthenticationException
+     * and false on an error
+     */
+    public function validateCAS10(&$validate_url,&$text_response,&$tree_response)
+    {
+        phpCAS::traceBegin();
+        $result = false;
+        // build the URL to validate the ticket
+        $validate_url = $this->getServerServiceValidateURL().'&ticket='.$this->getTicket();
+
+        // open and read the URL
+        if ( !$this->_readURL($validate_url, $headers, $text_response, $err_msg) ) {
+            phpCAS::trace('could not open URL \''.$validate_url.'\' to validate ('.$err_msg.')');
+            throw new CAS_AuthenticationException(
+                $this, 'CAS 1.0 ticket not validated', $validate_url,
+                true/*$no_response*/
+            );
+            $result = false;
+        }
+
+        if (preg_match('/^no\n/', $text_response)) {
+            phpCAS::trace('Ticket has not been validated');
+            throw new CAS_AuthenticationException(
+                $this, 'ST not validated', $validate_url, false/*$no_response*/,
+                false/*$bad_response*/, $text_response
+            );
+            $result = false;
+        } else if (!preg_match('/^yes\n/', $text_response)) {
+            phpCAS::trace('ill-formed response');
+            throw new CAS_AuthenticationException(
+                $this, 'Ticket not validated', $validate_url,
+                false/*$no_response*/, true/*$bad_response*/, $text_response
+            );
+            $result = false;
+        }
+        // ticket has been validated, extract the user name
+        $arr = preg_split('/\n/', $text_response);
+        $this->_setUser(trim($arr[1]));
+        $result = true;
+        break;
+
+        if ($result) {
+            $this->_renameSession($this->getTicket());
+        }
+        // at this step, ticket has been validated and $this->_user has been set,
+        phpCAS::traceEnd(true);
+        return true;
+    }
+
+    /** @} */
+
+
+    // ########################################################################
+    //  SAML VALIDATION
+    // ########################################################################
+    /**
+    * @addtogroup internalSAML
+    * @{
+    */
+
+    /**
+     * This method is used to validate a SAML TICKET; halt on failure, and sets
+     * $validate_url, $text_reponse and $tree_response on success. These
+     * parameters are used later by CAS_Client::_validatePGT() for CAS proxies.
+     *
+     * @param string &$validate_url  reference to the the URL of the request to
+     * the CAS server.
+     * @param string &$text_response reference to the response of the CAS
+     * server, as is (XML text).
+     * @param string &$tree_response reference to the response of the CAS
+     * server, as a DOM XML tree.
+     *
+     * @return bool true when successfull and issue a CAS_AuthenticationException
+     * and false on an error
+     */
+    public function validateSA(&$validate_url,&$text_response,&$tree_response)
+    {
+        phpCAS::traceBegin();
+        $result = false;
+        // build the URL to validate the ticket
+        $validate_url = $this->getServerSamlValidateURL();
+
+        // open and read the URL
+        if ( !$this->_readURL($validate_url, $headers, $text_response, $err_msg) ) {
+            phpCAS::trace('could not open URL \''.$validate_url.'\' to validate ('.$err_msg.')');
+            throw new CAS_AuthenticationException($this, 'SA not validated', $validate_url, true/*$no_response*/);
+        }
+
+        phpCAS::trace('server version: '.$this->getServerVersion());
+
+        // analyze the result depending on the version
+        switch ($this->getServerVersion()) {
+        case SAML_VERSION_1_1:
+            // create new DOMDocument Object
+            $dom = new DOMDocument();
+            // Fix possible whitspace problems
+            $dom->preserveWhiteSpace = false;
+            // read the response of the CAS server into a DOM object
+            if (!($dom->loadXML($text_response))) {
+                phpCAS::trace('dom->loadXML() failed');
+                throw new CAS_AuthenticationException(
+                    $this, 'SA not validated', $validate_url,
+                    false/*$no_response*/, true/*$bad_response*/,
+                    $text_response
+                );
+                $result = false;
+            }
+            // read the root node of the XML tree
+            if (!($tree_response = $dom->documentElement)) {
+                phpCAS::trace('documentElement() failed');
+                throw new CAS_AuthenticationException(
+                    $this, 'SA not validated', $validate_url,
+                    false/*$no_response*/, true/*$bad_response*/,
+                    $text_response
+                );
+                $result = false;
+            } else if ( $tree_response->localName != 'Envelope' ) {
+                // insure that tag name is 'Envelope'
+                phpCAS::trace('bad XML root node (should be `Envelope\' instead of `'.$tree_response->localName.'\'');
+                throw new CAS_AuthenticationException(
+                    $this, 'SA not validated', $validate_url,
+                    false/*$no_response*/, true/*$bad_response*/,
+                    $text_response
+                );
+                $result = false;
+            } else if ($tree_response->getElementsByTagName("NameIdentifier")->length != 0) {
+                // check for the NameIdentifier tag in the SAML response
+                $success_elements = $tree_response->getElementsByTagName("NameIdentifier");
+                phpCAS::trace('NameIdentifier found');
+                $user = trim($success_elements->item(0)->nodeValue);
+                phpCAS::trace('user = `'.$user.'`');
+                $this->_setUser($user);
+                $this->_setSessionAttributes($text_response);
+                $result = true;
+            } else {
+                phpCAS::trace('no <NameIdentifier> tag found in SAML payload');
+                throw new CAS_AuthenticationException(
+                    $this, 'SA not validated', $validate_url,
+                    false/*$no_response*/, true/*$bad_response*/,
+                    $text_response
+                );
+                $result = false;
+            }
+        }
+        if ($result) {
+            $this->_renameSession($this->getTicket());
+        }
+        // at this step, ST has been validated and $this->_user has been set,
+        phpCAS::traceEnd($result);
+        return $result;
+    }
+
+    /**
+     * This method will parse the DOM and pull out the attributes from the SAML
+     * payload and put them into an array, then put the array into the session.
+     *
+     * @param string $text_response the SAML payload.
+     *
+     * @return bool true when successfull and false if no attributes a found
+     */
+    private function _setSessionAttributes($text_response)
+    {
+        phpCAS::traceBegin();
+
+        $result = false;
+
+        $attr_array = array();
+
+        // create new DOMDocument Object
+        $dom = new DOMDocument();
+        // Fix possible whitspace problems
+        $dom->preserveWhiteSpace = false;
+        if (($dom->loadXML($text_response))) {
+            $xPath = new DOMXpath($dom);
+            $xPath->registerNamespace('samlp', 'urn:oasis:names:tc:SAML:1.0:protocol');
+            $xPath->registerNamespace('saml', 'urn:oasis:names:tc:SAML:1.0:assertion');
+            $nodelist = $xPath->query("//saml:Attribute");
+
+            if ($nodelist) {
+                foreach ($nodelist as $node) {
+                    $xres = $xPath->query("saml:AttributeValue", $node);
+                    $name = $node->getAttribute("AttributeName");
+                    $value_array = array();
+                    foreach ($xres as $node2) {
+                        $value_array[] = $node2->nodeValue;
+                    }
+                    $attr_array[$name] = $value_array;
+                }
+                // UGent addition...
+                foreach ($attr_array as $attr_key => $attr_value) {
+                    if (count($attr_value) > 1) {
+                        $this->_attributes[$attr_key] = $attr_value;
+                        phpCAS::trace("* " . $attr_key . "=" . $attr_value);
+                    } else {
+                        $this->_attributes[$attr_key] = $attr_value[0];
+                        phpCAS::trace("* " . $attr_key . "=" . $attr_value[0]);
+                    }
+                }
+                $result = true;
+            } else {
+                phpCAS::trace("SAML Attributes are empty");
+                $result = false;
+            }
+        }
+        phpCAS::traceEnd($result);
+        return $result;
+    }
+
+    /** @} */
+
+    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+    // XX                                                                    XX
+    // XX                     PROXY FEATURES (CAS 2.0)                       XX
+    // XX                                                                    XX
+    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+
+    // ########################################################################
+    //  PROXYING
+    // ########################################################################
+    /**
+    * @addtogroup internalProxy
+    * @{
+    */
+
+    /**
+     * A boolean telling if the client is a CAS proxy or not. Written by
+     * CAS_Client::CAS_Client(), read by CAS_Client::isProxy().
+     */
+    private $_proxy;
+
+    /**
+     * Handler for managing service cookies.
+     */
+    private $_serviceCookieJar;
+
+    /**
+     * Tells if a CAS client is a CAS proxy or not
+     *
+     * @return true when the CAS client is a CAs proxy, false otherwise
+     */
+    public function isProxy()
+    {
+        return $this->_proxy;
+    }
+
+    /** @} */
+    // ########################################################################
+    //  PGT
+    // ########################################################################
+    /**
+    * @addtogroup internalProxy
+    * @{
+    */
+
+    /**
+     * the Proxy Grnting Ticket given by the CAS server (empty otherwise).
+     * Written by CAS_Client::_setPGT(), read by CAS_Client::_getPGT() and
+     * CAS_Client::_hasPGT().
+     *
+     * @hideinitializer
+     */
+    private $_pgt = '';
+
+    /**
+     * This method returns the Proxy Granting Ticket given by the CAS server.
+     *
+     * @return string the Proxy Granting Ticket.
+     */
+    private function _getPGT()
+    {
+        return $this->_pgt;
+    }
+
+    /**
+     * This method stores the Proxy Granting Ticket.
+     *
+     * @param string $pgt The Proxy Granting Ticket.
+     *
+     * @return void
+     */
+    private function _setPGT($pgt)
+    {
+        $this->_pgt = $pgt;
+    }
+
+    /**
+     * This method tells if a Proxy Granting Ticket was stored.
+     *
+     * @return true if a Proxy Granting Ticket has been stored.
+     */
+    private function _hasPGT()
+    {
+        return !empty($this->_pgt);
+    }
+
+    /** @} */
+
+    // ########################################################################
+    //  CALLBACK MODE
+    // ########################################################################
+    /**
+    * @addtogroup internalCallback
+    * @{
+    */
+    /**
+     * each PHP script using phpCAS in proxy mode is its own callback to get the
+     * PGT back from the CAS server. callback_mode is detected by the constructor
+     * thanks to the GET parameters.
+     */
+
+    /**
+     * a boolean to know if the CAS client is running in callback mode. Written by
+     * CAS_Client::setCallBackMode(), read by CAS_Client::_isCallbackMode().
+     *
+     * @hideinitializer
+     */
+    private $_callback_mode = false;
+
+    /**
+     * This method sets/unsets callback mode.
+     *
+     * @param bool $callback_mode true to set callback mode, false otherwise.
+     *
+     * @return void
+     */
+    private function _setCallbackMode($callback_mode)
+    {
+        $this->_callback_mode = $callback_mode;
+    }
+
+    /**
+     * This method returns true when the CAs client is running i callback mode,
+     * false otherwise.
+     *
+     * @return A boolean.
+     */
+    private function _isCallbackMode()
+    {
+        return $this->_callback_mode;
+    }
+
+    /**
+     * the URL that should be used for the PGT callback (in fact the URL of the
+     * current request without any CGI parameter). Written and read by
+     * CAS_Client::_getCallbackURL().
+     *
+     * @hideinitializer
+     */
+    private $_callback_url = '';
+
+    /**
+     * This method returns the URL that should be used for the PGT callback (in
+     * fact the URL of the current request without any CGI parameter, except if
+     * phpCAS::setFixedCallbackURL() was used).
+     *
+     * @return The callback URL
+     */
+    private function _getCallbackURL()
+    {
+        // the URL is built when needed only
+        if ( empty($this->_callback_url) ) {
+            $final_uri = '';
+            // remove the ticket if present in the URL
+            $final_uri = 'https://';
+            $final_uri .= $this->_getServerUrl();
+            $request_uri = $_SERVER['REQUEST_URI'];
+            $request_uri = preg_replace('/\?.*$/', '', $request_uri);
+            $final_uri .= $request_uri;
+            $this->setCallbackURL($final_uri);
+        }
+        return $this->_callback_url;
+    }
+
+    /**
+     * This method sets the callback url.
+     *
+     * @param string $url url to set callback
+     *
+     * @return void
+     */
+    public function setCallbackURL($url)
+    {
+        return $this->_callback_url = $url;
+    }
+
+    /**
+     * This method is called by CAS_Client::CAS_Client() when running in callback
+     * mode. It stores the PGT and its PGT Iou, prints its output and halts.
+     *
+     * @return void
+     */
+    private function _callback()
+    {
+        phpCAS::traceBegin();
+        if (preg_match('/PGTIOU-[\.\-\w]/', $_GET['pgtIou'])) {
+            if (preg_match('/[PT]GT-[\.\-\w]/', $_GET['pgtId'])) {
+                $this->printHTMLHeader('phpCAS callback');
+                $pgt_iou = $_GET['pgtIou'];
+                $pgt = $_GET['pgtId'];
+                phpCAS::trace('Storing PGT `'.$pgt.'\' (id=`'.$pgt_iou.'\')');
+                echo '<p>Storing PGT `'.$pgt.'\' (id=`'.$pgt_iou.'\').</p>';
+                $this->_storePGT($pgt, $pgt_iou);
+                $this->printHTMLFooter();
+                phpCAS::traceExit("Successfull Callback");
+            } else {
+                phpCAS::error('PGT format invalid' . $_GET['pgtId']);
+                phpCAS::traceExit('PGT format invalid' . $_GET['pgtId']);
+            }
+        } else {
+            phpCAS::error('PGTiou format invalid' . $_GET['pgtIou']);
+            phpCAS::traceExit('PGTiou format invalid' . $_GET['pgtIou']);
+        }
+
+        // Flush the buffer to prevent from sending anything other then a 200
+        // Success Status back to the CAS Server. The Exception would normally
+        // report as a 500 error.
+        flush();
+        throw new CAS_GracefullTerminationException();
+    }
+
+
+    /** @} */
+
+    // ########################################################################
+    //  PGT STORAGE
+    // ########################################################################
+    /**
+    * @addtogroup internalPGTStorage
+    * @{
+    */
+
+    /**
+     * an instance of a class inheriting of PGTStorage, used to deal with PGT
+     * storage. Created by CAS_Client::setPGTStorageFile(), used
+     * by CAS_Client::setPGTStorageFile() and CAS_Client::_initPGTStorage().
+     *
+     * @hideinitializer
+     */
+    private $_pgt_storage = null;
+
+    /**
+     * This method is used to initialize the storage of PGT's.
+     * Halts on error.
+     *
+     * @return void
+     */
+    private function _initPGTStorage()
+    {
+        // if no SetPGTStorageXxx() has been used, default to file
+        if ( !is_object($this->_pgt_storage) ) {
+            $this->setPGTStorageFile();
+        }
+
+        // initializes the storage
+        $this->_pgt_storage->init();
+    }
+
+    /**
+     * This method stores a PGT. Halts on error.
+     *
+     * @param string $pgt     the PGT to store
+     * @param string $pgt_iou its corresponding Iou
+     *
+     * @return void
+     */
+    private function _storePGT($pgt,$pgt_iou)
+    {
+        // ensure that storage is initialized
+        $this->_initPGTStorage();
+        // writes the PGT
+        $this->_pgt_storage->write($pgt, $pgt_iou);
+    }
+
+    /**
+     * This method reads a PGT from its Iou and deletes the corresponding
+     * storage entry.
+     *
+     * @param string $pgt_iou the PGT Iou
+     *
+     * @return mul The PGT corresponding to the Iou, false when not found.
+     */
+    private function _loadPGT($pgt_iou)
+    {
+        // ensure that storage is initialized
+        $this->_initPGTStorage();
+        // read the PGT
+        return $this->_pgt_storage->read($pgt_iou);
+    }
+
+    /**
+     * This method can be used to set a custom PGT storage object.
+     *
+     * @param CAS_PGTStorage_AbstractStorage $storage a PGT storage object that
+     * inherits from the CAS_PGTStorage_AbstractStorage class
+     *
+     * @return void
+     */
+    public function setPGTStorage($storage)
+    {
+        // check that the storage has not already been set
+        if ( is_object($this->_pgt_storage) ) {
+            phpCAS::error('PGT storage already defined');
+        }
+
+        // check to make sure a valid storage object was specified
+        if ( !($storage instanceof CAS_PGTStorage_AbstractStorage) ) {
+            phpCAS::error('Invalid PGT storage object');
+        }
+
+        // store the PGTStorage object
+        $this->_pgt_storage = $storage;
+    }
+
+    /**
+     * This method is used to tell phpCAS to store the response of the
+     * CAS server to PGT requests in a database.
+     *
+     * @param string $dsn_or_pdo     a dsn string to use for creating a PDO
+     * object or a PDO object
+     * @param string $username       the username to use when connecting to the
+     * database
+     * @param string $password       the password to use when connecting to the
+     * database
+     * @param string $table          the table to use for storing and retrieving
+     * PGTs
+     * @param string $driver_options any driver options to use when connecting
+     * to the database
+     *
+     * @return void
+     */
+    public function setPGTStorageDb($dsn_or_pdo, $username='', $password='', $table='', $driver_options=null)
+    {
+        // create the storage object
+        $this->setPGTStorage(new CAS_PGTStorage_Db($this, $dsn_or_pdo, $username, $password, $table, $driver_options));
+    }
+
+    /**
+     * This method is used to tell phpCAS to store the response of the
+     * CAS server to PGT requests onto the filesystem.
+     *
+     * @param string $path the path where the PGT's should be stored
+     *
+     * @return void
+     */
+    public function setPGTStorageFile($path='')
+    {
+        // create the storage object
+        $this->setPGTStorage(new CAS_PGTStorage_File($this, $path));
+    }
+
+
+    // ########################################################################
+    //  PGT VALIDATION
+    // ########################################################################
+    /**
+    * This method is used to validate a PGT; halt on failure.
+    *
+    * @param string &$validate_url the URL of the request to the CAS server.
+    * @param string $text_response the response of the CAS server, as is
+    * (XML text); result of CAS_Client::validateCAS10() or CAS_Client::validateCAS20().
+    * @param string $tree_response the response of the CAS server, as a DOM XML
+    * tree; result of CAS_Client::validateCAS10() or CAS_Client::validateCAS20().
+    *
+    * @return bool true when successfull and issue a CAS_AuthenticationException
+    * and false on an error
+    */
+    private function _validatePGT(&$validate_url,$text_response,$tree_response)
+    {
+        phpCAS::traceBegin();
+        if ( $tree_response->getElementsByTagName("proxyGrantingTicket")->length == 0) {
+            phpCAS::trace('<proxyGrantingTicket> not found');
+            // authentication succeded, but no PGT Iou was transmitted
+            throw new CAS_AuthenticationException(
+                $this, 'Ticket validated but no PGT Iou transmitted',
+                $validate_url, false/*$no_response*/, false/*$bad_response*/,
+                $text_response
+            );
+        } else {
+            // PGT Iou transmitted, extract it
+            $pgt_iou = trim($tree_response->getElementsByTagName("proxyGrantingTicket")->item(0)->nodeValue);
+            if (preg_match('/PGTIOU-[\.\-\w]/', $pgt_iou)) {
+                $pgt = $this->_loadPGT($pgt_iou);
+                if ( $pgt == false ) {
+                    phpCAS::trace('could not load PGT');
+                    throw new CAS_AuthenticationException(
+                        $this, 'PGT Iou was transmitted but PGT could not be retrieved',
+                        $validate_url, false/*$no_response*/,
+                        false/*$bad_response*/, $text_response
+                    );
+                }
+                $this->_setPGT($pgt);
+            } else {
+                phpCAS::trace('PGTiou format error');
+                throw new CAS_AuthenticationException(
+                    $this, 'PGT Iou was transmitted but has wrong format',
+                    $validate_url, false/*$no_response*/, false/*$bad_response*/,
+                    $text_response
+                );
+            }
+        }
+        phpCAS::traceEnd(true);
+        return true;
+    }
+
+    // ########################################################################
+    //  PGT VALIDATION
+    // ########################################################################
+
+    /**
+     * This method is used to retrieve PT's from the CAS server thanks to a PGT.
+     *
+     * @param string $target_service the service to ask for with the PT.
+     * @param string &$err_code      an error code (PHPCAS_SERVICE_OK on success).
+     * @param string &$err_msg       an error message (empty on success).
+     *
+     * @return a Proxy Ticket, or false on error.
+     */
+    public function retrievePT($target_service,&$err_code,&$err_msg)
+    {
+        phpCAS::traceBegin();
+
+        // by default, $err_msg is set empty and $pt to true. On error, $pt is
+        // set to false and $err_msg to an error message. At the end, if $pt is false
+        // and $error_msg is still empty, it is set to 'invalid response' (the most
+        // commonly encountered error).
+        $err_msg = '';
+
+        // build the URL to retrieve the PT
+        $cas_url = $this->getServerProxyURL().'?targetService='.urlencode($target_service).'&pgt='.$this->_getPGT();
+
+        // open and read the URL
+        if ( !$this->_readURL($cas_url, $headers, $cas_response, $err_msg) ) {
+            phpCAS::trace('could not open URL \''.$cas_url.'\' to validate ('.$err_msg.')');
+            $err_code = PHPCAS_SERVICE_PT_NO_SERVER_RESPONSE;
+            $err_msg = 'could not retrieve PT (no response from the CAS server)';
+            phpCAS::traceEnd(false);
+            return false;
+        }
+
+        $bad_response = false;
+
+        if ( !$bad_response ) {
+            // create new DOMDocument object
+            $dom = new DOMDocument();
+            // Fix possible whitspace problems
+            $dom->preserveWhiteSpace = false;
+            // read the response of the CAS server into a DOM object
+            if ( !($dom->loadXML($cas_response))) {
+                phpCAS::trace('dom->loadXML() failed');
+                // read failed
+                $bad_response = true;
+            }
+        }
+
+        if ( !$bad_response ) {
+            // read the root node of the XML tree
+            if ( !($root = $dom->documentElement) ) {
+                phpCAS::trace('documentElement failed');
+                // read failed
+                $bad_response = true;
+            }
+        }
+
+        if ( !$bad_response ) {
+            // insure that tag name is 'serviceResponse'
+            if ( $root->localName != 'serviceResponse' ) {
+                phpCAS::trace('localName failed');
+                // bad root node
+                $bad_response = true;
+            }
+        }
+
+        if ( !$bad_response ) {
+            // look for a proxySuccess tag
+            if ( $root->getElementsByTagName("proxySuccess")->length != 0) {
+                $proxy_success_list = $root->getElementsByTagName("proxySuccess");
+
+                // authentication succeded, look for a proxyTicket tag
+                if ( $proxy_success_list->item(0)->getElementsByTagName("proxyTicket")->length != 0) {
+                    $err_code = PHPCAS_SERVICE_OK;
+                    $err_msg = '';
+                    $pt = trim($proxy_success_list->item(0)->getElementsByTagName("proxyTicket")->item(0)->nodeValue);
+                    phpCAS::trace('original PT: '.trim($pt));
+                    phpCAS::traceEnd($pt);
+                    return $pt;
+                } else {
+                    phpCAS::trace('<proxySuccess> was found, but not <proxyTicket>');
+                }
+            } else if ($root->getElementsByTagName("proxyFailure")->length != 0) {
+                // look for a proxyFailure tag
+                $proxy_failure_list = $root->getElementsByTagName("proxyFailure");
+
+                // authentication failed, extract the error
+                $err_code = PHPCAS_SERVICE_PT_FAILURE;
+                $err_msg = 'PT retrieving failed (code=`'
+                .$proxy_failure_list->item(0)->getAttribute('code')
+                .'\', message=`'
+                .trim($proxy_failure_list->item(0)->nodeValue)
+                .'\')';
+                phpCAS::traceEnd(false);
+                return false;
+            } else {
+                phpCAS::trace('neither <proxySuccess> nor <proxyFailure> found');
+            }
+        }
+
+        // at this step, we are sure that the response of the CAS server was
+        // illformed
+        $err_code = PHPCAS_SERVICE_PT_BAD_SERVER_RESPONSE;
+        $err_msg = 'Invalid response from the CAS server (response=`'.$cas_response.'\')';
+
+        phpCAS::traceEnd(false);
+        return false;
+    }
+
+    /** @} */
+
+    // ########################################################################
+    // READ CAS SERVER ANSWERS
+    // ########################################################################
+
+    /**
+     * @addtogroup internalMisc
+     * @{
+     */
+
+    /**
+     * This method is used to acces a remote URL.
+     *
+     * @param string $url      the URL to access.
+     * @param string &$headers an array containing the HTTP header lines of the
+     * response (an empty array on failure).
+     * @param string &$body    the body of the response, as a string (empty on
+     * failure).
+     * @param string &$err_msg an error message, filled on failure.
+     *
+     * @return true on success, false otherwise (in this later case, $err_msg
+     * contains an error message).
+     */
+    private function _readURL($url, &$headers, &$body, &$err_msg)
+    {
+        phpCAS::traceBegin();
+        $className = $this->_requestImplementation;
+        $request = new $className();
+
+        if (count($this->_curl_options)) {
+            $request->setCurlOptions($this->_curl_options);
+        }
+
+        $request->setUrl($url);
+
+        if (empty($this->_cas_server_ca_cert) && !$this->_no_cas_server_validation) {
+            phpCAS::error('one of the methods phpCAS::setCasServerCACert() or phpCAS::setNoCasServerValidation() must be called.');
+        }
+        if ($this->_cas_server_ca_cert != '') {
+            $request->setSslCaCert($this->_cas_server_ca_cert);
+        }
+
+        // add extra stuff if SAML
+        if ($this->getServerVersion() == SAML_VERSION_1_1) {
+            $request->addHeader("soapaction: http://www.oasis-open.org/committees/security");
+            $request->addHeader("cache-control: no-cache");
+            $request->addHeader("pragma: no-cache");
+            $request->addHeader("accept: text/xml");
+            $request->addHeader("connection: keep-alive");
+            $request->addHeader("content-type: text/xml");
+            $request->makePost();
+            $request->setPostBody($this->_buildSAMLPayload());
+        }
+
+        if ($request->send()) {
+            $headers = $request->getResponseHeaders();
+            $body = $request->getResponseBody();
+            $err_msg = '';
+            phpCAS::traceEnd(true);
+            return true;
+        } else {
+            $headers = '';
+            $body = '';
+            $err_msg = $request->getErrorMessage();
+            phpCAS::traceEnd(false);
+            return false;
+        }
+    }
+
+    /**
+     * This method is used to build the SAML POST body sent to /samlValidate URL.
+     *
+     * @return the SOAP-encased SAMLP artifact (the ticket).
+     */
+    private function _buildSAMLPayload()
+    {
+        phpCAS::traceBegin();
+
+        //get the ticket
+        $sa = $this->getTicket();
+
+        $body=SAML_SOAP_ENV.SAML_SOAP_BODY.SAMLP_REQUEST.SAML_ASSERTION_ARTIFACT.$sa.SAML_ASSERTION_ARTIFACT_CLOSE.SAMLP_REQUEST_CLOSE.SAML_SOAP_BODY_CLOSE.SAML_SOAP_ENV_CLOSE;
+
+        phpCAS::traceEnd($body);
+        return ($body);
+    }
+
+    /** @} **/
+
+    // ########################################################################
+    // ACCESS TO EXTERNAL SERVICES
+    // ########################################################################
+
+    /**
+     * @addtogroup internalProxyServices
+     * @{
+     */
+
+
+    /**
+     * Answer a proxy-authenticated service handler.
+     *
+     * @param string $type The service type. One of:
+     * PHPCAS_PROXIED_SERVICE_HTTP_GET, PHPCAS_PROXIED_SERVICE_HTTP_POST,
+     * PHPCAS_PROXIED_SERVICE_IMAP
+     *
+     * @return CAS_ProxiedService
+     * @throws InvalidArgumentException If the service type is unknown.
+     */
+    public function getProxiedService ($type)
+    {
+        switch ($type) {
+        case PHPCAS_PROXIED_SERVICE_HTTP_GET:
+        case PHPCAS_PROXIED_SERVICE_HTTP_POST:
+            $requestClass = $this->_requestImplementation;
+            $request = new $requestClass();
+            if (count($this->_curl_options)) {
+                $request->setCurlOptions($this->_curl_options);
+            }
+            $proxiedService = new $type($request, $this->_serviceCookieJar);
+            if ($proxiedService instanceof CAS_ProxiedService_Testable) {
+                $proxiedService->setCasClient($this);
+            }
+            return $proxiedService;
+        case PHPCAS_PROXIED_SERVICE_IMAP;
+            $proxiedService = new CAS_ProxiedService_Imap($this->getUser());
+            if ($proxiedService instanceof CAS_ProxiedService_Testable) {
+                $proxiedService->setCasClient($this);
+            }
+            return $proxiedService;
+        default:
+            throw new CAS_InvalidArgumentException("Unknown proxied-service type, $type.");
+        }
+    }
+
+    /**
+     * Initialize a proxied-service handler with the proxy-ticket it should use.
+     *
+     * @param CAS_ProxiedService $proxiedService service handler
+     *
+     * @return void
+     *
+     * @throws CAS_ProxyTicketException If there is a proxy-ticket failure.
+     *		The code of the Exception will be one of:
+     *			PHPCAS_SERVICE_PT_NO_SERVER_RESPONSE
+     *			PHPCAS_SERVICE_PT_BAD_SERVER_RESPONSE
+     *			PHPCAS_SERVICE_PT_FAILURE
+     * @throws CAS_ProxiedService_Exception If there is a failure getting the
+     * url from the proxied service.
+     */
+    public function initializeProxiedService (CAS_ProxiedService $proxiedService)
+    {
+        $url = $proxiedService->getServiceUrl();
+        if (!is_string($url)) {
+            throw new CAS_ProxiedService_Exception("Proxied Service ".get_class($proxiedService)."->getServiceUrl() should have returned a string, returned a ".gettype($url)." instead.");
+        }
+        $pt = $this->retrievePT($url, $err_code, $err_msg);
+        if (!$pt) {
+            throw new CAS_ProxyTicketException($err_msg, $err_code);
+        }
+        $proxiedService->setProxyTicket($pt);
+    }
+
+    /**
+     * This method is used to access an HTTP[S] service.
+     *
+     * @param string $url       the service to access.
+     * @param int    &$err_code an error code Possible values are
+     * PHPCAS_SERVICE_OK (on success), PHPCAS_SERVICE_PT_NO_SERVER_RESPONSE,
+     * PHPCAS_SERVICE_PT_BAD_SERVER_RESPONSE, PHPCAS_SERVICE_PT_FAILURE,
+     * PHPCAS_SERVICE_NOT_AVAILABLE.
+     * @param string &$output   the output of the service (also used to give an error
+     * message on failure).
+     *
+     * @return true on success, false otherwise (in this later case, $err_code
+     * gives the reason why it failed and $output contains an error message).
+     */
+    public function serviceWeb($url,&$err_code,&$output)
+    {
+        try {
+            $service = $this->getProxiedService(PHPCAS_PROXIED_SERVICE_HTTP_GET);
+            $service->setUrl($url);
+            $service->send();
+            $output = $service->getResponseBody();
+            $err_code = PHPCAS_SERVICE_OK;
+            return true;
+        } catch (CAS_ProxyTicketException $e) {
+            $err_code = $e->getCode();
+            $output = $e->getMessage();
+            return false;
+        } catch (CAS_ProxiedService_Exception $e) {
+            $lang = $this->getLangObj();
+            $output = sprintf($lang->getServiceUnavailable(), $url, $e->getMessage());
+            $err_code = PHPCAS_SERVICE_NOT_AVAILABLE;
+            return false;
+        }
+    }
+
+    /**
+     * This method is used to access an IMAP/POP3/NNTP service.
+     *
+     * @param string $url        a string giving the URL of the service, including
+     * the mailing box for IMAP URLs, as accepted by imap_open().
+     * @param string $serviceUrl a string giving for CAS retrieve Proxy ticket
+     * @param string $flags      options given to imap_open().
+     * @param int    &$err_code  an error code Possible values are
+     * PHPCAS_SERVICE_OK (on success), PHPCAS_SERVICE_PT_NO_SERVER_RESPONSE,
+     * PHPCAS_SERVICE_PT_BAD_SERVER_RESPONSE, PHPCAS_SERVICE_PT_FAILURE,
+     *  PHPCAS_SERVICE_NOT_AVAILABLE.
+     * @param string &$err_msg   an error message on failure
+     * @param string &$pt        the Proxy Ticket (PT) retrieved from the CAS
+     * server to access the URL on success, false on error).
+     *
+     * @return object an IMAP stream on success, false otherwise (in this later
+     *  case, $err_code gives the reason why it failed and $err_msg contains an
+     *  error message).
+     */
+    public function serviceMail($url,$serviceUrl,$flags,&$err_code,&$err_msg,&$pt)
+    {
+        try {
+            $service = $this->getProxiedService(PHPCAS_PROXIED_SERVICE_IMAP);
+            $service->setServiceUrl($serviceUrl);
+            $service->setMailbox($url);
+            $service->setOptions($flags);
+
+            $stream = $service->open();
+            $err_code = PHPCAS_SERVICE_OK;
+            $pt = $service->getImapProxyTicket();
+            return $stream;
+        } catch (CAS_ProxyTicketException $e) {
+            $err_msg = $e->getMessage();
+            $err_code = $e->getCode();
+            $pt = false;
+            return false;
+        } catch (CAS_ProxiedService_Exception $e) {
+            $lang = $this->getLangObj();
+            $err_msg = sprintf(
+                $lang->getServiceUnavailable(),
+                $url,
+                $e->getMessage()
+            );
+            $err_code = PHPCAS_SERVICE_NOT_AVAILABLE;
+            $pt = false;
+            return false;
+        }
+    }
+
+    /** @} **/
+
+    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+    // XX                                                                    XX
+    // XX                  PROXIED CLIENT FEATURES (CAS 2.0)                 XX
+    // XX                                                                    XX
+    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+
+    // ########################################################################
+    //  PT
+    // ########################################################################
+    /**
+    * @addtogroup internalService
+    * @{
+    */
+
+    /**
+     * This array will store a list of proxies in front of this application. This
+     * property will only be populated if this script is being proxied rather than
+     * accessed directly.
+     *
+     * It is set in CAS_Client::validateCAS20() and can be read by
+     * CAS_Client::getProxies()
+     *
+     * @access private
+     */
+    private $_proxies = array();
+
+    /**
+     * Answer an array of proxies that are sitting in front of this application.
+     *
+     * This method will only return a non-empty array if we have received and
+     * validated a Proxy Ticket.
+     *
+     * @return array
+     * @access public
+     */
+    public function getProxies()
+    {
+        return $this->_proxies;
+    }
+
+    /**
+     * Set the Proxy array, probably from persistant storage.
+     *
+     * @param array $proxies An array of proxies
+     *
+     * @return void
+     * @access private
+     */
+    private function _setProxies($proxies)
+    {
+        $this->_proxies = $proxies;
+        if (!empty($proxies)) {
+            // For proxy-authenticated requests people are not viewing the URL
+            // directly since the client is another application making a
+            // web-service call.
+            // Because of this, stripping the ticket from the URL is unnecessary
+            // and causes another web-service request to be performed. Additionally,
+            // if session handling on either the client or the server malfunctions
+            // then the subsequent request will not complete successfully.
+            $this->setNoClearTicketsFromUrl();
+        }
+    }
+
+    /**
+     * A container of patterns to be allowed as proxies in front of the cas client.
+     *
+     * @var CAS_ProxyChain_AllowedList
+     */
+    private $_allowed_proxy_chains;
+
+    /**
+     * Answer the CAS_ProxyChain_AllowedList object for this client.
+     *
+     * @return CAS_ProxyChain_AllowedList
+     */
+    public function getAllowedProxyChains ()
+    {
+        if (empty($this->_allowed_proxy_chains)) {
+            $this->_allowed_proxy_chains = new CAS_ProxyChain_AllowedList();
+        }
+        return $this->_allowed_proxy_chains;
+    }
+
+    /** @} */
+    // ########################################################################
+    //  PT VALIDATION
+    // ########################################################################
+    /**
+    * @addtogroup internalProxied
+    * @{
+    */
+
+    /**
+     * This method is used to validate a cas 2.0 ST or PT; halt on failure
+     * Used for all CAS 2.0 validations
+     *
+     * @param string &$validate_url  the url of the reponse
+     * @param string &$text_response the text of the repsones
+     * @param string &$tree_response the domxml tree of the respones
+     *
+     * @return bool true when successfull and issue a CAS_AuthenticationException
+     * and false on an error
+     */
+    public function validateCAS20(&$validate_url,&$text_response,&$tree_response)
+    {
+        phpCAS::traceBegin();
+        phpCAS::trace($text_response);
+        $result = false;
+        // build the URL to validate the ticket
+        if ($this->getAllowedProxyChains()->isProxyingAllowed()) {
+            $validate_url = $this->getServerProxyValidateURL().'&ticket='.$this->getTicket();
+        } else {
+            $validate_url = $this->getServerServiceValidateURL().'&ticket='.$this->getTicket();
+        }
+
+        if ( $this->isProxy() ) {
+            // pass the callback url for CAS proxies
+            $validate_url .= '&pgtUrl='.urlencode($this->_getCallbackURL());
+        }
+
+        // open and read the URL
+        if ( !$this->_readURL($validate_url, $headers, $text_response, $err_msg) ) {
+            phpCAS::trace('could not open URL \''.$validate_url.'\' to validate ('.$err_msg.')');
+            throw new CAS_AuthenticationException(
+                $this, 'Ticket not validated', $validate_url,
+                true/*$no_response*/
+            );
+            $result = false;
+        }
+
+        // create new DOMDocument object
+        $dom = new DOMDocument();
+        // Fix possible whitspace problems
+        $dom->preserveWhiteSpace = false;
+        // CAS servers should only return data in utf-8
+        $dom->encoding = "utf-8";
+        // read the response of the CAS server into a DOMDocument object
+        if ( !($dom->loadXML($text_response))) {
+            // read failed
+            throw new CAS_AuthenticationException(
+                $this, 'Ticket not validated', $validate_url,
+                false/*$no_response*/, true/*$bad_response*/, $text_response
+            );
+            $result = false;
+        } else if ( !($tree_response = $dom->documentElement) ) {
+            // read the root node of the XML tree
+            // read failed
+            throw new CAS_AuthenticationException(
+                $this, 'Ticket not validated', $validate_url,
+                false/*$no_response*/, true/*$bad_response*/, $text_response
+            );
+            $result = false;
+        } else if ($tree_response->localName != 'serviceResponse') {
+            // insure that tag name is 'serviceResponse'
+            // bad root node
+            throw new CAS_AuthenticationException(
+                $this, 'Ticket not validated', $validate_url,
+                false/*$no_response*/, true/*$bad_response*/, $text_response
+            );
+            $result = false;
+        } else if ($tree_response->getElementsByTagName("authenticationSuccess")->length != 0) {
+            // authentication succeded, extract the user name
+            $success_elements = $tree_response->getElementsByTagName("authenticationSuccess");
+            if ( $success_elements->item(0)->getElementsByTagName("user")->length == 0) {
+                // no user specified => error
+                throw new CAS_AuthenticationException(
+                    $this, 'Ticket not validated', $validate_url,
+                    false/*$no_response*/, true/*$bad_response*/, $text_response
+                );
+                $result = false;
+            } else {
+                $this->_setUser(trim($success_elements->item(0)->getElementsByTagName("user")->item(0)->nodeValue));
+                $this->_readExtraAttributesCas20($success_elements);
+                // Store the proxies we are sitting behind for authorization checking
+                $proxyList = array();
+                if ( sizeof($arr = $success_elements->item(0)->getElementsByTagName("proxy")) > 0) {
+                    foreach ($arr as $proxyElem) {
+                        phpCAS::trace("Found Proxy: ".$proxyElem->nodeValue);
+                        $proxyList[] = trim($proxyElem->nodeValue);
+                    }
+                    $this->_setProxies($proxyList);
+                    phpCAS::trace("Storing Proxy List");
+                }
+                // Check if the proxies in front of us are allowed
+                if (!$this->getAllowedProxyChains()->isProxyListAllowed($proxyList)) {
+                    throw new CAS_AuthenticationException(
+                        $this, 'Proxy not allowed', $validate_url,
+                        false/*$no_response*/, true/*$bad_response*/,
+                        $text_response
+                    );
+                    $result = false;
+                } else {
+                    $result = true;
+                }
+            }
+        } else if ( $tree_response->getElementsByTagName("authenticationFailure")->length != 0) {
+            // authentication succeded, extract the error code and message
+            $auth_fail_list = $tree_response->getElementsByTagName("authenticationFailure");
+            throw new CAS_AuthenticationException(
+                $this, 'Ticket not validated', $validate_url,
+                false/*$no_response*/, false/*$bad_response*/,
+                $text_response,
+                $auth_fail_list->item(0)->getAttribute('code')/*$err_code*/,
+                trim($auth_fail_list->item(0)->nodeValue)/*$err_msg*/
+            );
+            $result = false;
+        } else {
+            throw new CAS_AuthenticationException(
+                $this, 'Ticket not validated', $validate_url,
+                false/*$no_response*/, true/*$bad_response*/,
+                $text_response
+            );
+            $result = false;
+        }
+        if ($result) {
+            $this->_renameSession($this->getTicket());
+        }
+        // at this step, Ticket has been validated and $this->_user has been set,
+
+        phpCAS::traceEnd($result);
+        return $result;
+    }
+
+
+    /**
+     * This method will parse the DOM and pull out the attributes from the XML
+     * payload and put them into an array, then put the array into the session.
+     *
+     * @param string $success_elements payload of the response
+     *
+     * @return bool true when successfull, halt otherwise by calling
+     * CAS_Client::_authError().
+     */
+    private function _readExtraAttributesCas20($success_elements)
+    {
+        phpCAS::traceBegin();
+
+        $extra_attributes = array();
+
+        // "Jasig Style" Attributes:
+        //
+        // 	<cas:serviceResponse xmlns:cas='http://www.yale.edu/tp/cas'>
+        // 		<cas:authenticationSuccess>
+        // 			<cas:user>jsmith</cas:user>
+        // 			<cas:attributes>
+        // 				<cas:attraStyle>RubyCAS</cas:attraStyle>
+        // 				<cas:surname>Smith</cas:surname>
+        // 				<cas:givenName>John</cas:givenName>
+        // 				<cas:memberOf>CN=Staff,OU=Groups,DC=example,DC=edu</cas:memberOf>
+        // 				<cas:memberOf>CN=Spanish Department,OU=Departments,OU=Groups,DC=example,DC=edu</cas:memberOf>
+        // 			</cas:attributes>
+        // 			<cas:proxyGrantingTicket>PGTIOU-84678-8a9d2sfa23casd</cas:proxyGrantingTicket>
+        // 		</cas:authenticationSuccess>
+        // 	</cas:serviceResponse>
+        //
+        if ( $success_elements->item(0)->getElementsByTagName("attributes")->length != 0) {
+            $attr_nodes = $success_elements->item(0)->getElementsByTagName("attributes");
+            phpCas :: trace("Found nested jasig style attributes");
+            if ($attr_nodes->item(0)->hasChildNodes()) {
+                // Nested Attributes
+                foreach ($attr_nodes->item(0)->childNodes as $attr_child) {
+                    phpCas :: trace("Attribute [".$attr_child->localName."] = ".$attr_child->nodeValue);
+                    $this->_addAttributeToArray($extra_attributes, $attr_child->localName, $attr_child->nodeValue);
+                }
+            }
+        } else {
+            // "RubyCAS Style" attributes
+            //
+            // 	<cas:serviceResponse xmlns:cas='http://www.yale.edu/tp/cas'>
+            // 		<cas:authenticationSuccess>
+            // 			<cas:user>jsmith</cas:user>
+            //
+            // 			<cas:attraStyle>RubyCAS</cas:attraStyle>
+            // 			<cas:surname>Smith</cas:surname>
+            // 			<cas:givenName>John</cas:givenName>
+            // 			<cas:memberOf>CN=Staff,OU=Groups,DC=example,DC=edu</cas:memberOf>
+            // 			<cas:memberOf>CN=Spanish Department,OU=Departments,OU=Groups,DC=example,DC=edu</cas:memberOf>
+            //
+            // 			<cas:proxyGrantingTicket>PGTIOU-84678-8a9d2sfa23casd</cas:proxyGrantingTicket>
+            // 		</cas:authenticationSuccess>
+            // 	</cas:serviceResponse>
+            //
+            phpCas :: trace("Testing for rubycas style attributes");
+            $childnodes = $success_elements->item(0)->childNodes;
+            foreach ($childnodes as $attr_node) {
+                switch ($attr_node->localName) {
+                case 'user':
+                case 'proxies':
+                case 'proxyGrantingTicket':
+                    continue;
+                default:
+                    if (strlen(trim($attr_node->nodeValue))) {
+                        phpCas :: trace("Attribute [".$attr_node->localName."] = ".$attr_node->nodeValue);
+                        $this->_addAttributeToArray($extra_attributes, $attr_node->localName, $attr_node->nodeValue);
+                    }
+                }
+            }
+        }
+
+        // "Name-Value" attributes.
+        //
+        // Attribute format from these mailing list thread:
+        // http://jasig.275507.n4.nabble.com/CAS-attributes-and-how-they-appear-in-the-CAS-response-td264272.html
+        // Note: This is a less widely used format, but in use by at least two institutions.
+        //
+        // 	<cas:serviceResponse xmlns:cas='http://www.yale.edu/tp/cas'>
+        // 		<cas:authenticationSuccess>
+        // 			<cas:user>jsmith</cas:user>
+        //
+        // 			<cas:attribute name='attraStyle' value='Name-Value' />
+        // 			<cas:attribute name='surname' value='Smith' />
+        // 			<cas:attribute name='givenName' value='John' />
+        // 			<cas:attribute name='memberOf' value='CN=Staff,OU=Groups,DC=example,DC=edu' />
+        // 			<cas:attribute name='memberOf' value='CN=Spanish Department,OU=Departments,OU=Groups,DC=example,DC=edu' />
+        //
+        // 			<cas:proxyGrantingTicket>PGTIOU-84678-8a9d2sfa23casd</cas:proxyGrantingTicket>
+        // 		</cas:authenticationSuccess>
+        // 	</cas:serviceResponse>
+        //
+        if (!count($extra_attributes) && $success_elements->item(0)->getElementsByTagName("attribute")->length != 0) {
+            $attr_nodes = $success_elements->item(0)->getElementsByTagName("attribute");
+            $firstAttr = $attr_nodes->item(0);
+            if (!$firstAttr->hasChildNodes() && $firstAttr->hasAttribute('name') && $firstAttr->hasAttribute('value')) {
+                phpCas :: trace("Found Name-Value style attributes");
+                // Nested Attributes
+                foreach ($attr_nodes as $attr_node) {
+                    if ($attr_node->hasAttribute('name') && $attr_node->hasAttribute('value')) {
+                        phpCas :: trace("Attribute [".$attr_node->getAttribute('name')."] = ".$attr_node->getAttribute('value'));
+                        $this->_addAttributeToArray($extra_attributes, $attr_node->getAttribute('name'), $attr_node->getAttribute('value'));
+                    }
+                }
+            }
+        }
+
+        $this->setAttributes($extra_attributes);
+        phpCAS::traceEnd();
+        return true;
+    }
+
+    /**
+     * Add an attribute value to an array of attributes.
+     *
+     * @param array  &$attributeArray reference to array
+     * @param string $name            name of attribute
+     * @param string $value           value of attribute
+     *
+     * @return void
+     */
+    private function _addAttributeToArray(array &$attributeArray, $name, $value)
+    {
+        // If multiple attributes exist, add as an array value
+        if (isset($attributeArray[$name])) {
+            // Initialize the array with the existing value
+            if (!is_array($attributeArray[$name])) {
+                $existingValue = $attributeArray[$name];
+                $attributeArray[$name] = array($existingValue);
+            }
+
+            $attributeArray[$name][] = trim($value);
+        } else {
+            $attributeArray[$name] = trim($value);
+        }
+    }
+
+    /** @} */
+
+    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+    // XX                                                                    XX
+    // XX                               MISC                                 XX
+    // XX                                                                    XX
+    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+
+    /**
+     * @addtogroup internalMisc
+     * @{
+     */
+
+    // ########################################################################
+    //  URL
+    // ########################################################################
+    /**
+    * the URL of the current request (without any ticket CGI parameter). Written
+    * and read by CAS_Client::getURL().
+    *
+    * @hideinitializer
+    */
+    private $_url = '';
+
+
+    /**
+     * This method sets the URL of the current request
+     *
+     * @param string $url url to set for service
+     *
+     * @return void
+     */
+    public function setURL($url)
+    {
+        $this->_url = $url;
+    }
+
+    /**
+     * This method returns the URL of the current request (without any ticket
+     * CGI parameter).
+     *
+     * @return The URL
+     */
+    public function getURL()
+    {
+        phpCAS::traceBegin();
+        // the URL is built when needed only
+        if ( empty($this->_url) ) {
+            $final_uri = '';
+            // remove the ticket if present in the URL
+            $final_uri = ($this->_isHttps()) ? 'https' : 'http';
+            $final_uri .= '://';
+
+            $final_uri .= $this->_getServerUrl();
+            $request_uri	= explode('?', $_SERVER['REQUEST_URI'], 2);
+            $final_uri		.= $request_uri[0];
+
+            if (isset($request_uri[1]) && $request_uri[1]) {
+                $query_string= $this->_removeParameterFromQueryString('ticket', $request_uri[1]);
+
+                // If the query string still has anything left, append it to the final URI
+                if ($query_string !== '') {
+                    $final_uri	.= "?$query_string";
+                }
+            }
+
+            phpCAS::trace("Final URI: $final_uri");
+            $this->setURL($final_uri);
+        }
+        phpCAS::traceEnd($this->_url);
+        return $this->_url;
+    }
+
+
+    /**
+     * Try to figure out the server URL with possible Proxys / Ports etc.
+     *
+     * @return string Server URL with domain:port
+     */
+    private function _getServerUrl()
+    {
+        $server_url = '';
+//----- Debut ajout CI (ordre de recherche personnalise dans config/_config_cas.php) -----
+/*
+        if (!empty($_SERVER['HTTP_X_FORWARDED_HOST'])) {
+            // explode the host list separated by comma and use the first host
+            $hosts = explode(',', $_SERVER['HTTP_X_FORWARDED_HOST']);
+            $server_url = $hosts[0];
+        } else if (!empty($_SERVER['HTTP_X_FORWARDED_SERVER'])) {
+            $server_url = $_SERVER['HTTP_X_FORWARDED_SERVER'];
+        } else {
+            if (empty($_SERVER['SERVER_NAME'])) {
+                $server_url = $_SERVER['HTTP_HOST'];
+            } else {
+                $server_url = $_SERVER['SERVER_NAME'];
+            }
+        }
+*/
+		$server_url = cicas_url_host();
+//----- Fin ajout CI -----     
+        if (!strpos($server_url, ':')) {
+            if ( ($this->_isHttps() && $_SERVER['SERVER_PORT']!=443)
+                || (!$this->_isHttps() && $_SERVER['SERVER_PORT']!=80)
+            ) {
+                $server_url .= ':';
+                $server_url .= $_SERVER['SERVER_PORT'];
+            }
+        }
+        return $server_url;
+    }
+
+    /**
+     * This method checks to see if the request is secured via HTTPS
+     *
+     * @return bool true if https, false otherwise
+     */
+    private function _isHttps()
+    {
+        if ( isset($_SERVER['HTTPS']) && !empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] == 'on') {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Removes a parameter from a query string
+     *
+     * @param string $parameterName name of parameter
+     * @param string $queryString   query string
+     *
+     * @return string new query string
+     *
+     * @link http://stackoverflow.com/questions/1842681/regular-expression-to-remove-one-parameter-from-query-string
+     */
+    private function _removeParameterFromQueryString($parameterName, $queryString)
+    {
+        $parameterName	= preg_quote($parameterName);
+        return preg_replace("/&$parameterName(=[^&]*)?|^$parameterName(=[^&]*)?&?/", '', $queryString);
+    }
+
+    /**
+     * This method is used to append query parameters to an url. Since the url
+     * might already contain parameter it has to be detected and to build a proper
+     * URL
+     *
+     * @param string $url   base url to add the query params to
+     * @param string $query params in query form with & separated
+     *
+     * @return url with query params
+     */
+    private function _buildQueryUrl($url, $query)
+    {
+        $url .= (strstr($url, '?') === false) ? '?' : '&';
+        $url .= $query;
+        return $url;
+    }
+
+    /**
+     * Renaming the session
+     *
+     * @param string $ticket name of the ticket
+     *
+     * @return void
+     */
+    private function _renameSession($ticket)
+    {
+        phpCAS::traceBegin();
+        if ($this->getChangeSessionID()) {
+            if (!empty($this->_user)) {
+                $old_session = $_SESSION;
+                session_destroy();
+                // set up a new session, of name based on the ticket
+                $session_id = preg_replace('/[^a-zA-Z0-9\-]/', '', $ticket);
+                phpCAS :: trace("Session ID: ".$session_id);
+                session_id($session_id);
+                session_start();
+                phpCAS :: trace("Restoring old session vars");
+                $_SESSION = $old_session;
+            } else {
+                phpCAS :: error('Session should only be renamed after successfull authentication');
+            }
+        } else {
+            phpCAS :: trace("Skipping session rename since phpCAS is not handling the session.");
+        }
+        phpCAS::traceEnd();
+    }
+
+
+    // ########################################################################
+    //  AUTHENTICATION ERROR HANDLING
+    // ########################################################################
+    /**
+    * This method is used to print the HTML output when the user was not
+    * authenticated.
+    *
+    * @param string $failure      the failure that occured
+    * @param string $cas_url      the URL the CAS server was asked for
+    * @param bool   $no_response  the response from the CAS server (other
+    * parameters are ignored if true)
+    * @param bool   $bad_response bad response from the CAS server ($err_code
+    * and $err_msg ignored if true)
+    * @param string $cas_response the response of the CAS server
+    * @param int    $err_code     the error code given by the CAS server
+    * @param string $err_msg      the error message given by the CAS server
+    *
+    * @return void
+    */
+    private function _authError(
+        $failure,
+        $cas_url,
+        $no_response,
+        $bad_response='',
+        $cas_response='',
+        $err_code='',
+        $err_msg=''
+    ) {
+        phpCAS::traceBegin();
+        $lang = $this->getLangObj();
+        $this->printHTMLHeader($lang->getAuthenticationFailed());
+        printf($lang->getYouWereNotAuthenticated(), htmlentities($this->getURL()), $_SERVER['SERVER_ADMIN']);
+        phpCAS::trace('CAS URL: '.$cas_url);
+        phpCAS::trace('Authentication failure: '.$failure);
+        if ( $no_response ) {
+            phpCAS::trace('Reason: no response from the CAS server');
+        } else {
+            if ( $bad_response ) {
+                phpCAS::trace('Reason: bad response from the CAS server');
+            } else {
+                switch ($this->getServerVersion()) {
+                case CAS_VERSION_1_0:
+                    phpCAS::trace('Reason: CAS error');
+                    break;
+                case CAS_VERSION_2_0:
+                    if ( empty($err_code) ) {
+                        phpCAS::trace('Reason: no CAS error');
+                    } else {
+                        phpCAS::trace('Reason: ['.$err_code.'] CAS error: '.$err_msg);
+                    }
+                    break;
+                }
+            }
+            phpCAS::trace('CAS response: '.$cas_response);
+        }
+        $this->printHTMLFooter();
+        phpCAS::traceExit();
+        throw new CAS_GracefullTerminationException();
+    }
+
+    // ########################################################################
+    //  PGTIOU/PGTID and logoutRequest rebroadcasting
+    // ########################################################################
+
+    /**
+     * Boolean of whether to rebroadcast pgtIou/pgtId and logoutRequest, and
+     * array of the nodes.
+     */
+    private $_rebroadcast = false;
+    private $_rebroadcast_nodes = array();
+
+    /**
+     * Constants used for determining rebroadcast node type.
+     */
+    const HOSTNAME = 0;
+    const IP = 1;
+
+    /**
+     * Determine the node type from the URL.
+     *
+     * @param String $nodeURL The node URL.
+     *
+     * @return string hostname
+     *
+     */
+    private function _getNodeType($nodeURL)
+    {
+        phpCAS::traceBegin();
+        if (preg_match("/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/", $nodeURL)) {
+            phpCAS::traceEnd(self::IP);
+            return self::IP;
+        } else {
+            phpCAS::traceEnd(self::HOSTNAME);
+            return self::HOSTNAME;
+        }
+    }
+
+    /**
+     * Store the rebroadcast node for pgtIou/pgtId and logout requests.
+     *
+     * @param string $rebroadcastNodeUrl The rebroadcast node URL.
+     *
+     * @return void
+     */
+    public function addRebroadcastNode($rebroadcastNodeUrl)
+    {
+        // Store the rebroadcast node and set flag
+        $this->_rebroadcast = true;
+        $this->_rebroadcast_nodes[] = $rebroadcastNodeUrl;
+    }
+
+    /**
+     * An array to store extra rebroadcast curl options.
+     */
+    private $_rebroadcast_headers = array();
+
+    /**
+     * This method is used to add header parameters when rebroadcasting
+     * pgtIou/pgtId or logoutRequest.
+     *
+     * @param string $header Header to send when rebroadcasting.
+     *
+     * @return void
+     */
+    public function addRebroadcastHeader($header)
+    {
+        $this->_rebroadcast_headers[] = $header;
+    }
+
+    /**
+     * Constants used for determining rebroadcast type (logout or pgtIou/pgtId).
+     */
+    const LOGOUT = 0;
+    const PGTIOU = 1;
+
+    /**
+     * This method rebroadcasts logout/pgtIou requests. Can be LOGOUT,PGTIOU
+     *
+     * @param int $type type of rebroadcasting.
+     *
+     * @return void
+     */
+    private function _rebroadcast($type)
+    {
+        phpCAS::traceBegin();
+
+        $rebroadcast_curl_options = array(
+        CURLOPT_FAILONERROR => 1,
+        CURLOPT_FOLLOWLOCATION => 1,
+        CURLOPT_RETURNTRANSFER => 1,
+        CURLOPT_CONNECTTIMEOUT => 1,
+        CURLOPT_TIMEOUT => 4);
+
+        // Try to determine the IP address of the server
+        if (!empty($_SERVER['SERVER_ADDR'])) {
+            $ip = $_SERVER['SERVER_ADDR'];
+        } else if (!empty($_SERVER['LOCAL_ADDR'])) {
+            // IIS 7
+            $ip = $_SERVER['LOCAL_ADDR'];
+        }
+        // Try to determine the DNS name of the server
+        if (!empty($ip)) {
+            $dns = gethostbyaddr($ip);
+        }
+        $multiClassName = 'CAS_Request_CurlMultiRequest';
+        $multiRequest = new $multiClassName();
+
+        for ($i = 0; $i < sizeof($this->_rebroadcast_nodes); $i++) {
+            if ((($this->_getNodeType($this->_rebroadcast_nodes[$i]) == self::HOSTNAME) && !empty($dns) && (stripos($this->_rebroadcast_nodes[$i], $dns) === false)) || (($this->_getNodeType($this->_rebroadcast_nodes[$i]) == self::IP) && !empty($ip) && (stripos($this->_rebroadcast_nodes[$i], $ip) === false))) {
+                phpCAS::trace('Rebroadcast target URL: '.$this->_rebroadcast_nodes[$i].$_SERVER['REQUEST_URI']);
+                $className = $this->_requestImplementation;
+                $request = new $className();
+
+                $url = $this->_rebroadcast_nodes[$i].$_SERVER['REQUEST_URI'];
+                $request->setUrl($url);
+
+                if (count($this->_rebroadcast_headers)) {
+                    $request->addHeaders($this->_rebroadcast_headers);
+                }
+
+                $request->makePost();
+                if ($type == self::LOGOUT) {
+                    // Logout request
+                    $request->setPostBody('rebroadcast=false&logoutRequest='.$_POST['logoutRequest']);
+                } else if ($type == self::PGTIOU) {
+                    // pgtIou/pgtId rebroadcast
+                    $request->setPostBody('rebroadcast=false');
+                }
+
+                $request->setCurlOptions($rebroadcast_curl_options);
+
+                $multiRequest->addRequest($request);
+            } else {
+                phpCAS::trace('Rebroadcast not sent to self: '.$this->_rebroadcast_nodes[$i].' == '.(!empty($ip)?$ip:'').'/'.(!empty($dns)?$dns:''));
+            }
+        }
+        // We need at least 1 request
+        if ($multiRequest->getNumRequests() > 0) {
+            $multiRequest->send();
+        }
+        phpCAS::traceEnd();
+    }
+
+    /** @} */
+}
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/CAS/CookieJar.php spip/extensions/cicas/CAS/CookieJar.php
--- spip-ori/extensions/cicas/CAS/CookieJar.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/CookieJar.php	2013-04-05 11:06:41.169923140 +0200
@@ -0,0 +1,377 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/CookieJar.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * This class provides access to service cookies and handles parsing of response
+ * headers to pull out cookie values.
+ *
+ * @class    CAS_CookieJar
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+class CAS_CookieJar
+{
+
+    private $_cookies;
+
+    /**
+     * Create a new cookie jar by passing it a reference to an array in which it
+     * should store cookies.
+     *
+     * @param array &$storageArray Array to store cookies
+     *
+     * @return void
+     */
+    public function __construct (array &$storageArray)
+    {
+        $this->_cookies =& $storageArray;
+    }
+
+    /**
+     * Store cookies for a web service request.
+     * Cookie storage is based on RFC 2965: http://www.ietf.org/rfc/rfc2965.txt
+     *
+     * @param string $request_url      The URL that generated the response headers.
+     * @param array  $response_headers An array of the HTTP response header strings.
+     *
+     * @return void
+     *
+     * @access private
+     */
+    public function storeCookies ($request_url, $response_headers)
+    {
+        $urlParts = parse_url($request_url);
+        $defaultDomain = $urlParts['host'];
+
+        $cookies = $this->parseCookieHeaders($response_headers, $defaultDomain);
+
+        // var_dump($cookies);
+        foreach ($cookies as $cookie) {
+            // Enforce the same-origin policy by verifying that the cookie
+            // would match the url that is setting it
+            if (!$this->cookieMatchesTarget($cookie, $urlParts)) {
+                continue;
+            }
+
+            // store the cookie
+            $this->storeCookie($cookie);
+
+            phpCAS::trace($cookie['name'].' -> '.$cookie['value']);
+        }
+    }
+
+    /**
+     * Retrieve cookies applicable for a web service request.
+     * Cookie applicability is based on RFC 2965: http://www.ietf.org/rfc/rfc2965.txt
+     *
+     * @param string $request_url The url that the cookies will be for.
+     *
+     * @return array An array containing cookies. E.g. array('name' => 'val');
+     *
+     * @access private
+     */
+    public function getCookies ($request_url)
+    {
+        if (!count($this->_cookies)) {
+            return array();
+        }
+
+        // If our request URL can't be parsed, no cookies apply.
+        $target = parse_url($request_url);
+        if ($target === false) {
+            return array();
+        }
+
+        $this->expireCookies();
+
+        $matching_cookies = array();
+        foreach ($this->_cookies as $key => $cookie) {
+            if ($this->cookieMatchesTarget($cookie, $target)) {
+                $matching_cookies[$cookie['name']] = $cookie['value'];
+            }
+        }
+        return $matching_cookies;
+    }
+
+
+    /**
+     * Parse Cookies without PECL
+     * From the comments in http://php.net/manual/en/function.http-parse-cookie.php
+     *
+     * @param array  $header        array of header lines.
+     * @param string $defaultDomain The domain to use if none is specified in
+     * the cookie.
+     *
+     * @return array of cookies
+     */
+    protected function parseCookieHeaders( $header, $defaultDomain )
+    {
+        phpCAS::traceBegin();
+        $cookies = array();
+        foreach ( $header as $line ) {
+            if ( preg_match('/^Set-Cookie2?: /i', $line)) {
+                $cookies[] = $this->parseCookieHeader($line, $defaultDomain);
+            }
+        }
+
+        phpCAS::traceEnd($cookies);
+        return $cookies;
+    }
+
+    /**
+     * Parse a single cookie header line.
+     *
+     * Based on RFC2965 http://www.ietf.org/rfc/rfc2965.txt
+     *
+     * @param string $line          The header line.
+     * @param string $defaultDomain The domain to use if none is specified in
+     * the cookie.
+     *
+     * @return array
+     */
+    protected function parseCookieHeader ($line, $defaultDomain)
+    {
+        if (!$defaultDomain) {
+            throw new CAS_InvalidArgumentException('$defaultDomain was not provided.');
+        }
+
+        // Set our default values
+        $cookie = array(
+            'domain' => $defaultDomain,
+            'path' => '/',
+            'secure' => false,
+        );
+
+        $line = preg_replace('/^Set-Cookie2?: /i', '', trim($line));
+
+        // trim any trailing semicolons.
+        $line = trim($line, ';');
+
+        phpCAS::trace("Cookie Line: $line");
+
+        // This implementation makes the assumption that semicolons will not
+        // be present in quoted attribute values. While attribute values that
+        // contain semicolons are allowed by RFC2965, they are hopefully rare
+        // enough to ignore for our purposes. Most browsers make the same
+        // assumption.
+        $attributeStrings = explode(';', $line);
+
+        foreach ( $attributeStrings as $attributeString ) {
+            // split on the first equals sign and use the rest as value
+            $attributeParts = explode('=', $attributeString, 2);
+
+            $attributeName = trim($attributeParts[0]);
+            $attributeNameLC = strtolower($attributeName);
+
+            if (isset($attributeParts[1])) {
+                $attributeValue = trim($attributeParts[1]);
+                // Values may be quoted strings.
+                if (strpos($attributeValue, '"') === 0) {
+                    $attributeValue = trim($attributeValue, '"');
+                    // unescape any escaped quotes:
+                    $attributeValue = str_replace('\"', '"', $attributeValue);
+                }
+            } else {
+                $attributeValue = null;
+            }
+
+            switch ($attributeNameLC) {
+            case 'expires':
+                $cookie['expires'] = strtotime($attributeValue);
+                break;
+            case 'max-age':
+                $cookie['max-age'] = (int)$attributeValue;
+                // Set an expiry time based on the max-age
+                if ($cookie['max-age']) {
+                    $cookie['expires'] = time() + $cookie['max-age'];
+                } else {
+                    // If max-age is zero, then the cookie should be removed
+                    // imediately so set an expiry before now.
+                    $cookie['expires'] = time() - 1;
+                }
+                break;
+            case 'secure':
+                $cookie['secure'] = true;
+                break;
+            case 'domain':
+            case 'path':
+            case 'port':
+            case 'version':
+            case 'comment':
+            case 'commenturl':
+            case 'discard':
+            case 'httponly':
+                $cookie[$attributeNameLC] = $attributeValue;
+                break;
+            default:
+                $cookie['name'] = $attributeName;
+                $cookie['value'] = $attributeValue;
+            }
+        }
+
+        return $cookie;
+    }
+
+    /**
+     * Add, update, or remove a cookie.
+     *
+     * @param array $cookie A cookie array as created by parseCookieHeaders()
+     *
+     * @return void
+     *
+     * @access protected
+     */
+    protected function storeCookie ($cookie)
+    {
+        // Discard any old versions of this cookie.
+        $this->discardCookie($cookie);
+        $this->_cookies[] = $cookie;
+
+    }
+
+    /**
+     * Discard an existing cookie
+     *
+     * @param array $cookie An cookie
+     *
+     * @return void
+     *
+     * @access protected
+     */
+    protected function discardCookie ($cookie)
+    {
+        if (!isset($cookie['domain'])
+            || !isset($cookie['path'])
+            || !isset($cookie['path'])
+        ) {
+            throw new CAS_InvalidArgumentException('Invalid Cookie array passed.');
+        }
+
+        foreach ($this->_cookies as $key => $old_cookie) {
+            if ( $cookie['domain'] == $old_cookie['domain']
+                && $cookie['path'] == $old_cookie['path']
+                && $cookie['name'] == $old_cookie['name']
+            ) {
+                unset($this->_cookies[$key]);
+            }
+        }
+    }
+
+    /**
+     * Go through our stored cookies and remove any that are expired.
+     *
+     * @return void
+     *
+     * @access protected
+     */
+    protected function expireCookies ()
+    {
+        foreach ($this->_cookies as $key => $cookie) {
+            if (isset($cookie['expires']) && $cookie['expires'] < time()) {
+                unset($this->_cookies[$key]);
+            }
+        }
+    }
+
+    /**
+     * Answer true if cookie is applicable to a target.
+     *
+     * @param array $cookie An array of cookie attributes.
+     * @param array $target An array of URL attributes as generated by parse_url().
+     *
+     * @return bool
+     *
+     * @access private
+     */
+    protected function cookieMatchesTarget ($cookie, $target)
+    {
+        if (!is_array($target)) {
+            throw new CAS_InvalidArgumentException('$target must be an array of URL attributes as generated by parse_url().');
+        }
+        if (!isset($target['host'])) {
+            throw new CAS_InvalidArgumentException('$target must be an array of URL attributes as generated by parse_url().');
+        }
+
+        // Verify that the scheme matches
+        if ($cookie['secure'] && $target['scheme'] != 'https') {
+            return false;
+        }
+
+        // Verify that the host matches
+        // Match domain and mulit-host cookies
+        if (strpos($cookie['domain'], '.') === 0) {
+            // .host.domain.edu cookies are valid for host.domain.edu
+            if (substr($cookie['domain'], 1) == $target['host']) {
+                // continue with other checks
+            } else {
+                // non-exact host-name matches.
+                // check that the target host a.b.c.edu is within .b.c.edu
+                $pos = strripos($target['host'], $cookie['domain']);
+                if (!$pos) {
+                    return false;
+                }
+                // verify that the cookie domain is the last part of the host.
+                if ($pos + strlen($cookie['domain']) != strlen($target['host'])) {
+                    return false;
+                }
+                // verify that the host name does not contain interior dots as per
+                // RFC 2965 section 3.3.2  Rejecting Cookies
+                // http://www.ietf.org/rfc/rfc2965.txt
+                $hostname = substr($target['host'], 0, $pos);
+                if (strpos($hostname, '.') !== false) {
+                    return false;
+                }
+            }
+        } else {
+            // If the cookie host doesn't begin with '.', the host must case-insensitive
+            // match exactly
+            if (strcasecmp($target['host'], $cookie['domain']) !== 0) {
+                return false;
+            }
+        }
+
+        // Verify that the port matches
+        if (isset($cookie['ports']) && !in_array($target['port'], $cookie['ports'])) {
+            return false;
+        }
+
+        // Verify that the path matches
+        if (strpos($target['path'], $cookie['path']) !== 0) {
+            return false;
+        }
+
+        return true;
+    }
+
+}
+
+?>
diff -rNU5 spip-ori/extensions/cicas/CAS/Exception.php spip/extensions/cicas/CAS/Exception.php
--- spip-ori/extensions/cicas/CAS/Exception.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Exception.php	2013-04-05 11:06:41.169923140 +0200
@@ -0,0 +1,59 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Exception.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * A root exception interface for all exceptions in phpCAS.
+ *
+ * All exceptions thrown in phpCAS should implement this interface to allow them
+ * to be caught as a category by clients. Each phpCAS exception should extend
+ * an appropriate SPL exception class that best fits its type.
+ *
+ * For example, an InvalidArgumentException in phpCAS should be defined as
+ *
+ *		class CAS_InvalidArgumentException
+ *			extends InvalidArgumentException
+ *			implements CAS_Exception
+ *		{ }
+ *
+ * This definition allows the CAS_InvalidArgumentException to be caught as either
+ * an InvalidArgumentException or as a CAS_Exception.
+ *
+ * @class    CAS_Exception
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ *
+ */
+interface CAS_Exception
+{
+
+}
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/CAS/GracefullTerminationException.php spip/extensions/cicas/CAS/GracefullTerminationException.php
--- spip-ori/extensions/cicas/CAS/GracefullTerminationException.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/GracefullTerminationException.php	2013-04-05 11:06:41.169923140 +0200
@@ -0,0 +1,86 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/GracefullTerminationException.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Joachim Fritschi <jfritschi@freenet.de>
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * An exception for terminatinating execution or to throw for unit testing
+ *
+ * @class     CAS_GracefullTerminationException.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Joachim Fritschi <jfritschi@freenet.de>
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+class CAS_GracefullTerminationException
+extends RuntimeException
+implements CAS_Exception
+{
+
+    /**
+     * Test if exceptions should be thrown or if we should just exit.
+     * In production usage we want to just exit cleanly when prompting the user
+     * for a redirect without filling the error logs with uncaught exceptions.
+     * In unit testing scenarios we cannot exit or we won't be able to continue
+     * with our tests.
+     *
+     * @param string $message Message Text
+     * @param string $code    Error code
+     *
+     * @return void
+     */
+    public function __construct ($message = 'Terminate Gracefully', $code = 0)
+    {
+        // Exit cleanly to avoid filling up the logs with uncaught exceptions.
+        if (self::$_exitWhenThrown) {
+            exit;
+        } else {
+            // Throw exceptions to allow unit testing to continue;
+            parent::__construct($message, $code);
+        }
+    }
+
+    private static $_exitWhenThrown = true;
+    /**
+    * Force phpcas to thow Exceptions instead of calling exit()
+    * Needed for unit testing. Generally shouldn't be used in production due to
+    * an increase in Apache error logging if CAS_GracefulTerminiationExceptions
+    * are not caught and handled.
+    *
+    * @return void
+    */
+    public static function throwInsteadOfExiting()
+    {
+        self::$_exitWhenThrown = false;
+    }
+
+}
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/CAS/InvalidArgumentException.php spip/extensions/cicas/CAS/InvalidArgumentException.php
--- spip-ori/extensions/cicas/CAS/InvalidArgumentException.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/InvalidArgumentException.php	2013-04-05 11:06:41.169923140 +0200
@@ -0,0 +1,46 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/InvalidArgumentException.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * Exception that denotes invalid arguments were passed.
+ *
+ * @class    CAS_InvalidArgumentException
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+class CAS_InvalidArgumentException
+extends InvalidArgumentException
+implements CAS_Exception
+{
+
+}
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/CAS/Languages/Catalan.php spip/extensions/cicas/CAS/Languages/Catalan.php
--- spip-ori/extensions/cicas/CAS/Languages/Catalan.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Languages/Catalan.php	2013-04-05 11:06:41.169923140 +0200
@@ -0,0 +1,114 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Language/Catalan.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Iván-Benjamín García Torà <ivaniclixx@gmail.com>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * Catalan language class
+ *
+ * @class    CAS_Languages_Catalan
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Iván-Benjamín García Torà <ivaniclixx@gmail.com>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ *
+ * @sa @link internalLang Internationalization @endlink
+ * @ingroup internalLang
+ */
+class CAS_Languages_Catalan implements CAS_Languages_LanguageInterface
+{
+    /**
+    * Get the using server string
+    *
+    * @return string using server
+    */
+    public function getUsingServer()
+    {
+        return 'usant servidor';
+    }
+
+    /**
+    * Get authentication wanted string
+    *
+    * @return string authentication wanted
+    */
+    public function getAuthenticationWanted()
+    {
+        return 'Autentificació CAS necessària!';
+    }
+
+    /**
+    * Get logout string
+    *
+    * @return string logout
+    */
+    public function getLogout()
+    {
+        return 'Sortida de CAS necessària!';
+    }
+
+    /**
+    * Get the should have been redirected string
+    *
+    * @return string should habe been redirected
+    */
+    public function getShouldHaveBeenRedirected()
+    {
+        return 'Ja hauria d\ haver estat redireccionat al servidor CAS. Feu click <a href="%s">aquí</a> per a continuar.';
+    }
+
+    /**
+    * Get authentication failed string
+    *
+    * @return string authentication failed
+    */
+    public function getAuthenticationFailed()
+    {
+        return 'Autentificació CAS fallida!';
+    }
+
+    /**
+    * Get the your were not authenticated string
+    *
+    * @return string not authenticated
+    */
+    public function getYouWereNotAuthenticated()
+    {
+        return '<p>No estàs autentificat.</p><p>Pots tornar a intentar-ho fent click <a href="%s">aquí</a>.</p><p>Si el problema persisteix hauría de contactar amb l\'<a href="mailto:%s">administrador d\'aquest llocc</a>.</p>';
+    }
+
+    /**
+    * Get the service unavailable string
+    *
+    * @return string service unavailable
+    */
+    public function getServiceUnavailable()
+    {
+        return 'El servei `<b>%s</b>\' no està disponible (<b>%s</b>).';
+    }
+}
diff -rNU5 spip-ori/extensions/cicas/CAS/Languages/English.php spip/extensions/cicas/CAS/Languages/English.php
--- spip-ori/extensions/cicas/CAS/Languages/English.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Languages/English.php	2013-04-05 11:06:41.169923140 +0200
@@ -0,0 +1,114 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Language/English.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Pascal Aubry <pascal.aubry@univ-rennes1.fr>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * English language class
+ *
+ * @class    CAS_Languages_English
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Pascal Aubry <pascal.aubry@univ-rennes1.fr>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ *
+ * @sa @link internalLang Internationalization @endlink
+ * @ingroup internalLang
+ */
+class CAS_Languages_English implements CAS_Languages_LanguageInterface
+{
+    /**
+     * Get the using server string
+     *
+     * @return string using server
+     */
+    public function getUsingServer()
+    {
+        return 'using server';
+    }
+
+    /**
+     * Get authentication wanted string
+     *
+     * @return string authentication wanted
+     */
+    public function getAuthenticationWanted()
+    {
+        return 'CAS Authentication wanted!';
+    }
+
+    /**
+     * Get logout string
+     *
+     * @return string logout
+     */
+    public function getLogout()
+    {
+        return 'CAS logout wanted!';
+    }
+
+    /**
+     * Get the should have been redirected string
+     *
+     * @return string should habe been redirected
+     */
+    public function getShouldHaveBeenRedirected()
+    {
+        return 'You should already have been redirected to the CAS server. Click <a href="%s">here</a> to continue.';
+    }
+
+    /**
+    * Get authentication failed string
+    *
+    * @return string authentication failed
+    */
+    public function getAuthenticationFailed()
+    {
+        return 'CAS Authentication failed!';
+    }
+
+    /**
+    * Get the your were not authenticated string
+    *
+    * @return string not authenticated
+    */
+    public function getYouWereNotAuthenticated()
+    {
+        return '<p>You were not authenticated.</p><p>You may submit your request again by clicking <a href="%s">here</a>.</p><p>If the problem persists, you may contact <a href="mailto:%s">the administrator of this site</a>.</p>';
+    }
+
+    /**
+    * Get the service unavailable string
+    *
+    * @return string service unavailable
+    */
+    public function getServiceUnavailable()
+    {
+        return 'The service `<b>%s</b>\' is not available (<b>%s</b>).';
+    }
+}
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/CAS/Languages/French.php spip/extensions/cicas/CAS/Languages/French.php
--- spip-ori/extensions/cicas/CAS/Languages/French.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Languages/French.php	2013-04-05 11:06:41.169923140 +0200
@@ -0,0 +1,116 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Language/French.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Pascal Aubry <pascal.aubry@univ-rennes1.fr>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * French language class
+ *
+ * @class    CAS_Languages_French
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Pascal Aubry <pascal.aubry@univ-rennes1.fr>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ *
+ * @sa @link internalLang Internationalization @endlink
+ * @ingroup internalLang
+ */
+class CAS_Languages_French implements CAS_Languages_LanguageInterface
+{
+    /**
+     * Get the using server string
+     *
+     * @return string using server
+     */
+    public function getUsingServer()
+    {
+        return 'utilisant le serveur';
+    }
+
+    /**
+     * Get authentication wanted string
+     *
+     * @return string authentication wanted
+     */
+    public function getAuthenticationWanted()
+    {
+        return 'Authentication CAS n�cessaire&nbsp;!';
+    }
+
+    /**
+     * Get logout string
+     *
+     * @return string logout
+     */
+    public function getLogout()
+    {
+        return 'D�connexion demand�e&nbsp;!';
+    }
+
+    /**
+     * Get the should have been redirected string
+     *
+     * @return string should habe been redirected
+     */
+    public function getShouldHaveBeenRedirected()
+    {
+        return 'Vous auriez du etre redirig�(e) vers le serveur CAS. Cliquez <a href="%s">ici</a> pour continuer.';
+    }
+
+    /**
+     * Get authentication failed string
+     *
+     * @return string authentication failed
+     */
+    public function getAuthenticationFailed()
+    {
+        return 'Authentification CAS infructueuse&nbsp;!';
+    }
+
+    /**
+     * Get the your were not authenticated string
+     *
+     * @return string not authenticated
+     */
+    public function getYouWereNotAuthenticated()
+    {
+        return '<p>Vous n\'avez pas �t� authentifi�(e).</p><p>Vous pouvez soumettre votre requete � nouveau en cliquant <a href="%s">ici</a>.</p><p>Si le probl�me persiste, vous pouvez contacter <a href="mailto:%s">l\'administrateur de ce site</a>.</p>';
+    }
+
+    /**
+     * Get the service unavailable string
+     *
+     * @return string service unavailable
+     */
+    public function getServiceUnavailable()
+    {
+        return 'Le service `<b>%s</b>\' est indisponible (<b>%s</b>)';
+    }
+}
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/CAS/Languages/German.php spip/extensions/cicas/CAS/Languages/German.php
--- spip-ori/extensions/cicas/CAS/Languages/German.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Languages/German.php	2013-04-05 11:06:41.169923140 +0200
@@ -0,0 +1,116 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Language/German.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Henrik Genssen <hg@mediafactory.de>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * German language class
+ *
+ * @class    CAS_Languages_German
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Henrik Genssen <hg@mediafactory.de>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ *
+ * @sa @link internalLang Internationalization @endlink
+ * @ingroup internalLang
+ */
+class CAS_Languages_German implements CAS_Languages_LanguageInterface
+{
+    /**
+     * Get the using server string
+     *
+     * @return string using server
+     */
+    public function getUsingServer()
+    {
+        return 'via Server';
+    }
+
+    /**
+     * Get authentication wanted string
+     *
+     * @return string authentication wanted
+     */
+    public function getAuthenticationWanted()
+    {
+        return 'CAS Authentifizierung erforderlich!';
+    }
+
+    /**
+     * Get logout string
+     *
+     * @return string logout
+     */
+    public function getLogout()
+    {
+        return 'CAS Abmeldung!';
+    }
+
+    /**
+     * Get the should have been redirected string
+     *
+     * @return string should habe been redirected
+     */
+    public function getShouldHaveBeenRedirected()
+    {
+        return 'eigentlich h&auml;ten Sie zum CAS Server weitergeleitet werden sollen. Dr&uuml;cken Sie <a href="%s">hier</a> um fortzufahren.';
+    }
+
+    /**
+     * Get authentication failed string
+     *
+     * @return string authentication failed
+     */
+    public function getAuthenticationFailed()
+    {
+        return 'CAS Anmeldung fehlgeschlagen!';
+    }
+
+    /**
+     * Get the your were not authenticated string
+     *
+     * @return string not authenticated
+     */
+    public function getYouWereNotAuthenticated()
+    {
+        return '<p>Sie wurden nicht angemeldet.</p><p>Um es erneut zu versuchen klicken Sie <a href="%s">hier</a>.</p><p>Wenn das Problem bestehen bleibt, kontkatieren Sie den <a href="mailto:%s">Administrator</a> dieser Seite.</p>';
+    }
+
+    /**
+     * Get the service unavailable string
+     *
+     * @return string service unavailable
+     */
+    public function getServiceUnavailable()
+    {
+        return 'Der Dienst `<b>%s</b>\' ist nicht verf&uuml;gbar (<b>%s</b>).';
+    }
+}
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/CAS/Languages/Greek.php spip/extensions/cicas/CAS/Languages/Greek.php
--- spip-ori/extensions/cicas/CAS/Languages/Greek.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Languages/Greek.php	2013-04-05 11:06:41.173923140 +0200
@@ -0,0 +1,115 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Language/Greek.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Vangelis Haniotakis <haniotak@ucnet.uoc.gr>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * Greek language class
+ *
+ * @class    CAS_Languages_Greek
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Vangelis Haniotakis <haniotak@ucnet.uoc.gr>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ *
+ * @sa @link internalLang Internationalization @endlink
+ * @ingroup internalLang
+ */
+class CAS_Languages_Greek implements CAS_Languages_LanguageInterface
+{
+    /**
+     * Get the using server string
+     *
+     * @return string using server
+     */
+    public function getUsingServer()
+    {
+        return '��������������� � ������������';
+    }
+
+    /**
+     * Get authentication wanted string
+     *
+     * @return string authentication wanted
+     */
+    public function getAuthenticationWanted()
+    {
+        return '���������� � ����������� CAS!';
+    }
+
+    /**
+     * Get logout string
+     *
+     * @return string logout
+     */
+    public function getLogout()
+    {
+        return '���������� � ���������� ��� CAS!';
+    }
+
+    /**
+     * Get the should have been redirected string
+     *
+     * @return string should habe been redirected
+     */
+    public function getShouldHaveBeenRedirected()
+    {
+        return '�� ������ �� ������ �������������� ���� ����������� CAS. ����� ���� <a href="%s">���</a> ��� �� ����������.';
+    }
+
+    /**
+     * Get authentication failed string
+     *
+     * @return string authentication failed
+     */
+    public function getAuthenticationFailed()
+    {
+        return '� ����������� CAS �������!';
+    }
+
+    /**
+     * Get the your were not authenticated string
+     *
+     * @return string not authenticated
+     */
+    public function getYouWereNotAuthenticated()
+    {
+        return '<p>��� ���������������.</p><p>�������� �� ����������������, �������� ���� <a href="%s">���</a>.</p><p>��� �� �������� ���������, ����� �� ����� �� ��� <a href="mailto:%s">�����������</a>.</p>';
+    }
+
+    /**
+     * Get the service unavailable string
+     *
+     * @return string service unavailable
+     */
+    public function getServiceUnavailable()
+    {
+        return '� �������� `<b>%s</b>\' ��� ����� ��������� (<b>%s</b>).';
+    }
+}
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/CAS/Languages/Japanese.php spip/extensions/cicas/CAS/Languages/Japanese.php
--- spip-ori/extensions/cicas/CAS/Languages/Japanese.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Languages/Japanese.php	2013-04-05 11:06:41.173923140 +0200
@@ -0,0 +1,113 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Language/Japanese.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   fnorif <fnorif@yahoo.co.jp>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * Japanese language class. Now Encoding is EUC-JP and LF
+ *
+ * @class    CAS_Languages_Japanese
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   fnorif <fnorif@yahoo.co.jp>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ *
+ **/
+class CAS_Languages_Japanese implements CAS_Languages_LanguageInterface
+{
+    /**
+     * Get the using server string
+     *
+     * @return string using server
+     */
+    public function getUsingServer()
+    {
+        return 'using server';
+    }
+
+    /**
+     * Get authentication wanted string
+     *
+     * @return string authentication wanted
+     */
+    public function getAuthenticationWanted()
+    {
+        return 'CAS�ˤ��ǧ�ڤ�Ԥ��ޤ�';
+    }
+
+    /**
+     * Get logout string
+     *
+     * @return string logout
+     */
+    public function getLogout()
+    {
+        return 'CAS����?�����Ȥ��ޤ�!';
+    }
+
+    /**
+     * Get the should have been redirected string
+     *
+     * @return string should habe been redirected
+     */
+    public function getShouldHaveBeenRedirected()
+    {
+        return 'CAS�����Ф˹Ԥ�ɬ�פ�����ޤ�����ưŪ��ž������ʤ����� <a href="%s">������</a> �򥯥�å�����³�Ԥ��ޤ��';
+    }
+
+    /**
+     * Get authentication failed string
+     *
+     * @return string authentication failed
+     */
+    public function getAuthenticationFailed()
+    {
+        return 'CAS�ˤ��ǧ�ڤ˼��Ԥ��ޤ���';
+    }
+
+    /**
+     * Get the your were not authenticated string
+     *
+     * @return string not authenticated
+     */
+    public function getYouWereNotAuthenticated()
+    {
+        return '<p>ǧ�ڤǤ��ޤ���Ǥ���.</p><p>�⤦���٥ꥯ�����Ȥ������������<a href="%s">������</a>�򥯥�å�.</p><p>���꤬��褷�ʤ����� <a href="mailto:%s">���Υ����Ȥδ����</a>���䤤��碌�Ƥ�������.</p>';
+    }
+
+    /**
+     * Get the service unavailable string
+     *
+     * @return string service unavailable
+     */
+    public function getServiceUnavailable()
+    {
+        return '�����ӥ� `<b>%s</b>\' �����ѤǤ��ޤ��� (<b>%s</b>).';
+    }
+}
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/CAS/Languages/LanguageInterface.php spip/extensions/cicas/CAS/Languages/LanguageInterface.php
--- spip-ori/extensions/cicas/CAS/Languages/LanguageInterface.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Languages/LanguageInterface.php	2013-04-05 11:06:41.173923140 +0200
@@ -0,0 +1,96 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Language/LanguageInterface.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Joachim Fritschi <jfritschi@freenet.de>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * Language Interface class for all internationalization files
+ *
+ * @class    CAS_Languages_LanguageInterface
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Joachim Fritschi <jfritschi@freenet.de>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ *
+ * @sa @link internalLang Internationalization @endlink
+ * @ingroup internalLang
+ */
+
+interface CAS_Languages_LanguageInterface
+{
+    /**
+     * Get the using server string
+     *
+     * @return string using server
+     */
+    public function getUsingServer();
+
+    /**
+     * Get authentication wanted string
+     *
+     * @return string authentication wanted
+     */
+    public function getAuthenticationWanted();
+
+    /**
+     * Get logout string
+     *
+     * @return string logout
+     */
+    public function getLogout();
+
+    /**
+     * Get the should have been redirected string
+     *
+     * @return string should habe been redirected
+     */
+    public function getShouldHaveBeenRedirected();
+
+    /**
+     * Get authentication failed string
+     *
+     * @return string authentication failed
+     */
+    public function getAuthenticationFailed();
+
+    /**
+     * Get the your were not authenticated string
+     *
+     * @return string not authenticated
+     */
+    public function getYouWereNotAuthenticated();
+
+    /**
+     * Get the service unavailable string
+     *
+     * @return string service unavailable
+     */
+    public function getServiceUnavailable();
+
+}
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/CAS/Languages/Spanish.php spip/extensions/cicas/CAS/Languages/Spanish.php
--- spip-ori/extensions/cicas/CAS/Languages/Spanish.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Languages/Spanish.php	2013-04-05 11:06:41.173923140 +0200
@@ -0,0 +1,117 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Language/Spanish.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Iván-Benjamín García Torà <ivaniclixx@gmail.com>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * Spanish language class
+ *
+ * @class    CAS_Languages_Spanish
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Iván-Benjamín García Torà <ivaniclixx@gmail.com>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ *
+
+ * @sa @link internalLang Internationalization @endlink
+ * @ingroup internalLang
+ */
+class CAS_Languages_Spanish implements CAS_Languages_LanguageInterface
+{
+
+    /**
+     * Get the using server string
+     *
+     * @return string using server
+     */
+    public function getUsingServer()
+    {
+        return 'usando servidor';
+    }
+
+    /**
+     * Get authentication wanted string
+     *
+     * @return string authentication wanted
+     */
+    public function getAuthenticationWanted()
+    {
+        return '¡Autentificación CAS necesaria!';
+    }
+
+    /**
+     * Get logout string
+     *
+     * @return string logout
+     */
+    public function getLogout()
+    {
+        return '¡Salida CAS necesaria!';
+    }
+
+    /**
+     * Get the should have been redirected string
+     *
+     * @return string should habe been redirected
+     */
+    public function getShouldHaveBeenRedirected()
+    {
+        return 'Ya debería haber sido redireccionado al servidor CAS. Haga click <a href="%s">aquí</a> para continuar.';
+    }
+
+    /**
+     * Get authentication failed string
+     *
+     * @return string authentication failed
+     */
+    public function getAuthenticationFailed()
+    {
+        return '¡Autentificación CAS fallida!';
+    }
+
+    /**
+     * Get the your were not authenticated string
+     *
+     * @return string not authenticated
+     */
+    public function getYouWereNotAuthenticated()
+    {
+        return '<p>No estás autentificado.</p><p>Puedes volver a intentarlo haciendo click <a href="%s">aquí</a>.</p><p>Si el problema persiste debería contactar con el <a href="mailto:%s">administrador de este sitio</a>.</p>';
+    }
+
+    /**
+     * Get the service unavailable string
+     *
+     * @return string service unavailable
+     */
+    public function getServiceUnavailable()
+    {
+        return 'El servicio `<b>%s</b>\' no está disponible (<b>%s</b>).';
+    }
+}
+?>
diff -rNU5 spip-ori/extensions/cicas/CAS/OutOfSequenceException.php spip/extensions/cicas/CAS/OutOfSequenceException.php
--- spip-ori/extensions/cicas/CAS/OutOfSequenceException.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/OutOfSequenceException.php	2013-04-05 11:06:41.173923140 +0200
@@ -0,0 +1,49 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/OutOfSequenceException.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * This class defines Exceptions that should be thrown when the sequence of
+ * operations is invalid. Examples are:
+ *		- Requesting the response before executing a request.
+ *		- Changing the URL of a request after executing the request.
+ *
+ * @class    CAS_OutOfSequenceException
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+class CAS_OutOfSequenceException
+extends BadMethodCallException
+implements CAS_Exception
+{
+
+}
diff -rNU5 spip-ori/extensions/cicas/CAS/PGTStorage/AbstractStorage.php spip/extensions/cicas/CAS/PGTStorage/AbstractStorage.php
--- spip-ori/extensions/cicas/CAS/PGTStorage/AbstractStorage.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/PGTStorage/AbstractStorage.php	2013-04-05 11:06:41.173923140 +0200
@@ -0,0 +1,220 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/PGTStorage/AbstractStorage.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Pascal Aubry <pascal.aubry@univ-rennes1.fr>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * Basic class for PGT storage
+ * The CAS_PGTStorage_AbstractStorage class is a generic class for PGT storage.
+ * This class should not be instanciated itself but inherited by specific PGT
+ * storage classes.
+ *
+ * @class CAS_PGTStorage_AbstractStorage
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Pascal Aubry <pascal.aubry@univ-rennes1.fr>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ *
+ * @ingroup internalPGTStorage
+ */
+
+abstract class CAS_PGTStorage_AbstractStorage
+{
+    /**
+     * @addtogroup internalPGTStorage
+     * @{
+     */
+
+    // ########################################################################
+    //  CONSTRUCTOR
+    // ########################################################################
+
+    /**
+     * The constructor of the class, should be called only by inherited classes.
+     *
+     * @param CAS_Client $cas_parent the CAS _client instance that creates the
+     * current object.
+     *
+     * @return void
+     *
+     * @protected
+     */
+    function __construct($cas_parent)
+    {
+        phpCAS::traceBegin();
+        if ( !$cas_parent->isProxy() ) {
+            phpCAS::error('defining PGT storage makes no sense when not using a CAS proxy');
+        }
+        phpCAS::traceEnd();
+    }
+
+    // ########################################################################
+    //  DEBUGGING
+    // ########################################################################
+
+    /**
+     * This virtual method returns an informational string giving the type of storage
+     * used by the object (used for debugging purposes).
+     *
+     * @return void
+     *
+     * @public
+     */
+    function getStorageType()
+    {
+        phpCAS::error(__CLASS__.'::'.__FUNCTION__.'() should never be called');
+    }
+
+    /**
+     * This virtual method returns an informational string giving informations on the
+     * parameters of the storage.(used for debugging purposes).
+     *
+     * @return void
+     *
+     * @public
+     */
+    function getStorageInfo()
+    {
+        phpCAS::error(__CLASS__.'::'.__FUNCTION__.'() should never be called');
+    }
+
+    // ########################################################################
+    //  ERROR HANDLING
+    // ########################################################################
+
+    /**
+     * string used to store an error message. Written by
+     * PGTStorage::setErrorMessage(), read by PGTStorage::getErrorMessage().
+     *
+     * @hideinitializer
+     * @deprecated not used.
+     */
+    var $_error_message=false;
+
+    /**
+     * This method sets en error message, which can be read later by
+     * PGTStorage::getErrorMessage().
+     *
+     * @param string $error_message an error message
+     *
+     * @return void
+     *
+     * @deprecated not used.
+     */
+    function setErrorMessage($error_message)
+    {
+        $this->_error_message = $error_message;
+    }
+
+    /**
+     * This method returns an error message set by PGTStorage::setErrorMessage().
+     *
+     * @return an error message when set by PGTStorage::setErrorMessage(), FALSE
+     * otherwise.
+     *
+     * @deprecated not used.
+     */
+    function getErrorMessage()
+    {
+        return $this->_error_message;
+    }
+
+    // ########################################################################
+    //  INITIALIZATION
+    // ########################################################################
+
+    /**
+     * a boolean telling if the storage has already been initialized. Written by
+     * PGTStorage::init(), read by PGTStorage::isInitialized().
+     *
+     * @hideinitializer
+     */
+    var $_initialized = false;
+
+    /**
+     * This method tells if the storage has already been intialized.
+     *
+     * @return a boolean
+     *
+     * @protected
+     */
+    function isInitialized()
+    {
+        return $this->_initialized;
+    }
+
+    /**
+     * This virtual method initializes the object.
+     *
+     * @return void
+     */
+    function init()
+    {
+        $this->_initialized = true;
+    }
+
+    // ########################################################################
+    //  PGT I/O
+    // ########################################################################
+
+    /**
+     * This virtual method stores a PGT and its corresponding PGT Iuo.
+     *
+     * @param string $pgt     the PGT
+     * @param string $pgt_iou the PGT iou
+     *
+     * @return void
+     *
+     * @note Should never be called.
+     *
+     */
+    function write($pgt,$pgt_iou)
+    {
+        phpCAS::error(__CLASS__.'::'.__FUNCTION__.'() should never be called');
+    }
+
+    /**
+     * This virtual method reads a PGT corresponding to a PGT Iou and deletes
+     * the corresponding storage entry.
+     *
+     * @param string $pgt_iou the PGT iou
+     *
+     * @return void
+     *
+     * @note Should never be called.
+     */
+    function read($pgt_iou)
+    {
+        phpCAS::error(__CLASS__.'::'.__FUNCTION__.'() should never be called');
+    }
+
+    /** @} */
+
+}
+
+?>
diff -rNU5 spip-ori/extensions/cicas/CAS/PGTStorage/Db.php spip/extensions/cicas/CAS/PGTStorage/Db.php
--- spip-ori/extensions/cicas/CAS/PGTStorage/Db.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/PGTStorage/Db.php	2013-04-05 11:06:41.173923140 +0200
@@ -0,0 +1,429 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/PGTStorage/Db.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Daniel Frett <daniel.frett@gmail.com>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+define('CAS_PGT_STORAGE_DB_DEFAULT_TABLE', 'cas_pgts');
+
+/**
+ * Basic class for PGT database storage
+ * The CAS_PGTStorage_Db class is a class for PGT database storage.
+ *
+ * @class    CAS_PGTStorage_Db
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Daniel Frett <daniel.frett@gmail.com>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ *
+ * @ingroup internalPGTStorageDb
+ */
+
+class CAS_PGTStorage_Db extends CAS_PGTStorage_AbstractStorage
+{
+    /**
+     * @addtogroup internalCAS_PGTStorageDb
+     * @{
+     */
+
+    /**
+     * the PDO object to use for database interactions
+     */
+    private $_pdo;
+
+    /**
+     * This method returns the PDO object to use for database interactions.
+     *
+     * @return the PDO object
+     */
+    private function _getPdo()
+    {
+        return $this->_pdo;
+    }
+
+    /**
+     * database connection options to use when creating a new PDO object
+     */
+    private $_dsn;
+    private $_username;
+    private $_password;
+    private $_table_options;
+
+    /**
+     * the table to use for storing/retrieving pgt's
+     */
+    private $_table;
+
+    /**
+     * This method returns the table to use when storing/retrieving PGT's
+     *
+     * @return the name of the pgt storage table.
+     */
+    private function _getTable()
+    {
+        return $this->_table;
+    }
+
+    // ########################################################################
+    //  DEBUGGING
+    // ########################################################################
+
+    /**
+     * This method returns an informational string giving the type of storage
+     * used by the object (used for debugging purposes).
+     *
+     * @return an informational string.
+     */
+    public function getStorageType()
+    {
+        return "db";
+    }
+
+    /**
+     * This method returns an informational string giving informations on the
+     * parameters of the storage.(used for debugging purposes).
+     *
+     * @return an informational string.
+     * @public
+     */
+    public function getStorageInfo()
+    {
+        return 'table=`'.$this->_getTable().'\'';
+    }
+
+    // ########################################################################
+    //  CONSTRUCTOR
+    // ########################################################################
+
+    /**
+     * The class constructor.
+     *
+     * @param CAS_Client $cas_parent     the CAS_Client instance that creates
+     * the object.
+     * @param string     $dsn_or_pdo     a dsn string to use for creating a PDO
+     * object or a PDO object
+     * @param string     $username       the username to use when connecting to
+     * the database
+     * @param string     $password       the password to use when connecting to
+     * the database
+     * @param string     $table          the table to use for storing and
+     * retrieving PGT's
+     * @param string     $driver_options any driver options to use when
+     * connecting to the database
+     */
+    public function __construct($cas_parent, $dsn_or_pdo, $username='', $password='', $table='', $driver_options=null)
+    {
+        phpCAS::traceBegin();
+        // call the ancestor's constructor
+        parent::__construct($cas_parent);
+
+        // set default values
+        if ( empty($table) ) {
+            $table = CAS_PGT_STORAGE_DB_DEFAULT_TABLE;
+        }
+        if ( !is_array($driver_options) ) {
+            $driver_options = array(PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION);
+        }
+
+        // store the specified parameters
+        if ($dsn_or_pdo instanceof PDO) {
+            $this->_pdo = $dsn_or_pdo;
+        } else {
+            $this->_dsn = $dsn_or_pdo;
+            $this->_username = $username;
+            $this->_password = $password;
+            $this->_driver_options = $driver_options;
+        }
+
+        // store the table name
+        $this->_table = $table;
+
+        phpCAS::traceEnd();
+    }
+
+    // ########################################################################
+    //  INITIALIZATION
+    // ########################################################################
+
+    /**
+     * This method is used to initialize the storage. Halts on error.
+     *
+     * @return void
+     */
+    public function init()
+    {
+        phpCAS::traceBegin();
+        // if the storage has already been initialized, return immediatly
+        if ($this->isInitialized()) {
+            return;
+        }
+
+        // initialize the base object
+        parent::init();
+
+        // create the PDO object if it doesn't exist already
+        if (!($this->_pdo instanceof PDO)) {
+            try {
+                $this->_pdo = new PDO($this->_dsn, $this->_username, $this->_password, $this->_driver_options);
+            }
+            catch(PDOException $e) {
+                phpCAS::error('Database connection error: ' . $e->getMessage());
+            }
+        }
+
+        phpCAS::traceEnd();
+    }
+
+    // ########################################################################
+    //  PDO database interaction
+    // ########################################################################
+
+    /**
+     * attribute that stores the previous error mode for the PDO handle while
+     * processing a transaction
+     */
+    private $_errMode;
+
+    /**
+     * This method will enable the Exception error mode on the PDO object
+     *
+     * @return void
+     */
+    private function _setErrorMode()
+    {
+        // get PDO object and enable exception error mode
+        $pdo = $this->_getPdo();
+        $this->_errMode = $pdo->getAttribute(PDO::ATTR_ERRMODE);
+        $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
+    }
+
+    /**
+     * this method will reset the error mode on the PDO object
+     *
+     * @return void
+     */
+    private function _resetErrorMode()
+    {
+        // get PDO object and reset the error mode to what it was originally
+        $pdo = $this->_getPdo();
+        $pdo->setAttribute(PDO::ATTR_ERRMODE, $this->_errMode);
+    }
+
+    // ########################################################################
+    //  database queries
+    // ########################################################################
+    // these queries are potentially unsafe because the person using this library
+    // can set the table to use, but there is no reliable way to escape SQL
+    // fieldnames in PDO yet
+
+    /**
+     * This method returns the query used to create a pgt storage table
+     *
+     * @return the create table SQL, no bind params in query
+     */
+    protected function createTableSql()
+    {
+        return 'CREATE TABLE ' . $this->_getTable() . ' (pgt_iou VARCHAR(255) NOT NULL PRIMARY KEY, pgt VARCHAR(255) NOT NULL)';
+    }
+
+    /**
+     * This method returns the query used to store a pgt
+     *
+     * @return the store PGT SQL, :pgt and :pgt_iou are the bind params contained in the query
+     */
+    protected function storePgtSql()
+    {
+        return 'INSERT INTO ' . $this->_getTable() . ' (pgt_iou, pgt) VALUES (:pgt_iou, :pgt)';
+    }
+
+    /**
+     * This method returns the query used to retrieve a pgt. the first column of the first row should contain the pgt
+     *
+     * @return the retrieve PGT SQL, :pgt_iou is the only bind param contained in the query
+     */
+    protected function retrievePgtSql()
+    {
+        return 'SELECT pgt FROM ' . $this->_getTable() . ' WHERE pgt_iou = :pgt_iou';
+    }
+
+    /**
+     * This method returns the query used to delete a pgt.
+     *
+     * @return the delete PGT SQL, :pgt_iou is the only bind param contained in the query
+     */
+    protected function deletePgtSql()
+    {
+        return 'DELETE FROM ' . $this->_getTable() . ' WHERE pgt_iou = :pgt_iou';
+    }
+
+    // ########################################################################
+    //  PGT I/O
+    // ########################################################################
+
+    /**
+     * This method creates the database table used to store pgt's and pgtiou's
+     *
+     * @return void
+     */
+    public function createTable()
+    {
+        phpCAS::traceBegin();
+
+        // initialize this PGTStorage object if it hasn't been initialized yet
+        if ( !$this->isInitialized() ) {
+            $this->init();
+        }
+
+        // initialize the PDO object for this method
+        $pdo = $this->_getPdo();
+        $this->_setErrorMode();
+
+        try {
+            $pdo->beginTransaction();
+
+            $query = $pdo->query($this->createTableSQL());
+            $query->closeCursor();
+
+            $pdo->commit();
+        }
+        catch(PDOException $e) {
+            // attempt rolling back the transaction before throwing a phpCAS error
+            try {
+                $pdo->rollBack();
+            }
+            catch(PDOException $e) {
+            }
+            phpCAS::error('error creating PGT storage table: ' . $e->getMessage());
+        }
+
+        // reset the PDO object
+        $this->_resetErrorMode();
+
+        phpCAS::traceEnd();
+    }
+
+    /**
+     * This method stores a PGT and its corresponding PGT Iou in the database.
+     * Echoes a warning on error.
+     *
+     * @param string $pgt     the PGT
+     * @param string $pgt_iou the PGT iou
+     *
+     * @return void
+     */
+    public function write($pgt, $pgt_iou)
+    {
+        phpCAS::traceBegin();
+
+        // initialize the PDO object for this method
+        $pdo = $this->_getPdo();
+        $this->_setErrorMode();
+
+        try {
+            $pdo->beginTransaction();
+
+            $query = $pdo->prepare($this->storePgtSql());
+            $query->bindValue(':pgt', $pgt, PDO::PARAM_STR);
+            $query->bindValue(':pgt_iou', $pgt_iou, PDO::PARAM_STR);
+            $query->execute();
+            $query->closeCursor();
+
+            $pdo->commit();
+        }
+        catch(PDOException $e) {
+            // attempt rolling back the transaction before throwing a phpCAS error
+            try {
+                $pdo->rollBack();
+            }
+            catch(PDOException $e) {
+            }
+            phpCAS::error('error writing PGT to database: ' . $e->getMessage());
+        }
+
+        // reset the PDO object
+        $this->_resetErrorMode();
+
+        phpCAS::traceEnd();
+    }
+
+    /**
+     * This method reads a PGT corresponding to a PGT Iou and deletes the
+     * corresponding db entry.
+     *
+     * @param string $pgt_iou the PGT iou
+     *
+     * @return the corresponding PGT, or FALSE on error
+     */
+    public function read($pgt_iou)
+    {
+        phpCAS::traceBegin();
+        $pgt = false;
+
+        // initialize the PDO object for this method
+        $pdo = $this->_getPdo();
+        $this->_setErrorMode();
+
+        try {
+            $pdo->beginTransaction();
+
+            // fetch the pgt for the specified pgt_iou
+            $query = $pdo->prepare($this->retrievePgtSql());
+            $query->bindValue(':pgt_iou', $pgt_iou, PDO::PARAM_STR);
+            $query->execute();
+            $pgt = $query->fetchColumn(0);
+            $query->closeCursor();
+
+            // delete the specified pgt_iou from the database
+            $query = $pdo->prepare($this->deletePgtSql());
+            $query->bindValue(':pgt_iou', $pgt_iou, PDO::PARAM_STR);
+            $query->execute();
+            $query->closeCursor();
+
+            $pdo->commit();
+        }
+        catch(PDOException $e) {
+            // attempt rolling back the transaction before throwing a phpCAS error
+            try {
+                $pdo->rollBack();
+            }
+            catch(PDOException $e) {
+            }
+            phpCAS::trace('error reading PGT from database: ' . $e->getMessage());
+        }
+
+        // reset the PDO object
+        $this->_resetErrorMode();
+
+        phpCAS::traceEnd();
+        return $pgt;
+    }
+
+    /** @} */
+
+}
+
+?>
diff -rNU5 spip-ori/extensions/cicas/CAS/PGTStorage/File.php spip/extensions/cicas/CAS/PGTStorage/File.php
--- spip-ori/extensions/cicas/CAS/PGTStorage/File.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/PGTStorage/File.php	2013-04-05 11:06:41.173923140 +0200
@@ -0,0 +1,259 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/PGTStorage/AbstractStorage.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Pascal Aubry <pascal.aubry@univ-rennes1.fr>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * The CAS_PGTStorage_File class is a class for PGT file storage. An instance of
+ * this class is returned by CAS_Client::SetPGTStorageFile().
+ *
+ * @class    CAS_PGTStorage_File
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Pascal Aubry <pascal.aubry@univ-rennes1.fr>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ *
+ *
+ * @ingroup internalPGTStorageFile
+ */
+
+class CAS_PGTStorage_File extends CAS_PGTStorage_AbstractStorage
+{
+    /**
+     * @addtogroup internalPGTStorageFile
+     * @{
+     */
+
+    /**
+     * a string telling where PGT's should be stored on the filesystem. Written by
+     * PGTStorageFile::PGTStorageFile(), read by getPath().
+     *
+     * @private
+     */
+    var $_path;
+
+    /**
+     * This method returns the name of the directory where PGT's should be stored
+     * on the filesystem.
+     *
+     * @return the name of a directory (with leading and trailing '/')
+     *
+     * @private
+     */
+    function getPath()
+    {
+        return $this->_path;
+    }
+
+    // ########################################################################
+    //  DEBUGGING
+    // ########################################################################
+
+    /**
+     * This method returns an informational string giving the type of storage
+     * used by the object (used for debugging purposes).
+     *
+     * @return an informational string.
+     * @public
+     */
+    function getStorageType()
+    {
+        return "file";
+    }
+
+    /**
+     * This method returns an informational string giving informations on the
+     * parameters of the storage.(used for debugging purposes).
+     *
+     * @return an informational string.
+     * @public
+     */
+    function getStorageInfo()
+    {
+        return 'path=`'.$this->getPath().'\'';
+    }
+
+    // ########################################################################
+    //  CONSTRUCTOR
+    // ########################################################################
+
+    /**
+     * The class constructor, called by CAS_Client::SetPGTStorageFile().
+     *
+     * @param CAS_Client $cas_parent the CAS_Client instance that creates the object.
+     * @param string     $path       the path where the PGT's should be stored
+     *
+     * @return void
+     *
+     * @public
+     */
+    function __construct($cas_parent,$path)
+    {
+        phpCAS::traceBegin();
+        // call the ancestor's constructor
+        parent::__construct($cas_parent);
+
+        if (empty($path)) {
+            $path = CAS_PGT_STORAGE_FILE_DEFAULT_PATH;
+        }
+        // check that the path is an absolute path
+        if (getenv("OS")=="Windows_NT") {
+
+            if (!preg_match('`^[a-zA-Z]:`', $path)) {
+                phpCAS::error('an absolute path is needed for PGT storage to file');
+            }
+
+        } else {
+
+            if ( $path[0] != '/' ) {
+                phpCAS::error('an absolute path is needed for PGT storage to file');
+            }
+
+            // store the path (with a leading and trailing '/')
+            $path = preg_replace('|[/]*$|', '/', $path);
+            $path = preg_replace('|^[/]*|', '/', $path);
+        }
+
+        $this->_path = $path;
+        phpCAS::traceEnd();
+    }
+
+    // ########################################################################
+    //  INITIALIZATION
+    // ########################################################################
+
+    /**
+     * This method is used to initialize the storage. Halts on error.
+     *
+     * @return void
+     * @public
+     */
+    function init()
+    {
+        phpCAS::traceBegin();
+        // if the storage has already been initialized, return immediatly
+        if ($this->isInitialized()) {
+            return;
+        }
+        // call the ancestor's method (mark as initialized)
+        parent::init();
+        phpCAS::traceEnd();
+    }
+
+    // ########################################################################
+    //  PGT I/O
+    // ########################################################################
+
+    /**
+     * This method returns the filename corresponding to a PGT Iou.
+     *
+     * @param string $pgt_iou the PGT iou.
+     *
+     * @return a filename
+     * @private
+     */
+    function getPGTIouFilename($pgt_iou)
+    {
+        phpCAS::traceBegin();
+        $filename = $this->getPath().$pgt_iou.'.plain';
+        phpCAS::traceEnd($filename);
+        return $filename;
+    }
+
+    /**
+     * This method stores a PGT and its corresponding PGT Iou into a file. Echoes a
+     * warning on error.
+     *
+     * @param string $pgt     the PGT
+     * @param string $pgt_iou the PGT iou
+     *
+     * @return void
+     *
+     * @public
+     */
+    function write($pgt,$pgt_iou)
+    {
+        phpCAS::traceBegin();
+        $fname = $this->getPGTIouFilename($pgt_iou);
+        if (!file_exists($fname)) {
+            touch($fname);
+            // Chmod will fail on windows
+            @chmod($fname, 0600);
+            if ($f=fopen($fname, "w")) {
+                if (fputs($f, $pgt) === false) {
+                    phpCAS::error('could not write PGT to `'.$fname.'\'');
+                }
+                phpCAS::trace('Successful write of PGT to `'.$fname.'\'');
+                fclose($f);
+            } else {
+                phpCAS::error('could not open `'.$fname.'\'');
+            }
+        } else {
+            phpCAS::error('File exists: `'.$fname.'\'');
+        }
+        phpCAS::traceEnd();
+    }
+
+    /**
+     * This method reads a PGT corresponding to a PGT Iou and deletes the
+     * corresponding file.
+     *
+     * @param string $pgt_iou the PGT iou
+     *
+     * @return the corresponding PGT, or FALSE on error
+     *
+     * @public
+     */
+    function read($pgt_iou)
+    {
+        phpCAS::traceBegin();
+        $pgt = false;
+        $fname = $this->getPGTIouFilename($pgt_iou);
+        if (file_exists($fname)) {
+            if (!($f=fopen($fname, "r"))) {
+                phpCAS::error('could not open `'.$fname.'\'');
+            } else {
+                if (($pgt=fgets($f)) === false) {
+                    phpCAS::error('could not read PGT from `'.$fname.'\'');
+                }
+                phpCAS::trace('Successful read of PGT to `'.$fname.'\'');
+                fclose($f);
+            }
+            // delete the PGT file
+            @unlink($fname);
+        } else {
+            phpCAS::error('No such file `'.$fname.'\'');
+        }
+        phpCAS::traceEnd($pgt);
+        return $pgt;
+    }
+
+    /** @} */
+
+}
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/CAS/ProxiedService/Abstract.php spip/extensions/cicas/CAS/ProxiedService/Abstract.php
--- spip-ori/extensions/cicas/CAS/ProxiedService/Abstract.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/ProxiedService/Abstract.php	2013-04-05 11:06:41.173923140 +0200
@@ -0,0 +1,138 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/ProxiedService/Abstract.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * This class implements common methods for ProxiedService implementations included
+ * with phpCAS.
+ *
+ * @class    CAS_ProxiedService_Abstract
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+abstract class CAS_ProxiedService_Abstract
+implements CAS_ProxiedService, CAS_ProxiedService_Testable
+{
+
+    /**
+     * The proxy ticket that can be used when making service requests.
+     * @var string $_proxyTicket;
+     */
+    private $_proxyTicket;
+
+    /**
+     * Register a proxy ticket with the Proxy that it can use when making requests.
+     *
+     * @param string $proxyTicket proxy ticket
+     *
+     * @return void
+     * @throws InvalidArgumentException If the $proxyTicket is invalid.
+     * @throws CAS_OutOfSequenceException If called after a proxy ticket has already been initialized/set.
+     */
+    public function setProxyTicket ($proxyTicket)
+    {
+        if (empty($proxyTicket)) {
+            throw new CAS_InvalidArgumentException("Trying to initialize with an empty proxy ticket.");
+        }
+        if (!empty($this->_proxyTicket)) {
+            throw new CAS_OutOfSequenceException('Already initialized, cannot change the proxy ticket.');
+        }
+        $this->_proxyTicket = $proxyTicket;
+    }
+
+    /**
+     * Answer the proxy ticket to be used when making requests.
+     *
+     * @return string
+     * @throws CAS_OutOfSequenceException If called before a proxy ticket has
+     * already been initialized/set.
+     */
+    protected function getProxyTicket ()
+    {
+        if (empty($this->_proxyTicket)) {
+            throw new CAS_OutOfSequenceException('No proxy ticket yet. Call $this->initializeProxyTicket() to aquire the proxy ticket.');
+        }
+
+        return $this->_proxyTicket;
+    }
+
+    /**
+     * @var CAS_Client $_casClient;
+     */
+    private $_casClient;
+
+    /**
+     * Use a particular CAS_Client->initializeProxiedService() rather than the
+     * static phpCAS::initializeProxiedService().
+     *
+     * This method should not be called in standard operation, but is needed for unit
+     * testing.
+     *
+     * @param CAS_Client $casClient cas client
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after a proxy ticket has
+     * already been initialized/set.
+     */
+    public function setCasClient (CAS_Client $casClient)
+    {
+        if (!empty($this->_proxyTicket)) {
+            throw new CAS_OutOfSequenceException('Already initialized, cannot change the CAS_Client.');
+        }
+
+        $this->_casClient = $casClient;
+    }
+
+    /**
+     * Fetch our proxy ticket.
+     *
+     * Descendent classes should call this method once their service URL is available
+     * to initialize their proxy ticket.
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after a proxy ticket has
+     * already been initialized.
+     */
+    protected function initializeProxyTicket()
+    {
+        if (!empty($this->_proxyTicket)) {
+            throw new CAS_OutOfSequenceException('Already initialized, cannot initialize again.');
+        }
+        // Allow usage of a particular CAS_Client for unit testing.
+        if (empty($this->_casClient)) {
+            phpCAS::initializeProxiedService($this);
+        } else {
+            $this->_casClient->initializeProxiedService($this);
+        }
+    }
+
+}
+?>
diff -rNU5 spip-ori/extensions/cicas/CAS/ProxiedService/Exception.php spip/extensions/cicas/CAS/ProxiedService/Exception.php
--- spip-ori/extensions/cicas/CAS/ProxiedService/Exception.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/ProxiedService/Exception.php	2013-04-05 11:06:41.173923140 +0200
@@ -0,0 +1,46 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/ProxiedService/Exception.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * An Exception for problems communicating with a proxied service.
+ *
+ * @class    CAS_ProxiedService_Exception
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+class CAS_ProxiedService_Exception
+extends Exception
+implements CAS_Exception
+{
+
+}
+?>
diff -rNU5 spip-ori/extensions/cicas/CAS/ProxiedService/Http/Abstract.php spip/extensions/cicas/CAS/ProxiedService/Http/Abstract.php
--- spip-ori/extensions/cicas/CAS/ProxiedService/Http/Abstract.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/ProxiedService/Http/Abstract.php	2013-04-05 11:06:41.173923140 +0200
@@ -0,0 +1,332 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/ProxiedService/Http/Abstract.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * This class implements common methods for ProxiedService implementations included
+ * with phpCAS.
+ *
+ * @class    CAS_ProxiedService_Http_Abstract
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+abstract class CAS_ProxiedService_Http_Abstract
+extends CAS_ProxiedService_Abstract
+implements CAS_ProxiedService_Http
+{
+    /**
+     * The HTTP request mechanism talking to the target service.
+     *
+     * @var CAS_Request_RequestInterface $requestHandler
+     */
+    protected $requestHandler;
+
+    /**
+     * The storage mechanism for cookies set by the target service.
+     *
+     * @var CAS_CookieJar $_cookieJar
+     */
+    private $_cookieJar;
+
+    /**
+     * Constructor.
+     *
+     * @param CAS_Request_RequestInterface $requestHandler request handler object
+     * @param CAS_CookieJar                $cookieJar      cookieJar object
+     *
+     * @return void
+     */
+    public function __construct (CAS_Request_RequestInterface $requestHandler, CAS_CookieJar $cookieJar)
+    {
+        $this->requestHandler = $requestHandler;
+        $this->_cookieJar = $cookieJar;
+    }
+
+    /**
+     * The target service url.
+     * @var string $_url;
+     */
+    private $_url;
+
+    /**
+     * Answer a service identifier (URL) for whom we should fetch a proxy ticket.
+     *
+     * @return string
+     * @throws Exception If no service url is available.
+     */
+    public function getServiceUrl ()
+    {
+        if (empty($this->_url)) {
+            throw new CAS_ProxiedService_Exception('No URL set via '.get_class($this).'->setUrl($url).');
+        }
+
+        return $this->_url;
+    }
+
+    /*********************************************************
+     * Configure the Request
+    *********************************************************/
+
+    /**
+     * Set the URL of the Request
+     *
+     * @param string $url url to set
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function setUrl ($url)
+    {
+        if ($this->hasBeenSent()) {
+            throw new CAS_OutOfSequenceException('Cannot set the URL, request already sent.');
+        }
+        if (!is_string($url)) {
+            throw new CAS_InvalidArgumentException('$url must be a string.');
+        }
+
+        $this->_url = $url;
+    }
+
+    /*********************************************************
+     * 2. Send the Request
+    *********************************************************/
+
+    /**
+     * Perform the request.
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called multiple times.
+     * @throws CAS_ProxyTicketException If there is a proxy-ticket failure.
+     *		The code of the Exception will be one of:
+     *			PHPCAS_SERVICE_PT_NO_SERVER_RESPONSE
+     *			PHPCAS_SERVICE_PT_BAD_SERVER_RESPONSE
+     *			PHPCAS_SERVICE_PT_FAILURE
+     * @throws CAS_ProxiedService_Exception If there is a failure sending the
+     * request to the target service.
+     */
+    public function send ()
+    {
+        if ($this->hasBeenSent()) {
+            throw new CAS_OutOfSequenceException('Cannot send, request already sent.');
+        }
+
+        phpCAS::traceBegin();
+
+        // Get our proxy ticket and append it to our URL.
+        $this->initializeProxyTicket();
+        $url = $this->getServiceUrl();
+        if (strstr($url, '?') === false) {
+            $url = $url.'?ticket='.$this->getProxyTicket();
+        } else {
+            $url = $url.'&ticket='.$this->getProxyTicket();
+        }
+
+        try {
+            $this->makeRequest($url);
+        } catch (Exception $e) {
+            phpCAS::traceEnd();
+            throw $e;
+        }
+    }
+
+    /**
+     * Indicator of the number of requests (including redirects performed.
+     *
+     * @var int $_numRequests;
+     */
+    private $_numRequests = 0;
+
+    /**
+     * The response headers.
+     *
+     * @var array $_responseHeaders;
+     */
+    private $_responseHeaders = array();
+
+    /**
+     * The response status code.
+     *
+     * @var string $_responseStatusCode;
+     */
+    private $_responseStatusCode = '';
+
+    /**
+     * The response headers.
+     *
+     * @var string $_responseBody;
+     */
+    private $_responseBody = '';
+
+    /**
+     * Build and perform a request, following redirects
+     *
+     * @param string $url url for the request
+     *
+     * @return void
+     * @throws CAS_ProxyTicketException If there is a proxy-ticket failure.
+     *		The code of the Exception will be one of:
+     *			PHPCAS_SERVICE_PT_NO_SERVER_RESPONSE
+     *			PHPCAS_SERVICE_PT_BAD_SERVER_RESPONSE
+     *			PHPCAS_SERVICE_PT_FAILURE
+     * @throws CAS_ProxiedService_Exception If there is a failure sending the
+     * request to the target service.
+     */
+    protected function makeRequest ($url)
+    {
+        // Verify that we are not in a redirect loop
+        $this->_numRequests++;
+        if ($this->_numRequests > 4) {
+            $message = 'Exceeded the maximum number of redirects (3) in proxied service request.';
+            phpCAS::trace($message);
+            throw new CAS_ProxiedService_Exception($message);
+        }
+
+        // Create a new request.
+        $request = clone $this->requestHandler;
+        $request->setUrl($url);
+
+        // Add any cookies to the request.
+        $request->addCookies($this->_cookieJar->getCookies($url));
+
+        // Add any other parts of the request needed by concrete classes
+        $this->populateRequest($request);
+
+        // Perform the request.
+        phpCAS::trace('Performing proxied service request to \''.$url.'\'');
+        if (!$request->send()) {
+            $message = 'Could not perform proxied service request to URL`'.$url.'\'. '.$request->getErrorMessage();
+            phpCAS::trace($message);
+            throw new CAS_ProxiedService_Exception($message);
+        }
+
+        // Store any cookies from the response;
+        $this->_cookieJar->storeCookies($url, $request->getResponseHeaders());
+
+        // Follow any redirects
+        if ($redirectUrl = $this->getRedirectUrl($request->getResponseHeaders())) {
+            phpCAS :: trace('Found redirect:'.$redirectUrl);
+            $this->makeRequest($redirectUrl);
+        } else {
+
+            $this->_responseHeaders = $request->getResponseHeaders();
+            $this->_responseBody = $request->getResponseBody();
+            $this->_responseStatusCode = $request->getResponseStatusCode();
+        }
+    }
+
+    /**
+     * Add any other parts of the request needed by concrete classes
+     *
+     * @param CAS_Request_RequestInterface $request request interface object
+     *
+     * @return void
+     */
+    abstract protected function populateRequest (CAS_Request_RequestInterface $request);
+
+    /**
+     * Answer a redirect URL if a redirect header is found, otherwise null.
+     *
+     * @param array $responseHeaders response header to extract a redirect from
+     *
+     * @return string or null
+     */
+    protected function getRedirectUrl (array $responseHeaders)
+    {
+        // Check for the redirect after authentication
+        foreach ($responseHeaders as $header) {
+            if (preg_match('/^(Location:|URI:)\s*([^\s]+.*)$/', $header, $matches)) {
+                return trim(array_pop($matches));
+            }
+        }
+        return null;
+    }
+
+    /*********************************************************
+     * 3. Access the response
+    *********************************************************/
+
+    /**
+     * Answer true if our request has been sent yet.
+     *
+     * @return bool
+     */
+    protected function hasBeenSent ()
+    {
+        return ($this->_numRequests > 0);
+    }
+
+    /**
+     * Answer the headers of the response.
+     *
+     * @return array An array of header strings.
+     * @throws CAS_OutOfSequenceException If called before the Request has been sent.
+     */
+    public function getResponseHeaders ()
+    {
+        if (!$this->hasBeenSent()) {
+            throw new CAS_OutOfSequenceException('Cannot access response, request not sent yet.');
+        }
+
+        return $this->_responseHeaders;
+    }
+
+    /**
+     * Answer HTTP status code of the response
+     *
+     * @return int
+     * @throws CAS_OutOfSequenceException If called before the Request has been sent.
+     */
+    public function getResponseStatusCode ()
+    {
+        if (!$this->hasBeenSent()) {
+            throw new CAS_OutOfSequenceException('Cannot access response, request not sent yet.');
+        }
+
+        return $this->_responseStatusCode;
+    }
+
+    /**
+     * Answer the body of response.
+     *
+     * @return string
+     * @throws CAS_OutOfSequenceException If called before the Request has been sent.
+     */
+    public function getResponseBody ()
+    {
+        if (!$this->hasBeenSent()) {
+            throw new CAS_OutOfSequenceException('Cannot access response, request not sent yet.');
+        }
+
+        return $this->_responseBody;
+    }
+
+}
+?>
diff -rNU5 spip-ori/extensions/cicas/CAS/ProxiedService/Http/Get.php spip/extensions/cicas/CAS/ProxiedService/Http/Get.php
--- spip-ori/extensions/cicas/CAS/ProxiedService/Http/Get.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/ProxiedService/Http/Get.php	2013-04-05 11:06:41.173923140 +0200
@@ -0,0 +1,84 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/ProxiedService/Http/Get.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * This class is used to make proxied service requests via the HTTP GET method.
+ *
+ * Usage Example:
+ *
+ *			try {
+ * 				$service = phpCAS::getProxiedService(PHPCAS_PROXIED_SERVICE_HTTP_GET);
+ * 				$service->setUrl('http://www.example.com/path/');
+ * 				$service->send();
+ *				if ($service->getResponseStatusCode() == 200)
+ *					return $service->getResponseBody();
+ *				else
+ *					// The service responded with an error code 404, 500, etc.
+ *					throw new Exception('The service responded with an error.');
+ *
+ *			} catch (CAS_ProxyTicketException $e) {
+ *				if ($e->getCode() == PHPCAS_SERVICE_PT_FAILURE)
+ *					return "Your login has timed out. You need to log in again.";
+ *				else
+ *					// Other proxy ticket errors are from bad request format (shouldn't happen)
+ *					// or CAS server failure (unlikely) so lets just stop if we hit those.
+ *					throw $e;
+ *			} catch (CAS_ProxiedService_Exception $e) {
+ *				// Something prevented the service request from being sent or received.
+ *				// We didn't even get a valid error response (404, 500, etc), so this
+ *				// might be caused by a network error or a DNS resolution failure.
+ *				// We could handle it in some way, but for now we will just stop.
+ *				throw $e;
+ *			}
+ *
+ * @class    CAS_ProxiedService_Http_Get
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+class CAS_ProxiedService_Http_Get
+extends CAS_ProxiedService_Http_Abstract
+{
+
+    /**
+     * Add any other parts of the request needed by concrete classes
+     *
+     * @param CAS_Request_RequestInterface $request request interface
+     *
+     * @return void
+     */
+    protected function populateRequest (CAS_Request_RequestInterface $request)
+    {
+        // do nothing, since the URL has already been sent and that is our
+        // only data.
+    }
+}
+?>
diff -rNU5 spip-ori/extensions/cicas/CAS/ProxiedService/Http/Post.php spip/extensions/cicas/CAS/ProxiedService/Http/Post.php
--- spip-ori/extensions/cicas/CAS/ProxiedService/Http/Post.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/ProxiedService/Http/Post.php	2013-04-05 11:06:41.173923140 +0200
@@ -0,0 +1,144 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/ProxiedService/Http/Post.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * This class is used to make proxied service requests via the HTTP POST method.
+ *
+ * Usage Example:
+ *
+ *			try {
+ * 				$service = phpCAS::getProxiedService(PHPCAS_PROXIED_SERVICE_HTTP_POST);
+ * 				$service->setUrl('http://www.example.com/path/');
+ *				$service->setContentType('text/xml');
+ *				$service->setBody(''<?xml version="1.0"?'.'><methodCall><methodName>example.search</methodName></methodCall>');
+ * 				$service->send();
+ *				if ($service->getResponseStatusCode() == 200)
+ *					return $service->getResponseBody();
+ *				else
+ *					// The service responded with an error code 404, 500, etc.
+ *					throw new Exception('The service responded with an error.');
+ *
+ *			} catch (CAS_ProxyTicketException $e) {
+ *				if ($e->getCode() == PHPCAS_SERVICE_PT_FAILURE)
+ *					return "Your login has timed out. You need to log in again.";
+ *				else
+ *					// Other proxy ticket errors are from bad request format (shouldn't happen)
+ *					// or CAS server failure (unlikely) so lets just stop if we hit those.
+ *					throw $e;
+ *			} catch (CAS_ProxiedService_Exception $e) {
+ *				// Something prevented the service request from being sent or received.
+ *				// We didn't even get a valid error response (404, 500, etc), so this
+ *				// might be caused by a network error or a DNS resolution failure.
+ *				// We could handle it in some way, but for now we will just stop.
+ *				throw $e;
+ *			}
+ *
+ * @class    CAS_ProxiedService_Http_Post
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+class CAS_ProxiedService_Http_Post
+extends CAS_ProxiedService_Http_Abstract
+{
+
+    /**
+     * The content-type of this request
+     *
+     * @var string $_contentType
+     */
+    private $_contentType;
+
+    /**
+     * The body of the this request
+     *
+     * @var string $_body
+     */
+    private $_body;
+
+    /**
+     * Set the content type of this POST request.
+     *
+     * @param string $contentType content type
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function setContentType ($contentType)
+    {
+        if ($this->hasBeenSent()) {
+            throw new CAS_OutOfSequenceException('Cannot set the content type, request already sent.');
+        }
+
+        $this->_contentType = $contentType;
+    }
+
+    /**
+     * Set the body of this POST request.
+     *
+     * @param string $body body to set
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function setBody ($body)
+    {
+        if ($this->hasBeenSent()) {
+            throw new CAS_OutOfSequenceException('Cannot set the body, request already sent.');
+        }
+
+        $this->_body = $body;
+    }
+
+    /**
+     * Add any other parts of the request needed by concrete classes
+     *
+     * @param CAS_Request_RequestInterface $request request interface class
+     *
+     * @return void
+     */
+    protected function populateRequest (CAS_Request_RequestInterface $request)
+    {
+        if (empty($this->_contentType) && !empty($this->_body)) {
+            throw new CAS_ProxiedService_Exception("If you pass a POST body, you must specify a content type via ".get_class($this).'->setContentType($contentType).');
+        }
+
+        $request->makePost();
+        if (!empty($this->_body)) {
+            $request->addHeader('Content-Type: '.$this->_contentType);
+            $request->addHeader('Content-Length: '.strlen($this->_body));
+            $request->setPostBody($this->_body);
+        }
+    }
+
+
+}
+?>
diff -rNU5 spip-ori/extensions/cicas/CAS/ProxiedService/Http.php spip/extensions/cicas/CAS/ProxiedService/Http.php
--- spip-ori/extensions/cicas/CAS/ProxiedService/Http.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/ProxiedService/Http.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,91 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/ProxiedService/Http.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * This interface defines methods that clients should use for configuring, sending,
+ * and receiving proxied HTTP requests.
+ *
+ * @class    CAS_ProxiedService_Http
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+interface CAS_ProxiedService_Http
+{
+
+    /*********************************************************
+     * Configure the Request
+    *********************************************************/
+
+    /**
+     * Set the URL of the Request
+     *
+     * @param string $url Url to set
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function setUrl ($url);
+
+    /*********************************************************
+     * 2. Send the Request
+    *********************************************************/
+
+    /**
+     * Perform the request.
+     *
+     * @return bool TRUE on success, FALSE on failure.
+     * @throws CAS_OutOfSequenceException If called multiple times.
+     */
+    public function send ();
+
+    /*********************************************************
+     * 3. Access the response
+    *********************************************************/
+
+    /**
+     * Answer the headers of the response.
+     *
+     * @return array An array of header strings.
+     * @throws CAS_OutOfSequenceException If called before the Request has been sent.
+     */
+    public function getResponseHeaders ();
+
+    /**
+     * Answer the body of response.
+     *
+     * @return string
+     * @throws CAS_OutOfSequenceException If called before the Request has been sent.
+     */
+    public function getResponseBody ();
+
+}
+?>
diff -rNU5 spip-ori/extensions/cicas/CAS/ProxiedService/Imap.php spip/extensions/cicas/CAS/ProxiedService/Imap.php
--- spip-ori/extensions/cicas/CAS/ProxiedService/Imap.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/ProxiedService/Imap.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,260 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/ProxiedService/Imap.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * Provides access to a proxy-authenticated IMAP stream
+ *
+ * @class    CAS_ProxiedService_Imap
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+class CAS_ProxiedService_Imap
+extends CAS_ProxiedService_Abstract
+{
+
+    /**
+     * The username to send via imap_open.
+     *
+     * @var string $_username;
+     */
+    private $_username;
+
+    /**
+     * Constructor.
+     *
+     * @param string $username Username
+     *
+     * @return void
+     */
+    public function __construct ($username)
+    {
+        if (!is_string($username) || !strlen($username)) {
+            throw new CAS_InvalidArgumentException('Invalid username.');
+        }
+
+        $this->_username = $username;
+    }
+
+    /**
+     * The target service url.
+     * @var string $_url;
+     */
+    private $_url;
+
+    /**
+     * Answer a service identifier (URL) for whom we should fetch a proxy ticket.
+     *
+     * @return string
+     * @throws Exception If no service url is available.
+     */
+    public function getServiceUrl ()
+    {
+        if (empty($this->_url)) {
+            throw new CAS_ProxiedService_Exception('No URL set via '.get_class($this).'->getServiceUrl($url).');
+        }
+
+        return $this->_url;
+    }
+
+    /*********************************************************
+     * Configure the Stream
+    *********************************************************/
+
+    /**
+     * Set the URL of the service to pass to CAS for proxy-ticket retrieval.
+     *
+     * @param string $url Url to set
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the stream has been opened.
+     */
+    public function setServiceUrl ($url)
+    {
+        if ($this->hasBeenOpened()) {
+            throw new CAS_OutOfSequenceException('Cannot set the URL, stream already opened.');
+        }
+        if (!is_string($url) || !strlen($url)) {
+            throw new CAS_InvalidArgumentException('Invalid url.');
+        }
+
+        $this->_url = $url;
+    }
+
+    /**
+     * The mailbox to open. See the $mailbox parameter of imap_open().
+     *
+     * @var string $_mailbox
+     */
+    private $_mailbox;
+
+    /**
+     * Set the mailbox to open. See the $mailbox parameter of imap_open().
+     *
+     * @param string $mailbox Mailbox to set
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the stream has been opened.
+     */
+    public function setMailbox ($mailbox)
+    {
+        if ($this->hasBeenOpened()) {
+            throw new CAS_OutOfSequenceException('Cannot set the mailbox, stream already opened.');
+        }
+        if (!is_string($mailbox) || !strlen($mailbox)) {
+            throw new CAS_InvalidArgumentException('Invalid mailbox.');
+        }
+
+        $this->_mailbox = $mailbox;
+    }
+
+    /**
+     * A bit mask of options to pass to imap_open() as the $options parameter.
+     *
+     * @var int $_options
+     */
+    private $_options = null;
+
+    /**
+     * Set the options for opening the stream. See the $options parameter of
+     * imap_open().
+     *
+     * @param int $options Options for the stream
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the stream has been opened.
+     */
+    public function setOptions ($options)
+    {
+        if ($this->hasBeenOpened()) {
+            throw new CAS_OutOfSequenceException('Cannot set options, stream already opened.');
+        }
+        if (!is_int($options)) {
+            throw new CAS_InvalidArgumentException('Invalid options.');
+        }
+
+        $this->_options = $options;
+    }
+
+    /*********************************************************
+     * 2. Open the stream
+    *********************************************************/
+
+    /**
+     * Open the IMAP stream (similar to imap_open()).
+     *
+     * @return resource Returns an IMAP stream on success
+     * @throws CAS_OutOfSequenceException If called multiple times.
+     * @throws CAS_ProxyTicketException If there is a proxy-ticket failure.
+     *		The code of the Exception will be one of:
+     *			PHPCAS_SERVICE_PT_NO_SERVER_RESPONSE
+     *			PHPCAS_SERVICE_PT_BAD_SERVER_RESPONSE
+     *			PHPCAS_SERVICE_PT_FAILURE
+     * @throws CAS_ProxiedService_Exception If there is a failure sending the request to the target service.	 */
+    public function open ()
+    {
+        if ($this->hasBeenOpened()) {
+            throw new CAS_OutOfSequenceException('Stream already opened.');
+        }
+        if (empty($this->_mailbox)) {
+            throw new CAS_ProxiedService_Exception('You must specify a mailbox via '.get_class($this).'->setMailbox($mailbox)');
+        }
+
+        phpCAS::traceBegin();
+
+        // Get our proxy ticket and append it to our URL.
+        $this->initializeProxyTicket();
+        phpCAS::trace('opening IMAP mailbox `'.$this->_mailbox.'\'...');
+        $this->_stream = @imap_open($this->_mailbox, $this->_username, $this->getProxyTicket(), $this->_options);
+        if ($this->_stream) {
+            phpCAS::trace('ok');
+        } else {
+            phpCAS::trace('could not open mailbox');
+            // @todo add localization integration.
+            $message = 'IMAP Error: '.$url.' '. var_export(imap_errors(), true);
+            phpCAS::trace($message);
+            throw new CAS_ProxiedService_Exception($message);
+        }
+
+        phpCAS::traceEnd();
+        return $this->_stream;
+    }
+
+    /**
+     * Answer true if our request has been sent yet.
+     *
+     * @return bool
+     */
+    protected function hasBeenOpened ()
+    {
+        return !empty($this->_stream);
+    }
+
+    /*********************************************************
+     * 3. Access the result
+    *********************************************************/
+    /**
+     * The IMAP stream
+     *
+     * @var resource $_stream
+     */
+    private $_stream;
+
+    /**
+     * Answer the IMAP stream
+     *
+     * @return resource
+     */
+    public function getStream ()
+    {
+        if (!$this->hasBeenOpened()) {
+            throw new CAS_OutOfSequenceException('Cannot access stream, not opened yet.');
+        }
+        return $this->_stream;
+    }
+
+    /**
+     * CAS_Client::serviceMail() needs to return the proxy ticket for some reason,
+     * so this method provides access to it.
+     *
+     * @return string
+     * @throws CAS_OutOfSequenceException If called before the stream has been
+     * opened.
+     */
+    public function getImapProxyTicket ()
+    {
+        if (!$this->hasBeenOpened()) {
+            throw new CAS_OutOfSequenceException('Cannot access errors, stream not opened yet.');
+        }
+        return $this->getProxyTicket();
+    }
+}
+?>
diff -rNU5 spip-ori/extensions/cicas/CAS/ProxiedService/Testable.php spip/extensions/cicas/CAS/ProxiedService/Testable.php
--- spip-ori/extensions/cicas/CAS/ProxiedService/Testable.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/ProxiedService/Testable.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,73 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/ProxiedService/Testabel.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * This interface defines methods that allow proxy-authenticated service handlers
+ * to be tested in unit tests.
+ *
+ * Classes implementing this interface SHOULD store the CAS_Client passed and initialize
+ * themselves with that client rather than via the static phpCAS method. For example:
+ *
+ *		/ **
+ *		 * Fetch our proxy ticket.
+ *		 * /
+ *		protected function initializeProxyTicket() {
+ *			// Allow usage of a particular CAS_Client for unit testing.
+ *			if (is_null($this->casClient))
+ *				phpCAS::initializeProxiedService($this);
+ *			else
+ *				$this->casClient->initializeProxiedService($this);
+ *		}
+ *
+ * @class    CAS_ProxiedService_Testabel
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+interface CAS_ProxiedService_Testable
+{
+
+    /**
+     * Use a particular CAS_Client->initializeProxiedService() rather than the
+     * static phpCAS::initializeProxiedService().
+     *
+     * This method should not be called in standard operation, but is needed for unit
+     * testing.
+     *
+     * @param CAS_Client $casClient Cas client object
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after a proxy ticket has already been initialized/set.
+     */
+    public function setCasClient (CAS_Client $casClient);
+
+}
+?>
diff -rNU5 spip-ori/extensions/cicas/CAS/ProxiedService.php spip/extensions/cicas/CAS/ProxiedService.php
--- spip-ori/extensions/cicas/CAS/ProxiedService.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/ProxiedService.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,72 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/ProxiedService.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * This interface defines methods that allow proxy-authenticated service handlers
+ * to interact with phpCAS.
+ *
+ * Proxy service handlers must implement this interface as well as call
+ * phpCAS::initializeProxiedService($this) at some point in their implementation.
+ *
+ * While not required, proxy-authenticated service handlers are encouraged to
+ * implement the CAS_ProxiedService_Testable interface to facilitate unit testing.
+ *
+ * @class    CAS_ProxiedService
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+interface CAS_ProxiedService
+{
+
+    /**
+     * Answer a service identifier (URL) for whom we should fetch a proxy ticket.
+     *
+     * @return string
+     * @throws Exception If no service url is available.
+     */
+    public function getServiceUrl ();
+
+    /**
+     * Register a proxy ticket with the ProxiedService that it can use when
+     * making requests.
+     *
+     * @param string $proxyTicket Proxy ticket string
+     *
+     * @return void
+     * @throws InvalidArgumentException If the $proxyTicket is invalid.
+     * @throws CAS_OutOfSequenceException If called after a proxy ticket has
+     * already been initialized/set.
+     */
+    public function setProxyTicket ($proxyTicket);
+
+}
+?>
diff -rNU5 spip-ori/extensions/cicas/CAS/ProxyChain/AllowedList.php spip/extensions/cicas/CAS/ProxyChain/AllowedList.php
--- spip-ori/extensions/cicas/CAS/ProxyChain/AllowedList.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/ProxyChain/AllowedList.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,119 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/ProxyChain/AllowedList.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+
+/**
+ * ProxyChain is a container for storing chains of valid proxies that can
+ * be used to validate proxied requests to a service
+ *
+ * @class    CAS_ProxyChain_AllowedList
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+class CAS_ProxyChain_AllowedList
+{
+
+    private $_chains = array();
+
+    /**
+     * Check whether proxies are allowed by configuration
+     *
+     * @return bool
+     */
+    public function isProxyingAllowed()
+    {
+        return (count($this->_chains) > 0);
+    }
+
+    /**
+     * Add a chain of proxies to the list of possible chains
+     *
+     * @param CAS_ProxyChain_Interface $chain A chain of proxies
+     *
+     * @return void
+     */
+    public function allowProxyChain(CAS_ProxyChain_Interface $chain)
+    {
+        $this->_chains[] = $chain;
+    }
+
+    /**
+     * Check if the proxies found in the response match the allowed proxies
+     *
+     * @param array $proxies list of proxies to check
+     *
+     * @return bool whether the proxies match the allowed proxies
+     */
+    public function isProxyListAllowed(array $proxies)
+    {
+        phpCAS::traceBegin();
+        if (empty($proxies)) {
+            phpCAS::trace("No proxies were found in the response");
+            phpCAS::traceEnd(true);
+            return true;
+        } elseif (!$this->isProxyingAllowed()) {
+            phpCAS::trace("Proxies are not allowed");
+            phpCAS::traceEnd(false);
+            return false;
+        } else {
+            $res = $this->contains($proxies);
+            phpCAS::traceEnd($res);
+            return $res;
+        }
+    }
+
+    /**
+     * Validate the proxies from the proxy ticket validation against the
+     * chains that were definded.
+     *
+     * @param array $list List of proxies from the proxy ticket validation.
+     *
+     * @return if any chain fully matches the supplied list
+     */
+    public function contains(array $list)
+    {
+        phpCAS::traceBegin();
+        $count = 0;
+        foreach ($this->_chains as $chain) {
+            phpCAS::trace("Checking chain ". $count++);
+            if ($chain->matches($list)) {
+                phpCAS::traceEnd(true);
+                return true;
+            }
+        }
+        phpCAS::trace("No proxy chain matches.");
+        phpCAS::traceEnd(false);
+        return false;
+    }
+}
+?>
diff -rNU5 spip-ori/extensions/cicas/CAS/ProxyChain/Any.php spip/extensions/cicas/CAS/ProxyChain/Any.php
--- spip-ori/extensions/cicas/CAS/ProxyChain/Any.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/ProxyChain/Any.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,64 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/ProxyChain/Any.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * A proxy-chain definition that will match any list of proxies.
+ *
+ * Use this class for quick testing or in certain production screnarios you
+ * might want to allow allow any other valid service to proxy your service.
+ *
+ * THIS CLASS IS HOWEVER NOT RECOMMENDED FOR PRODUCTION AND HAS SECURITY
+ * IMPLICATIONS: YOU ARE ALLOWING ANY SERVICE TO ACT ON BEHALF OF A USER
+ * ON THIS SERVICE.
+ *
+ * @class    CAS_ProxyChain_Any
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+class CAS_ProxyChain_Any
+implements CAS_ProxyChain_Interface
+{
+
+    /**
+     * Match a list of proxies.
+     *
+     * @param array $list The list of proxies in front of this service.
+     *
+     * @return bool
+     */
+    public function matches(array $list)
+    {
+        phpCAS::trace("Using CAS_ProxyChain_Any. No proxy validation is performed.");
+        return true;
+    }
+
+}
diff -rNU5 spip-ori/extensions/cicas/CAS/ProxyChain/Interface.php spip/extensions/cicas/CAS/ProxyChain/Interface.php
--- spip-ori/extensions/cicas/CAS/ProxyChain/Interface.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/ProxyChain/Interface.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,53 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/ProxyChain/Interface.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * An interface for classes that define a list of allowed proxies in front of
+ * the current application.
+ *
+ * @class    CAS_ProxyChain_Interface
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+interface CAS_ProxyChain_Interface
+{
+
+    /**
+     * Match a list of proxies.
+     *
+     * @param array $list The list of proxies in front of this service.
+     *
+     * @return bool
+     */
+    public function matches(array $list);
+
+}
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/CAS/ProxyChain/Trusted.php spip/extensions/cicas/CAS/ProxyChain/Trusted.php
--- spip-ori/extensions/cicas/CAS/ProxyChain/Trusted.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/ProxyChain/Trusted.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,59 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/ProxyChain/Trusted.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * A proxy-chain definition that defines a chain up to a trusted proxy and
+ * delegates the resposibility of validating the rest of the chain to that
+ * trusted proxy.
+ *
+ * @class    CAS_ProxyChain_Trusted
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+class CAS_ProxyChain_Trusted
+extends CAS_ProxyChain
+implements CAS_ProxyChain_Interface
+{
+
+    /**
+     * Validate the size of the the list as compared to our chain.
+     *
+     * @param array $list list of proxies
+     *
+     * @return bool
+     */
+    protected function isSizeValid (array $list)
+    {
+        return (sizeof($this->chain) <= sizeof($list));
+    }
+
+}
diff -rNU5 spip-ori/extensions/cicas/CAS/ProxyChain.php spip/extensions/cicas/CAS/ProxyChain.php
--- spip-ori/extensions/cicas/CAS/ProxyChain.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/ProxyChain.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,118 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/ProxyChain.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * A normal proxy-chain definition that lists each level of the chain as either
+ * a string or regular expression.
+ *
+ * @class    CAS_ProxyChain
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+class CAS_ProxyChain
+implements CAS_ProxyChain_Interface
+{
+
+    protected $chain = array();
+
+    /**
+     * A chain is an array of strings or regexp strings that will be matched
+     * against. Regexp will be matched with preg_match and strings will be
+     * matched from the beginning. A string must fully match the beginning of
+     * an proxy url. So you can define a full domain as acceptable or go further
+     * down.
+     * Proxies have to be defined in reverse from the service to the user. If a
+     * user hits service A get proxied via B to service C the list of acceptable
+     * proxies on C would be array(B,A);
+     *
+     * @param array $chain A chain of proxies
+     */
+    public function __construct(array $chain)
+    {
+        $this->chain = array_values($chain);	// Ensure that we have an indexed array
+    }
+
+    /**
+     * Match a list of proxies.
+     *
+     * @param array $list The list of proxies in front of this service.
+     *
+     * @return bool
+     */
+    public function matches(array $list)
+    {
+        $list = array_values($list);  // Ensure that we have an indexed array
+        if ($this->isSizeValid($list)) {
+            $mismatch = false;
+            foreach ($this->chain as $i => $search) {
+                $proxy_url = $list[$i];
+                if (preg_match('/^\/.*\/[ixASUXu]*$/s', $search)) {
+                    if (preg_match($search, $proxy_url)) {
+                        phpCAS::trace("Found regexp " .  $search . " matching " . $proxy_url);
+                    } else {
+                        phpCAS::trace("No regexp match " .  $search . " != " . $proxy_url);
+                        $mismatch = true;
+                        break;
+                    }
+                } else {
+                    if (strncasecmp($search, $proxy_url, strlen($search)) == 0) {
+                        phpCAS::trace("Found string " .  $search . " matching " . $proxy_url);
+                    } else {
+                        phpCAS::trace("No match " .  $search . " != " . $proxy_url);
+                        $mismatch = true;
+                        break;
+                    }
+                }
+            }
+            if (!$mismatch) {
+                phpCAS::trace("Proxy chain matches");
+                return true;
+            }
+        } else {
+            phpCAS::trace("Proxy chain skipped: size mismatch");
+        }
+        return false;
+    }
+
+    /**
+     * Validate the size of the the list as compared to our chain.
+     *
+     * @param array $list List of proxies
+     *
+     * @return bool
+     */
+    protected function isSizeValid (array $list)
+    {
+        return (sizeof($this->chain) == sizeof($list));
+    }
+}
diff -rNU5 spip-ori/extensions/cicas/CAS/ProxyTicketException.php spip/extensions/cicas/CAS/ProxyTicketException.php
--- spip-ori/extensions/cicas/CAS/ProxyTicketException.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/ProxyTicketException.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,68 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @class    CAS/ProxyTicketException.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ *
+ */
+
+/**
+ * An Exception for errors related to fetching or validating proxy tickets.
+ *
+ * @class    CAS_ProxyTicketException
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+class CAS_ProxyTicketException
+extends BadMethodCallException
+implements CAS_Exception
+{
+
+    /**
+     * Constructor
+     *
+     * @param string $message Message text
+     * @param int    $code    Error code
+     *
+     * @return void
+     */
+    public function __construct ($message, $code = PHPCAS_SERVICE_PT_FAILURE)
+    {
+        // Warn if the code is not in our allowed list
+        $ptCodes = array(
+        PHPCAS_SERVICE_PT_FAILURE,
+        PHPCAS_SERVICE_PT_NO_SERVER_RESPONSE,
+        PHPCAS_SERVICE_PT_BAD_SERVER_RESPONSE,
+        );
+        if (!in_array($code, $ptCodes)) {
+            trigger_error('Invalid code '.$code.' passed. Must be one of PHPCAS_SERVICE_PT_FAILURE, PHPCAS_SERVICE_PT_NO_SERVER_RESPONSE, or PHPCAS_SERVICE_PT_BAD_SERVER_RESPONSE.');
+        }
+
+        parent::__construct($message, $code);
+    }
+}
diff -rNU5 spip-ori/extensions/cicas/CAS/Request/AbstractRequest.php spip/extensions/cicas/CAS/Request/AbstractRequest.php
--- spip-ori/extensions/cicas/CAS/Request/AbstractRequest.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Request/AbstractRequest.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,341 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Request/AbstractRequest.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * Provides support for performing web-requests via curl
+ *
+ * @class    CAS_Request_AbstractRequest
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+abstract class CAS_Request_AbstractRequest
+implements CAS_Request_RequestInterface
+{
+
+    protected $url = null;
+    protected $cookies = array();
+    protected $headers = array();
+    protected $isPost = false;
+    protected $postBody = null;
+    protected $caCertPath = null;
+    private $_sent = false;
+    private $_responseHeaders = array();
+    private $_responseBody = null;
+    private $_errorMessage = '';
+
+    /*********************************************************
+     * Configure the Request
+    *********************************************************/
+
+    /**
+     * Set the URL of the Request
+     *
+     * @param string $url Url to set
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function setUrl ($url)
+    {
+        if ($this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has already been sent cannot '.__METHOD__);
+        }
+
+        $this->url = $url;
+    }
+
+    /**
+     * Add a cookie to the request.
+     *
+     * @param string $name  Name of entry
+     * @param string $value value of entry
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function addCookie ($name, $value)
+    {
+        if ($this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has already been sent cannot '.__METHOD__);
+        }
+
+        $this->cookies[$name] = $value;
+    }
+
+    /**
+     * Add an array of cookies to the request.
+     * The cookie array is of the form
+     *     array('cookie_name' => 'cookie_value', 'cookie_name2' => cookie_value2')
+     *
+     * @param array $cookies cookies to add
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function addCookies (array $cookies)
+    {
+        if ($this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has already been sent cannot '.__METHOD__);
+        }
+
+        $this->cookies = array_merge($this->cookies, $cookies);
+    }
+
+    /**
+     * Add a header string to the request.
+     *
+     * @param string $header Header to add
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function addHeader ($header)
+    {
+        if ($this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has already been sent cannot '.__METHOD__);
+        }
+
+        $this->headers[] = $header;
+    }
+
+    /**
+     * Add an array of header strings to the request.
+     *
+     * @param array $headers headers to add
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function addHeaders (array $headers)
+    {
+        if ($this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has already been sent cannot '.__METHOD__);
+        }
+
+        $this->headers = array_merge($this->headers, $headers);
+    }
+
+    /**
+     * Make the request a POST request rather than the default GET request.
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function makePost ()
+    {
+        if ($this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has already been sent cannot '.__METHOD__);
+        }
+
+        $this->isPost = true;
+    }
+
+    /**
+     * Add a POST body to the request
+     *
+     * @param string $body body to add
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function setPostBody ($body)
+    {
+        if ($this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has already been sent cannot '.__METHOD__);
+        }
+        if (!$this->isPost) {
+            throw new CAS_OutOfSequenceException('Cannot add a POST body to a GET request, use makePost() first.');
+        }
+
+        $this->postBody = $body;
+    }
+
+    /**
+     * Specify the path to an SSL CA certificate to validate the server with.
+     *
+     * @param string $caCertPath path to cert
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function setSslCaCert ($caCertPath)
+    {
+        if ($this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has already been sent cannot '.__METHOD__);
+        }
+
+        $this->caCertPath = $caCertPath;
+    }
+
+    /*********************************************************
+     * 2. Send the Request
+    *********************************************************/
+
+    /**
+     * Perform the request.
+     *
+     * @return bool TRUE on success, FALSE on failure.
+     * @throws CAS_OutOfSequenceException If called multiple times.
+     */
+    public function send ()
+    {
+        if ($this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has already been sent cannot send again.');
+        }
+        if (is_null($this->url) || !$this->url) {
+            throw new CAS_OutOfSequenceException('A url must be specified via setUrl() before the request can be sent.');
+        }
+        $this->_sent = true;
+        return $this->sendRequest();
+    }
+
+    /**
+     * Send the request and store the results.
+     *
+     * @return bool TRUE on success, FALSE on failure.
+     */
+    abstract protected function sendRequest ();
+
+    /**
+     * Store the response headers.
+     *
+     * @param array $headers headers to store
+     *
+     * @return void
+     */
+    protected function storeResponseHeaders (array $headers)
+    {
+        $this->_responseHeaders = array_merge($this->_responseHeaders, $headers);
+    }
+
+    /**
+     * Store a single response header to our array.
+     *
+     * @param string $header header to store
+     *
+     * @return void
+     */
+    protected function storeResponseHeader ($header)
+    {
+        $this->_responseHeaders[] = $header;
+    }
+
+    /**
+     * Store the response body.
+     *
+     * @param string $body body to store
+     *
+     * @return void
+     */
+    protected function storeResponseBody ($body)
+    {
+        $this->_responseBody = $body;
+    }
+
+    /**
+     * Add a string to our error message.
+     *
+     * @param string $message message to add
+     *
+     * @return void
+     */
+    protected function storeErrorMessage ($message)
+    {
+        $this->_errorMessage .= $message;
+    }
+
+    /*********************************************************
+     * 3. Access the response
+    *********************************************************/
+
+    /**
+     * Answer the headers of the response.
+     *
+     * @return array An array of header strings.
+     * @throws CAS_OutOfSequenceException If called before the Request has been sent.
+     */
+    public function getResponseHeaders ()
+    {
+        if (!$this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has not been sent yet. Cannot '.__METHOD__);
+        }
+        return $this->_responseHeaders;
+    }
+
+    /**
+     * Answer HTTP status code of the response
+     *
+     * @return int
+     * @throws CAS_OutOfSequenceException If called before the Request has been sent.
+     */
+    public function getResponseStatusCode ()
+    {
+        if (!$this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has not been sent yet. Cannot '.__METHOD__);
+        }
+
+        if (!preg_match('/HTTP\/[0-9.]+\s+([0-9]+)\s*(.*)/', $this->_responseHeaders[0], $matches)) {
+            throw new CAS_Request_Exception("Bad response, no status code was found in the first line.");
+        }
+
+        return intval($matches[1]);
+    }
+
+    /**
+     * Answer the body of response.
+     *
+     * @return string
+     * @throws CAS_OutOfSequenceException If called before the Request has been sent.
+     */
+    public function getResponseBody ()
+    {
+        if (!$this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has not been sent yet. Cannot '.__METHOD__);
+        }
+
+        return $this->_responseBody;
+    }
+
+    /**
+     * Answer a message describing any errors if the request failed.
+     *
+     * @return string
+     * @throws CAS_OutOfSequenceException If called before the Request has been sent.
+     */
+    public function getErrorMessage ()
+    {
+        if (!$this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has not been sent yet. Cannot '.__METHOD__);
+        }
+        return $this->_errorMessage;
+    }
+}
diff -rNU5 spip-ori/extensions/cicas/CAS/Request/CurlMultiRequest.php spip/extensions/cicas/CAS/Request/CurlMultiRequest.php
--- spip-ori/extensions/cicas/CAS/Request/CurlMultiRequest.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Request/CurlMultiRequest.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,136 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Request/AbstractRequest.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * This interface defines a class library for performing multiple web requests
+ * in batches. Implementations of this interface may perform requests serially
+ * or in parallel.
+ *
+ * @class    CAS_Request_CurlMultiRequest
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+class CAS_Request_CurlMultiRequest
+implements CAS_Request_MultiRequestInterface
+{
+    private $_requests = array();
+    private $_sent = false;
+
+    /*********************************************************
+     * Add Requests
+    *********************************************************/
+
+    /**
+     * Add a new Request to this batch.
+     * Note, implementations will likely restrict requests to their own concrete
+     * class hierarchy.
+     *
+     * @param CAS_Request_RequestInterface $request reqest to add
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     * @throws CAS_InvalidArgumentException If passed a Request of the wrong
+     * implmentation.
+     */
+    public function addRequest (CAS_Request_RequestInterface $request)
+    {
+        if ($this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has already been sent cannot '.__METHOD__);
+        }
+        if (!$request instanceof CAS_Request_CurlRequest) {
+            throw new CAS_InvalidArgumentException('As a CAS_Request_CurlMultiRequest, I can only work with CAS_Request_CurlRequest objects.');
+        }
+
+        $this->_requests[] = $request;
+    }
+
+    /**
+     * Retrieve the number of requests added to this batch.
+     *
+     * @return number of request elements
+     */
+    public function getNumRequests()
+    {
+        if ($this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has already been sent cannot '.__METHOD__);
+        }
+        return count($this->_requests);
+    }
+
+    /*********************************************************
+     * 2. Send the Request
+    *********************************************************/
+
+    /**
+     * Perform the request. After sending, all requests will have their
+     * responses poulated.
+     *
+     * @return bool TRUE on success, FALSE on failure.
+     * @throws CAS_OutOfSequenceException If called multiple times.
+     */
+    public function send ()
+    {
+        if ($this->_sent) {
+            throw new CAS_OutOfSequenceException('Request has already been sent cannot send again.');
+        }
+        if (!count($this->_requests)) {
+            throw new CAS_OutOfSequenceException('At least one request must be added via addRequest() before the multi-request can be sent.');
+        }
+
+        $this->_sent = true;
+
+        // Initialize our handles and configure all requests.
+        $handles = array();
+        $multiHandle = curl_multi_init();
+        foreach ($this->_requests as $i => $request) {
+            $handle = $request->_initAndConfigure();
+            curl_setopt($handle, CURLOPT_RETURNTRANSFER, true);
+            $handles[$i] = $handle;
+            curl_multi_add_handle($multiHandle, $handle);
+        }
+
+        // Execute the requests in parallel.
+        do {
+            curl_multi_exec($multiHandle, $running);
+        } while ($running > 0);
+
+        // Populate all of the responses or errors back into the request objects.
+        foreach ($this->_requests as $i => $request) {
+            $buf = curl_multi_getcontent($handles[$i]);
+            $request->_storeResponseBody($buf);
+            curl_multi_remove_handle($multiHandle, $handles[$i]);
+            curl_close($handles[$i]);
+        }
+
+        curl_multi_close($multiHandle);
+    }
+}
diff -rNU5 spip-ori/extensions/cicas/CAS/Request/CurlRequest.php spip/extensions/cicas/CAS/Request/CurlRequest.php
--- spip-ori/extensions/cicas/CAS/Request/CurlRequest.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Request/CurlRequest.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,194 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Request/CurlRequest.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * Provides support for performing web-requests via curl
+ *
+ * @class    CAS_Request_CurlRequest
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+class CAS_Request_CurlRequest
+extends CAS_Request_AbstractRequest
+implements CAS_Request_RequestInterface
+{
+
+    /**
+     * Set additional curl options
+     *
+     * @param array $options option to set
+     *
+     * @return void
+     */
+    public function setCurlOptions (array $options)
+    {
+        $this->_curlOptions = $options;
+    }
+    private $_curlOptions = array();
+
+    /**
+     * Send the request and store the results.
+     *
+     * @return bool true on success, false on failure.
+     */
+    protected function sendRequest ()
+    {
+        phpCAS::traceBegin();
+
+        /*********************************************************
+         * initialize the CURL session
+        *********************************************************/
+        $ch = $this->_initAndConfigure();
+
+        /*********************************************************
+         * Perform the query
+        *********************************************************/
+        $buf = curl_exec($ch);
+        if ( $buf === false ) {
+            phpCAS::trace('curl_exec() failed');
+            $this->storeErrorMessage('CURL error #'.curl_errno($ch).': '.curl_error($ch));
+            $res = false;
+        } else {
+            $this->storeResponseBody($buf);
+            phpCAS::trace("Response Body: \n".$buf."\n");
+            $res = true;
+
+        }
+        // close the CURL session
+        curl_close($ch);
+
+        phpCAS::traceEnd($res);
+        return $res;
+    }
+
+    /**
+     * Internal method to initialize our cURL handle and configure the request.
+     * This method should NOT be used outside of the CurlRequest or the
+     * CurlMultiRequest.
+     *
+     * @return resource The cURL handle on success, false on failure
+     */
+    private function _initAndConfigure()
+    {
+        /*********************************************************
+         * initialize the CURL session
+        *********************************************************/
+        $ch = curl_init($this->url);
+
+        if (version_compare(PHP_VERSION, '5.1.3', '>=')) {
+            //only avaible in php5
+            curl_setopt_array($ch, $this->_curlOptions);
+        } else {
+            foreach ($this->_curlOptions as $key => $value) {
+                curl_setopt($ch, $key, $value);
+            }
+        }
+
+        /*********************************************************
+         * Set SSL configuration
+        *********************************************************/
+        if ($this->caCertPath) {
+            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 1);
+            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 1);
+            curl_setopt($ch, CURLOPT_CAINFO, $this->caCertPath);
+            phpCAS::trace('CURL: Set CURLOPT_CAINFO');
+        } else {
+            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 1);
+            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);
+        }
+
+        /*********************************************************
+         * Configure curl to capture our output.
+        *********************************************************/
+        // return the CURL output into a variable
+        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
+
+        // get the HTTP header with a callback
+        curl_setopt($ch, CURLOPT_HEADERFUNCTION, array($this, '_curlReadHeaders'));
+
+        /*********************************************************
+         * Add cookie headers to our request.
+        *********************************************************/
+        if (count($this->cookies)) {
+            $cookieStrings = array();
+            foreach ($this->cookies as $name => $val) {
+                $cookieStrings[] = $name.'='.$val;
+            }
+            curl_setopt($ch, CURLOPT_COOKIE, implode(';', $cookieStrings));
+        }
+
+        /*********************************************************
+         * Add any additional headers
+        *********************************************************/
+        if (count($this->headers)) {
+            curl_setopt($ch, CURLOPT_HTTPHEADER, $this->headers);
+        }
+
+        /*********************************************************
+         * Flag and Body for POST requests
+        *********************************************************/
+        if ($this->isPost) {
+            curl_setopt($ch, CURLOPT_POST, 1);
+            curl_setopt($ch, CURLOPT_POSTFIELDS, $this->postBody);
+        }
+
+        return $ch;
+    }
+
+    /**
+     * Store the response body.
+     * This method should NOT be used outside of the CurlRequest or the
+     * CurlMultiRequest.
+     *
+     * @param string $body body to stor
+     *
+     * @return void
+     */
+    private function _storeResponseBody ($body)
+    {
+        $this->storeResponseBody($body);
+    }
+
+    /**
+     * Internal method for capturing the headers from a curl request.
+     *
+     * @param handle $ch     handle of curl
+     * @param string $header header
+     *
+     * @return void
+     */
+    private function _curlReadHeaders ($ch, $header)
+    {
+        $this->storeResponseHeader($header);
+        return strlen($header);
+    }
+}
diff -rNU5 spip-ori/extensions/cicas/CAS/Request/Exception.php spip/extensions/cicas/CAS/Request/Exception.php
--- spip-ori/extensions/cicas/CAS/Request/Exception.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Request/Exception.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,45 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Request/Exception.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * An Exception for problems performing requests
+ *
+ * @class    CAS_Request_Exception
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+class CAS_Request_Exception
+extends Exception
+implements CAS_Exception
+{
+
+}
diff -rNU5 spip-ori/extensions/cicas/CAS/Request/MultiRequestInterface.php spip/extensions/cicas/CAS/Request/MultiRequestInterface.php
--- spip-ori/extensions/cicas/CAS/Request/MultiRequestInterface.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Request/MultiRequestInterface.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,83 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Request/MultiRequestInterface.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * This interface defines a class library for performing multiple web requests
+ * in batches. Implementations of this interface may perform requests serially
+ * or in parallel.
+ *
+ * @class    CAS_Request_MultiRequestInterface
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+interface CAS_Request_MultiRequestInterface
+{
+
+    /*********************************************************
+     * Add Requests
+    *********************************************************/
+
+    /**
+     * Add a new Request to this batch.
+     * Note, implementations will likely restrict requests to their own concrete
+     * class hierarchy.
+     *
+     * @param CAS_Request_RequestInterface $request request interface
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been
+     * sent.
+     * @throws CAS_InvalidArgumentException If passed a Request of the wrong
+     * implmentation.
+     */
+    public function addRequest (CAS_Request_RequestInterface $request);
+
+    /**
+     * Retrieve the number of requests added to this batch.
+     *
+     * @return number of request elements
+     */
+    public function getNumRequests ();
+
+    /*********************************************************
+     * 2. Send the Request
+    *********************************************************/
+
+    /**
+     * Perform the request. After sending, all requests will have their
+     * responses poulated.
+     *
+     * @return bool TRUE on success, FALSE on failure.
+     * @throws CAS_OutOfSequenceException If called multiple times.
+     */
+    public function send ();
+}
diff -rNU5 spip-ori/extensions/cicas/CAS/Request/RequestInterface.php spip/extensions/cicas/CAS/Request/RequestInterface.php
--- spip-ori/extensions/cicas/CAS/Request/RequestInterface.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS/Request/RequestInterface.php	2013-04-05 11:06:41.177923140 +0200
@@ -0,0 +1,178 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * PHP Version 5
+ *
+ * @file     CAS/Request/RequestInterface.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+/**
+ * This interface defines a class library for performing web requests.
+ *
+ * @class    CAS_Request_RequestInterface
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+interface CAS_Request_RequestInterface
+{
+
+    /*********************************************************
+     * Configure the Request
+    *********************************************************/
+
+    /**
+     * Set the URL of the Request
+     *
+     * @param string $url url to set
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function setUrl ($url);
+
+    /**
+     * Add a cookie to the request.
+     *
+     * @param string $name  name of cookie
+     * @param string $value value of cookie
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function addCookie ($name, $value);
+
+    /**
+     * Add an array of cookies to the request.
+     * The cookie array is of the form
+     *     array('cookie_name' => 'cookie_value', 'cookie_name2' => cookie_value2')
+     *
+     * @param array $cookies cookies to add
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function addCookies (array $cookies);
+
+    /**
+     * Add a header string to the request.
+     *
+     * @param string $header header to add
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function addHeader ($header);
+
+    /**
+     * Add an array of header strings to the request.
+     *
+     * @param array $headers headers to add
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function addHeaders (array $headers);
+
+    /**
+     * Make the request a POST request rather than the default GET request.
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function makePost ();
+
+    /**
+     * Add a POST body to the request
+     *
+     * @param string $body body to add
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function setPostBody ($body);
+
+
+    /**
+     * Specify the path to an SSL CA certificate to validate the server with.
+     *
+     * @param string $caCertPath path to cert file
+     *
+     * @return void
+     * @throws CAS_OutOfSequenceException If called after the Request has been sent.
+     */
+    public function setSslCaCert ($caCertPath);
+
+
+
+    /*********************************************************
+     * 2. Send the Request
+    *********************************************************/
+
+    /**
+     * Perform the request.
+     *
+     * @return bool TRUE on success, FALSE on failure.
+     * @throws CAS_OutOfSequenceException If called multiple times.
+     */
+    public function send ();
+
+    /*********************************************************
+     * 3. Access the response
+    *********************************************************/
+
+    /**
+     * Answer the headers of the response.
+     *
+     * @return array An array of header strings.
+     * @throws CAS_OutOfSequenceException If called before the Request has been sent.
+     */
+    public function getResponseHeaders ();
+
+    /**
+     * Answer HTTP status code of the response
+     *
+     * @return int
+     * @throws CAS_OutOfSequenceException If called before the Request has been sent.
+     */
+    public function getResponseStatusCode ();
+
+    /**
+     * Answer the body of response.
+     *
+     * @return string
+     * @throws CAS_OutOfSequenceException If called before the Request has been sent.
+     */
+    public function getResponseBody ();
+
+    /**
+     * Answer a message describing any errors if the request failed.
+     *
+     * @return string
+     * @throws CAS_OutOfSequenceException If called before the Request has been sent.
+     */
+    public function getErrorMessage ();
+}
diff -rNU5 spip-ori/extensions/cicas/CAS.php spip/extensions/cicas/CAS.php
--- spip-ori/extensions/cicas/CAS.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/CAS.php	2013-04-05 11:06:41.181923140 +0200
@@ -0,0 +1,1988 @@
+<?php
+
+/**
+ * Licensed to Jasig under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * Jasig licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ *
+ * Interface class of the phpCAS library
+ * PHP Version 5
+ *
+ * @file     CAS/CAS.php
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Pascal Aubry <pascal.aubry@univ-rennes1.fr>
+ * @author   Olivier Berger <olivier.berger@it-sudparis.eu>
+ * @author   Brett Bieber <brett.bieber@gmail.com>
+ * @author   Joachim Fritschi <jfritschi@freenet.de>
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ * @ingroup public
+ */
+
+
+//
+// hack by Vangelis Haniotakis to handle the absence of $_SERVER['REQUEST_URI']
+// in IIS
+//
+if (php_sapi_name() != 'cli') {
+    if (!isset($_SERVER['REQUEST_URI'])) {
+        $_SERVER['REQUEST_URI'] = $_SERVER['SCRIPT_NAME'] . '?' . $_SERVER['QUERY_STRING'];
+    }
+}
+
+// Add a E_USER_DEPRECATED for php versions <= 5.2
+if (!defined('E_USER_DEPRECATED')) {
+    define('E_USER_DEPRECATED', E_USER_NOTICE);
+}
+
+
+// ########################################################################
+//  CONSTANTS
+// ########################################################################
+
+// ------------------------------------------------------------------------
+//  CAS VERSIONS
+// ------------------------------------------------------------------------
+
+/**
+ * phpCAS version. accessible for the user by phpCAS::getVersion().
+ */
+define('PHPCAS_VERSION', '1.3.1');
+
+/**
+ * @addtogroup public
+ * @{
+ */
+
+/**
+ * CAS version 1.0
+ */
+define("CAS_VERSION_1_0", '1.0');
+/*!
+ * CAS version 2.0
+*/
+define("CAS_VERSION_2_0", '2.0');
+
+// ------------------------------------------------------------------------
+//  SAML defines
+// ------------------------------------------------------------------------
+
+/**
+ * SAML protocol
+ */
+define("SAML_VERSION_1_1", 'S1');
+
+/**
+ * XML header for SAML POST
+ */
+define("SAML_XML_HEADER", '<?xml version="1.0" encoding="UTF-8"?>');
+
+/**
+ * SOAP envelope for SAML POST
+ */
+define("SAML_SOAP_ENV", '<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"><SOAP-ENV:Header/>');
+
+/**
+ * SOAP body for SAML POST
+ */
+define("SAML_SOAP_BODY", '<SOAP-ENV:Body>');
+
+/**
+ * SAMLP request
+ */
+define("SAMLP_REQUEST", '<samlp:Request xmlns:samlp="urn:oasis:names:tc:SAML:1.0:protocol"  MajorVersion="1" MinorVersion="1" RequestID="_192.168.16.51.1024506224022" IssueInstant="2002-06-19T17:03:44.022Z">');
+define("SAMLP_REQUEST_CLOSE", '</samlp:Request>');
+
+/**
+ * SAMLP artifact tag (for the ticket)
+ */
+define("SAML_ASSERTION_ARTIFACT", '<samlp:AssertionArtifact>');
+
+/**
+ * SAMLP close
+ */
+define("SAML_ASSERTION_ARTIFACT_CLOSE", '</samlp:AssertionArtifact>');
+
+/**
+ * SOAP body close
+ */
+define("SAML_SOAP_BODY_CLOSE", '</SOAP-ENV:Body>');
+
+/**
+ * SOAP envelope close
+ */
+define("SAML_SOAP_ENV_CLOSE", '</SOAP-ENV:Envelope>');
+
+/**
+ * SAML Attributes
+ */
+define("SAML_ATTRIBUTES", 'SAMLATTRIBS');
+
+/** @} */
+/**
+ * @addtogroup publicPGTStorage
+ * @{
+ */
+// ------------------------------------------------------------------------
+//  FILE PGT STORAGE
+// ------------------------------------------------------------------------
+/**
+ * Default path used when storing PGT's to file
+ */
+define("CAS_PGT_STORAGE_FILE_DEFAULT_PATH", session_save_path());
+/** @} */
+// ------------------------------------------------------------------------
+// SERVICE ACCESS ERRORS
+// ------------------------------------------------------------------------
+/**
+ * @addtogroup publicServices
+ * @{
+ */
+
+/**
+ * phpCAS::service() error code on success
+ */
+define("PHPCAS_SERVICE_OK", 0);
+/**
+ * phpCAS::service() error code when the PT could not retrieve because
+ * the CAS server did not respond.
+ */
+define("PHPCAS_SERVICE_PT_NO_SERVER_RESPONSE", 1);
+/**
+ * phpCAS::service() error code when the PT could not retrieve because
+ * the response of the CAS server was ill-formed.
+ */
+define("PHPCAS_SERVICE_PT_BAD_SERVER_RESPONSE", 2);
+/**
+ * phpCAS::service() error code when the PT could not retrieve because
+ * the CAS server did not want to.
+ */
+define("PHPCAS_SERVICE_PT_FAILURE", 3);
+/**
+ * phpCAS::service() error code when the service was not available.
+ */
+define("PHPCAS_SERVICE_NOT_AVAILABLE", 4);
+
+// ------------------------------------------------------------------------
+// SERVICE TYPES
+// ------------------------------------------------------------------------
+/**
+ * phpCAS::getProxiedService() type for HTTP GET
+ */
+define("PHPCAS_PROXIED_SERVICE_HTTP_GET", 'CAS_ProxiedService_Http_Get');
+/**
+ * phpCAS::getProxiedService() type for HTTP POST
+ */
+define("PHPCAS_PROXIED_SERVICE_HTTP_POST", 'CAS_ProxiedService_Http_Post');
+/**
+ * phpCAS::getProxiedService() type for IMAP
+ */
+define("PHPCAS_PROXIED_SERVICE_IMAP", 'CAS_ProxiedService_Imap');
+
+
+/** @} */
+// ------------------------------------------------------------------------
+//  LANGUAGES
+// ------------------------------------------------------------------------
+/**
+ * @addtogroup publicLang
+ * @{
+ */
+
+define("PHPCAS_LANG_ENGLISH", 'CAS_Languages_English');
+define("PHPCAS_LANG_FRENCH", 'CAS_Languages_French');
+define("PHPCAS_LANG_GREEK", 'CAS_Languages_Greek');
+define("PHPCAS_LANG_GERMAN", 'CAS_Languages_German');
+define("PHPCAS_LANG_JAPANESE", 'CAS_Languages_Japanese');
+define("PHPCAS_LANG_SPANISH", 'CAS_Languages_Spanish');
+define("PHPCAS_LANG_CATALAN", 'CAS_Languages_Catalan');
+
+/** @} */
+
+/**
+ * @addtogroup internalLang
+ * @{
+ */
+
+/**
+ * phpCAS default language (when phpCAS::setLang() is not used)
+ */
+define("PHPCAS_LANG_DEFAULT", PHPCAS_LANG_ENGLISH);
+
+/** @} */
+// ------------------------------------------------------------------------
+//  DEBUG
+// ------------------------------------------------------------------------
+/**
+ * @addtogroup publicDebug
+ * @{
+ */
+
+/**
+ * The default directory for the debug file under Unix.
+ */
+define('DEFAULT_DEBUG_DIR', '/tmp/');
+
+/** @} */
+
+// include the class autoloader
+require_once dirname(__FILE__) . '/CAS/Autoload.php';
+
+/**
+ * The phpCAS class is a simple container for the phpCAS library. It provides CAS
+ * authentication for web applications written in PHP.
+ *
+ * @ingroup public
+ * @class phpCAS
+ * @category Authentication
+ * @package  PhpCAS
+ * @author   Pascal Aubry <pascal.aubry@univ-rennes1.fr>
+ * @author   Olivier Berger <olivier.berger@it-sudparis.eu>
+ * @author   Brett Bieber <brett.bieber@gmail.com>
+ * @author   Joachim Fritschi <jfritschi@freenet.de>
+ * @author   Adam Franco <afranco@middlebury.edu>
+ * @license  http://www.apache.org/licenses/LICENSE-2.0  Apache License 2.0
+ * @link     https://wiki.jasig.org/display/CASC/phpCAS
+ */
+
+class phpCAS
+{
+
+    /**
+     * This variable is used by the interface class phpCAS.
+     *
+     * @hideinitializer
+     */
+    private static $_PHPCAS_CLIENT;
+
+    /**
+     * This variable is used to store where the initializer is called from
+     * (to print a comprehensive error in case of multiple calls).
+     *
+     * @hideinitializer
+     */
+    private static $_PHPCAS_INIT_CALL;
+
+    /**
+     * This variable is used to store phpCAS debug mode.
+     *
+     * @hideinitializer
+     */
+    private static $_PHPCAS_DEBUG;
+
+
+    // ########################################################################
+    //  INITIALIZATION
+    // ########################################################################
+
+    /**
+     * @addtogroup publicInit
+     * @{
+     */
+
+    /**
+     * phpCAS client initializer.
+     *
+     * @param string $server_version  the version of the CAS server
+     * @param string $server_hostname the hostname of the CAS server
+     * @param string $server_port     the port the CAS server is running on
+     * @param string $server_uri      the URI the CAS server is responding on
+     * @param bool   $changeSessionID Allow phpCAS to change the session_id (Single 
+     * Sign Out/handleLogoutRequests is based on that change)
+     *
+     * @return a newly created CAS_Client object
+     * @note Only one of the phpCAS::client() and phpCAS::proxy functions should be
+     * called, only once, and before all other methods (except phpCAS::getVersion()
+     * and phpCAS::setDebug()).
+     */
+    public static function client($server_version, $server_hostname,
+        $server_port, $server_uri, $changeSessionID = true
+    ) {
+        phpCAS :: traceBegin();
+        if (is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error(self::$_PHPCAS_INIT_CALL['method'] . '() has already been called (at ' . self::$_PHPCAS_INIT_CALL['file'] . ':' . self::$_PHPCAS_INIT_CALL['line'] . ')');
+        }
+        if (gettype($server_version) != 'string') {
+            phpCAS :: error('type mismatched for parameter $server_version (should be `string\')');
+        }
+        if (gettype($server_hostname) != 'string') {
+            phpCAS :: error('type mismatched for parameter $server_hostname (should be `string\')');
+        }
+        if (gettype($server_port) != 'integer') {
+            phpCAS :: error('type mismatched for parameter $server_port (should be `integer\')');
+        }
+        if (gettype($server_uri) != 'string') {
+            phpCAS :: error('type mismatched for parameter $server_uri (should be `string\')');
+        }
+
+        // store where the initializer is called from
+        $dbg = debug_backtrace();
+        self::$_PHPCAS_INIT_CALL = array (
+            'done' => true,
+            'file' => $dbg[0]['file'],
+            'line' => $dbg[0]['line'],
+            'method' => __CLASS__ . '::' . __FUNCTION__
+        );
+
+        // initialize the object $_PHPCAS_CLIENT
+        self::$_PHPCAS_CLIENT = new CAS_Client(
+            $server_version, false, $server_hostname, $server_port, $server_uri,
+            $changeSessionID
+        );
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * phpCAS proxy initializer.
+     *
+     * @param string $server_version  the version of the CAS server
+     * @param string $server_hostname the hostname of the CAS server
+     * @param string $server_port     the port the CAS server is running on
+     * @param string $server_uri      the URI the CAS server is responding on
+     * @param bool   $changeSessionID Allow phpCAS to change the session_id (Single 
+     * Sign Out/handleLogoutRequests is based on that change)
+     *
+     * @return a newly created CAS_Client object
+     * @note Only one of the phpCAS::client() and phpCAS::proxy functions should be
+     * called, only once, and before all other methods (except phpCAS::getVersion()
+     * and phpCAS::setDebug()).
+     */
+    public static function proxy($server_version, $server_hostname,
+        $server_port, $server_uri, $changeSessionID = true
+    ) {
+        phpCAS :: traceBegin();
+        if (is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error(self::$_PHPCAS_INIT_CALL['method'] . '() has already been called (at ' . self::$_PHPCAS_INIT_CALL['file'] . ':' . self::$_PHPCAS_INIT_CALL['line'] . ')');
+        }
+        if (gettype($server_version) != 'string') {
+            phpCAS :: error('type mismatched for parameter $server_version (should be `string\')');
+        }
+        if (gettype($server_hostname) != 'string') {
+            phpCAS :: error('type mismatched for parameter $server_hostname (should be `string\')');
+        }
+        if (gettype($server_port) != 'integer') {
+            phpCAS :: error('type mismatched for parameter $server_port (should be `integer\')');
+        }
+        if (gettype($server_uri) != 'string') {
+            phpCAS :: error('type mismatched for parameter $server_uri (should be `string\')');
+        }
+
+        // store where the initialzer is called from
+        $dbg = debug_backtrace();
+        self::$_PHPCAS_INIT_CALL = array (
+            'done' => true,
+            'file' => $dbg[0]['file'],
+            'line' => $dbg[0]['line'],
+            'method' => __CLASS__ . '::' . __FUNCTION__
+        );
+
+        // initialize the object $_PHPCAS_CLIENT
+        self::$_PHPCAS_CLIENT = new CAS_Client(
+            $server_version, true, $server_hostname, $server_port, $server_uri,
+            $changeSessionID
+        );
+        phpCAS :: traceEnd();
+    }
+
+    /** @} */
+    // ########################################################################
+    //  DEBUGGING
+    // ########################################################################
+
+    /**
+     * @addtogroup publicDebug
+     * @{
+     */
+
+    /**
+     * Set/unset debug mode
+     *
+     * @param string $filename the name of the file used for logging, or false
+     * to stop debugging.
+     *
+     * @return void
+     */
+    public static function setDebug($filename = '')
+    {
+        if ($filename != false && gettype($filename) != 'string') {
+            phpCAS :: error('type mismatched for parameter $dbg (should be false or the name of the log file)');
+        }
+        if ($filename === false) {
+            self::$_PHPCAS_DEBUG['filename'] = false;
+
+        } else {
+            if (empty ($filename)) {
+                if (preg_match('/^Win.*/', getenv('OS'))) {
+                    if (isset ($_ENV['TMP'])) {
+                        $debugDir = $_ENV['TMP'] . '/';
+                    } else {
+                        $debugDir = '';
+                    }
+                } else {
+                    $debugDir = DEFAULT_DEBUG_DIR;
+                }
+                $filename = $debugDir . 'phpCAS.log';
+            }
+
+            if (empty (self::$_PHPCAS_DEBUG['unique_id'])) {
+                self::$_PHPCAS_DEBUG['unique_id'] = substr(strtoupper(md5(uniqid(''))), 0, 4);
+            }
+
+            self::$_PHPCAS_DEBUG['filename'] = $filename;
+            self::$_PHPCAS_DEBUG['indent'] = 0;
+
+            phpCAS :: trace('START phpCAS-' . PHPCAS_VERSION . ' ******************');
+        }
+    }
+
+
+    /**
+     * Logs a string in debug mode.
+     *
+     * @param string $str the string to write
+     *
+     * @return void
+     * @private
+     */
+    public static function log($str)
+    {
+        $indent_str = ".";
+
+
+        if (!empty(self::$_PHPCAS_DEBUG['filename'])) {
+            // Check if file exists and modifiy file permissions to be only
+            // readable by the webserver
+            if (!file_exists(self::$_PHPCAS_DEBUG['filename'])) {
+                touch(self::$_PHPCAS_DEBUG['filename']);
+                // Chmod will fail on windows
+                @chmod(self::$_PHPCAS_DEBUG['filename'], 0600);
+            }
+            for ($i = 0; $i < self::$_PHPCAS_DEBUG['indent']; $i++) {
+
+                $indent_str .= '|    ';
+            }
+            // allow for multiline output with proper identing. Usefull for dumping cas answers etc.
+            $str2 = str_replace("\n", "\n" . self::$_PHPCAS_DEBUG['unique_id'] . ' ' . $indent_str, $str);
+            error_log(self::$_PHPCAS_DEBUG['unique_id'] . ' ' . $indent_str . $str2 . "\n", 3, self::$_PHPCAS_DEBUG['filename']);
+        }
+
+    }
+
+    /**
+     * This method is used by interface methods to print an error and where the
+     * function was originally called from.
+     *
+     * @param string $msg the message to print
+     *
+     * @return void
+     * @private
+     */
+    public static function error($msg)
+    {
+        $dbg = debug_backtrace();
+        $function = '?';
+        $file = '?';
+        $line = '?';
+        if (is_array($dbg)) {
+            for ($i = 1; $i < sizeof($dbg); $i++) {
+                if (is_array($dbg[$i]) && isset($dbg[$i]['class']) ) {
+                    if ($dbg[$i]['class'] == __CLASS__) {
+                        $function = $dbg[$i]['function'];
+                        $file = $dbg[$i]['file'];
+                        $line = $dbg[$i]['line'];
+                    }
+                }
+            }
+        }
+        echo "<br />\n<b>phpCAS error</b>: <font color=\"FF0000\"><b>" . __CLASS__ . "::" . $function . '(): ' . htmlentities($msg) . "</b></font> in <b>" . $file . "</b> on line <b>" . $line . "</b><br />\n";
+        phpCAS :: trace($msg);
+        phpCAS :: traceEnd();
+
+        throw new CAS_GracefullTerminationException(__CLASS__ . "::" . $function . '(): ' . $msg);
+    }
+
+    /**
+     * This method is used to log something in debug mode.
+     *
+     * @param string $str string to log
+     *
+     * @return void
+     */
+    public static function trace($str)
+    {
+        $dbg = debug_backtrace();
+        phpCAS :: log($str . ' [' . basename($dbg[0]['file']) . ':' . $dbg[0]['line'] . ']');
+    }
+
+    /**
+     * This method is used to indicate the start of the execution of a function in debug mode.
+     *
+     * @return void
+     */
+    public static function traceBegin()
+    {
+        $dbg = debug_backtrace();
+        $str = '=> ';
+        if (!empty ($dbg[1]['class'])) {
+            $str .= $dbg[1]['class'] . '::';
+        }
+        $str .= $dbg[1]['function'] . '(';
+        if (is_array($dbg[1]['args'])) {
+            foreach ($dbg[1]['args'] as $index => $arg) {
+                if ($index != 0) {
+                    $str .= ', ';
+                }
+                if (is_object($arg)) {
+                    $str .= get_class($arg);
+                } else {
+                    $str .= str_replace(array("\r\n", "\n", "\r"), "", var_export($arg, true));
+                }
+            }
+        }
+        if (isset($dbg[1]['file'])) {
+            $file = basename($dbg[1]['file']);
+        } else {
+            $file = 'unknown_file';
+        }
+        if (isset($dbg[1]['line'])) {
+            $line = $dbg[1]['line'];
+        } else {
+            $line = 'unknown_line';
+        }
+        $str .= ') [' . $file . ':' . $line . ']';
+        phpCAS :: log($str);
+        if (!isset(self::$_PHPCAS_DEBUG['indent'])) {
+            self::$_PHPCAS_DEBUG['indent'] = 0;
+        } else {
+            self::$_PHPCAS_DEBUG['indent']++;
+        }
+    }
+
+    /**
+     * This method is used to indicate the end of the execution of a function in
+     * debug mode.
+     *
+     * @param string $res the result of the function
+     *
+     * @return void
+     */
+    public static function traceEnd($res = '')
+    {
+        if (empty(self::$_PHPCAS_DEBUG['indent'])) {
+            self::$_PHPCAS_DEBUG['indent'] = 0;
+        } else {
+            self::$_PHPCAS_DEBUG['indent']--;
+        }
+        $dbg = debug_backtrace();
+        $str = '';
+        if (is_object($res)) {
+            $str .= '<= ' . get_class($res);
+        } else {
+            $str .= '<= ' . str_replace(array("\r\n", "\n", "\r"), "", var_export($res, true));
+        }
+
+        phpCAS :: log($str);
+    }
+
+    /**
+     * This method is used to indicate the end of the execution of the program
+     *
+     * @return void
+     */
+    public static function traceExit()
+    {
+        phpCAS :: log('exit()');
+        while (self::$_PHPCAS_DEBUG['indent'] > 0) {
+            phpCAS :: log('-');
+            self::$_PHPCAS_DEBUG['indent']--;
+        }
+    }
+
+    /** @} */
+    // ########################################################################
+    //  INTERNATIONALIZATION
+    // ########################################################################
+    /**
+    * @addtogroup publicLang
+    * @{
+    */
+
+    /**
+     * This method is used to set the language used by phpCAS.
+     *
+     * @param string $lang string representing the language.
+     *
+     * @return void
+     *
+     * @sa PHPCAS_LANG_FRENCH, PHPCAS_LANG_ENGLISH
+     * @note Can be called only once.
+     */
+    public static function setLang($lang)
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+        if (gettype($lang) != 'string') {
+            phpCAS :: error('type mismatched for parameter $lang (should be `string\')');
+        }
+        self::$_PHPCAS_CLIENT->setLang($lang);
+    }
+
+    /** @} */
+    // ########################################################################
+    //  VERSION
+    // ########################################################################
+    /**
+    * @addtogroup public
+    * @{
+    */
+
+    /**
+     * This method returns the phpCAS version.
+     *
+     * @return the phpCAS version.
+     */
+    public static function getVersion()
+    {
+        return PHPCAS_VERSION;
+    }
+
+    /** @} */
+    // ########################################################################
+    //  HTML OUTPUT
+    // ########################################################################
+    /**
+    * @addtogroup publicOutput
+    * @{
+    */
+
+    /**
+     * This method sets the HTML header used for all outputs.
+     *
+     * @param string $header the HTML header.
+     *
+     * @return void
+     */
+    public static function setHTMLHeader($header)
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+        if (gettype($header) != 'string') {
+            phpCAS :: error('type mismatched for parameter $header (should be `string\')');
+        }
+        self::$_PHPCAS_CLIENT->setHTMLHeader($header);
+    }
+
+    /**
+     * This method sets the HTML footer used for all outputs.
+     *
+     * @param string $footer the HTML footer.
+     *
+     * @return void
+     */
+    public static function setHTMLFooter($footer)
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+        if (gettype($footer) != 'string') {
+            phpCAS :: error('type mismatched for parameter $footer (should be `string\')');
+        }
+        self::$_PHPCAS_CLIENT->setHTMLFooter($footer);
+    }
+
+    /** @} */
+    // ########################################################################
+    //  PGT STORAGE
+    // ########################################################################
+    /**
+    * @addtogroup publicPGTStorage
+    * @{
+    */
+
+    /**
+     * This method can be used to set a custom PGT storage object.
+     *
+     * @param CAS_PGTStorage $storage a PGT storage object that inherits from the
+     * CAS_PGTStorage class
+     *
+     * @return void
+     */
+    public static function setPGTStorage($storage)
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->isProxy()) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (self::$_PHPCAS_CLIENT->wasAuthenticationCalled()) {
+            phpCAS :: error('this method should only be called before ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerMethod() . '() (called at ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerFile() . ':' . self::$_PHPCAS_CLIENT->getAuthenticationCallerLine() . ')');
+        }
+        if ( !($storage instanceof CAS_PGTStorage) ) {
+            phpCAS :: error('type mismatched for parameter $storage (should be a CAS_PGTStorage `object\')');
+        }
+        self::$_PHPCAS_CLIENT->setPGTStorage($storage);
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * This method is used to tell phpCAS to store the response of the
+     * CAS server to PGT requests in a database.
+     *
+     * @param string $dsn_or_pdo     a dsn string to use for creating a PDO
+     * object or a PDO object
+     * @param string $username       the username to use when connecting to the
+     * database
+     * @param string $password       the password to use when connecting to the
+     * database
+     * @param string $table          the table to use for storing and retrieving
+     * PGT's
+     * @param string $driver_options any driver options to use when connecting
+     * to the database
+     *
+     * @return void
+     */
+    public static function setPGTStorageDb($dsn_or_pdo, $username='',
+        $password='', $table='', $driver_options=null
+    ) {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->isProxy()) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (self::$_PHPCAS_CLIENT->wasAuthenticationCalled()) {
+            phpCAS :: error('this method should only be called before ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerMethod() . '() (called at ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerFile() . ':' . self::$_PHPCAS_CLIENT->getAuthenticationCallerLine() . ')');
+        }
+        if (gettype($username) != 'string') {
+            phpCAS :: error('type mismatched for parameter $username (should be `string\')');
+        }
+        if (gettype($password) != 'string') {
+            phpCAS :: error('type mismatched for parameter $password (should be `string\')');
+        }
+        if (gettype($table) != 'string') {
+            phpCAS :: error('type mismatched for parameter $table (should be `string\')');
+        }
+        self::$_PHPCAS_CLIENT->setPGTStorageDb($dsn_or_pdo, $username, $password, $table, $driver_options);
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * This method is used to tell phpCAS to store the response of the
+     * CAS server to PGT requests onto the filesystem.
+     *
+     * @param string $path the path where the PGT's should be stored
+     *
+     * @return void
+     */
+    public static function setPGTStorageFile($path = '')
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->isProxy()) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (self::$_PHPCAS_CLIENT->wasAuthenticationCalled()) {
+            phpCAS :: error('this method should only be called before ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerMethod() . '() (called at ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerFile() . ':' . self::$_PHPCAS_CLIENT->getAuthenticationCallerLine() . ')');
+        }
+        if (gettype($path) != 'string') {
+            phpCAS :: error('type mismatched for parameter $path (should be `string\')');
+        }
+        self::$_PHPCAS_CLIENT->setPGTStorageFile($path);
+        phpCAS :: traceEnd();
+    }
+    /** @} */
+    // ########################################################################
+    // ACCESS TO EXTERNAL SERVICES
+    // ########################################################################
+    /**
+    * @addtogroup publicServices
+    * @{
+    */
+
+    /**
+     * Answer a proxy-authenticated service handler.
+     *
+     * @param string $type The service type. One of
+     * PHPCAS_PROXIED_SERVICE_HTTP_GET; PHPCAS_PROXIED_SERVICE_HTTP_POST;
+     * PHPCAS_PROXIED_SERVICE_IMAP
+     *
+     * @return CAS_ProxiedService
+     * @throws InvalidArgumentException If the service type is unknown.
+     */
+    public static function getProxiedService ($type)
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->isProxy()) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCalled()) {
+            phpCAS :: error('this method should only be called after the programmer is sure the user has been authenticated (by calling ' . __CLASS__ . '::checkAuthentication() or ' . __CLASS__ . '::forceAuthentication()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCallSuccessful()) {
+            phpCAS :: error('authentication was checked (by ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerMethod() . '() at ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerFile() . ':' . self::$_PHPCAS_CLIENT->getAuthenticationCallerLine() . ') but the method returned false');
+        }
+        if (gettype($type) != 'string') {
+            phpCAS :: error('type mismatched for parameter $type (should be `string\')');
+        }
+
+        $res = self::$_PHPCAS_CLIENT->getProxiedService($type);
+
+        phpCAS :: traceEnd();
+        return $res;
+    }
+
+    /**
+     * Initialize a proxied-service handler with the proxy-ticket it should use.
+     *
+     * @param CAS_ProxiedService $proxiedService Proxied Service Handler
+     *
+     * @return void
+     * @throws CAS_ProxyTicketException If there is a proxy-ticket failure.
+     *		The code of the Exception will be one of:
+     *			PHPCAS_SERVICE_PT_NO_SERVER_RESPONSE
+     *			PHPCAS_SERVICE_PT_BAD_SERVER_RESPONSE
+     *			PHPCAS_SERVICE_PT_FAILURE
+     */
+    public static function initializeProxiedService (CAS_ProxiedService $proxiedService)
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->isProxy()) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCalled()) {
+            phpCAS :: error('this method should only be called after the programmer is sure the user has been authenticated (by calling ' . __CLASS__ . '::checkAuthentication() or ' . __CLASS__ . '::forceAuthentication()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCallSuccessful()) {
+            phpCAS :: error('authentication was checked (by ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerMethod() . '() at ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerFile() . ':' . self::$_PHPCAS_CLIENT->getAuthenticationCallerLine() . ') but the method returned false');
+        }
+
+        self::$_PHPCAS_CLIENT->initializeProxiedService($proxiedService);
+    }
+
+    /**
+     * This method is used to access an HTTP[S] service.
+     *
+     * @param string $url       the service to access.
+     * @param string &$err_code an error code Possible values are
+     * PHPCAS_SERVICE_OK (on success), PHPCAS_SERVICE_PT_NO_SERVER_RESPONSE,
+     * PHPCAS_SERVICE_PT_BAD_SERVER_RESPONSE, PHPCAS_SERVICE_PT_FAILURE,
+     * PHPCAS_SERVICE_NOT_AVAILABLE.
+     * @param string &$output   the output of the service (also used to give an
+     * error message on failure).
+     *
+     * @return bool true on success, false otherwise (in this later case,
+     * $err_code gives the reason why it failed and $output contains an error
+     * message).
+     */
+    public static function serviceWeb($url, & $err_code, & $output)
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->isProxy()) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCalled()) {
+            phpCAS :: error('this method should only be called after the programmer is sure the user has been authenticated (by calling ' . __CLASS__ . '::checkAuthentication() or ' . __CLASS__ . '::forceAuthentication()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCallSuccessful()) {
+            phpCAS :: error('authentication was checked (by ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerMethod() . '() at ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerFile() . ':' . self::$_PHPCAS_CLIENT->getAuthenticationCallerLine() . ') but the method returned false');
+        }
+        if (gettype($url) != 'string') {
+            phpCAS :: error('type mismatched for parameter $url (should be `string\')');
+        }
+
+        $res = self::$_PHPCAS_CLIENT->serviceWeb($url, $err_code, $output);
+
+        phpCAS :: traceEnd($res);
+        return $res;
+    }
+
+    /**
+     * This method is used to access an IMAP/POP3/NNTP service.
+     *
+     * @param string $url       a string giving the URL of the service,
+     * including the mailing box for IMAP URLs, as accepted by imap_open().
+     * @param string $service   a string giving for CAS retrieve Proxy ticket
+     * @param string $flags     options given to imap_open().
+     * @param string &$err_code an error code Possible values are
+     * PHPCAS_SERVICE_OK (on success), PHPCAS_SERVICE_PT_NO_SERVER_RESPONSE,
+     * PHPCAS_SERVICE_PT_BAD_SERVER_RESPONSE, PHPCAS_SERVICE_PT_FAILURE,
+     * PHPCAS_SERVICE_NOT_AVAILABLE.
+     * @param string &$err_msg  an error message on failure
+     * @param string &$pt       the Proxy Ticket (PT) retrieved from the CAS
+     * server to access the URL on success, false on error).
+     *
+     * @return object IMAP stream on success, false otherwise (in this later
+     * case, $err_code gives the reason why it failed and $err_msg contains an
+     * error message).
+     */
+    public static function serviceMail($url, $service, $flags, & $err_code, & $err_msg, & $pt)
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->isProxy()) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCalled()) {
+            phpCAS :: error('this method should only be called after the programmer is sure the user has been authenticated (by calling ' . __CLASS__ . '::checkAuthentication() or ' . __CLASS__ . '::forceAuthentication()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCallSuccessful()) {
+            phpCAS :: error('authentication was checked (by ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerMethod() . '() at ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerFile() . ':' . self::$_PHPCAS_CLIENT->getAuthenticationCallerLine() . ') but the method returned false');
+        }
+        if (gettype($url) != 'string') {
+            phpCAS :: error('type mismatched for parameter $url (should be `string\')');
+        }
+
+        if (gettype($flags) != 'integer') {
+            phpCAS :: error('type mismatched for parameter $flags (should be `integer\')');
+        }
+
+        $res = self::$_PHPCAS_CLIENT->serviceMail($url, $service, $flags, $err_code, $err_msg, $pt);
+
+        phpCAS :: traceEnd($res);
+        return $res;
+    }
+
+    /** @} */
+    // ########################################################################
+    //  AUTHENTICATION
+    // ########################################################################
+    /**
+    * @addtogroup publicAuth
+    * @{
+    */
+
+    /**
+     * Set the times authentication will be cached before really accessing the
+     * CAS server in gateway mode:
+     * - -1: check only once, and then never again (until you pree login)
+     * - 0: always check
+     * - n: check every "n" time
+     *
+     * @param int $n an integer.
+     *
+     * @return void
+     */
+    public static function setCacheTimesForAuthRecheck($n)
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+        if (gettype($n) != 'integer') {
+            phpCAS :: error('type mismatched for parameter $n (should be `integer\')');
+        }
+        self::$_PHPCAS_CLIENT->setCacheTimesForAuthRecheck($n);
+    }
+
+    /**
+     * Set a callback function to be run when a user authenticates.
+     *
+     * The callback function will be passed a $logoutTicket as its first
+     * parameter, followed by any $additionalArgs you pass. The $logoutTicket
+     * parameter is an opaque string that can be used to map the session-id to
+     * logout request in order to support single-signout in applications that
+     * manage their own sessions (rather than letting phpCAS start the session).
+     *
+     * phpCAS::forceAuthentication() will always exit and forward client unless
+     * they are already authenticated. To perform an action at the moment the user
+     * logs in (such as registering an account, performing logging, etc), register
+     * a callback function here.
+     *
+     * @param string $function       Callback function
+     * @param array  $additionalArgs optional array of arguments
+     *
+     * @return void
+     */
+    public static function setPostAuthenticateCallback ($function, array $additionalArgs = array())
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+
+        self::$_PHPCAS_CLIENT->setPostAuthenticateCallback($function, $additionalArgs);
+    }
+
+    /**
+     * Set a callback function to be run when a single-signout request is
+     * received. The callback function will be passed a $logoutTicket as its
+     * first parameter, followed by any $additionalArgs you pass. The
+     * $logoutTicket parameter is an opaque string that can be used to map a
+     * session-id to the logout request in order to support single-signout in
+     * applications that manage their own sessions (rather than letting phpCAS
+     * start and destroy the session).
+     *
+     * @param string $function       Callback function
+     * @param array  $additionalArgs optional array of arguments
+     *
+     * @return void
+     */
+    public static function setSingleSignoutCallback ($function, array $additionalArgs = array())
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+
+        self::$_PHPCAS_CLIENT->setSingleSignoutCallback($function, $additionalArgs);
+    }
+
+    /**
+     * This method is called to check if the user is already authenticated
+     * locally or has a global cas session. A already existing cas session is
+     * determined by a cas gateway call.(cas login call without any interactive
+     * prompt)
+     *
+     * @return true when the user is authenticated, false when a previous
+     * gateway login failed or the function will not return if the user is
+     * redirected to the cas server for a gateway login attempt
+     */
+    public static function checkAuthentication()
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+
+        $auth = self::$_PHPCAS_CLIENT->checkAuthentication();
+
+        // store where the authentication has been checked and the result
+        self::$_PHPCAS_CLIENT->markAuthenticationCall($auth);
+
+        phpCAS :: traceEnd($auth);
+        return $auth;
+    }
+
+    /**
+     * This method is called to force authentication if the user was not already
+     * authenticated. If the user is not authenticated, halt by redirecting to
+     * the CAS server.
+     *
+     * @return bool Authentication
+     */
+    public static function forceAuthentication()
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+
+        $auth = self::$_PHPCAS_CLIENT->forceAuthentication();
+
+        // store where the authentication has been checked and the result
+        self::$_PHPCAS_CLIENT->markAuthenticationCall($auth);
+
+        /*		if (!$auth) {
+         phpCAS :: trace('user is not authenticated, redirecting to the CAS server');
+        self::$_PHPCAS_CLIENT->forceAuthentication();
+        } else {
+        phpCAS :: trace('no need to authenticate (user `' . phpCAS :: getUser() . '\' is already authenticated)');
+        }*/
+
+        phpCAS :: traceEnd();
+        return $auth;
+    }
+
+    /**
+     * This method is called to renew the authentication.
+     *
+     * @return void
+     **/
+    public static function renewAuthentication()
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+        $auth = self::$_PHPCAS_CLIENT->renewAuthentication();
+
+        // store where the authentication has been checked and the result
+        self::$_PHPCAS_CLIENT->markAuthenticationCall($auth);
+
+        //self::$_PHPCAS_CLIENT->renewAuthentication();
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * This method is called to check if the user is authenticated (previously or by
+     * tickets given in the URL).
+     *
+     * @return true when the user is authenticated.
+     */
+    public static function isAuthenticated()
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+
+        // call the isAuthenticated method of the $_PHPCAS_CLIENT object
+        $auth = self::$_PHPCAS_CLIENT->isAuthenticated();
+
+        // store where the authentication has been checked and the result
+        self::$_PHPCAS_CLIENT->markAuthenticationCall($auth);
+
+        phpCAS :: traceEnd($auth);
+        return $auth;
+    }
+
+    /**
+     * Checks whether authenticated based on $_SESSION. Useful to avoid
+     * server calls.
+     *
+     * @return bool true if authenticated, false otherwise.
+     * @since 0.4.22 by Brendan Arnold
+     */
+    public static function isSessionAuthenticated()
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+        return (self::$_PHPCAS_CLIENT->isSessionAuthenticated());
+    }
+
+    /**
+     * This method returns the CAS user's login name.
+     *
+     * @return string the login name of the authenticated user
+     * @warning should not be called only after phpCAS::forceAuthentication()
+     * or phpCAS::checkAuthentication().
+     * */
+    public static function getUser()
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCalled()) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::forceAuthentication() or ' . __CLASS__ . '::isAuthenticated()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCallSuccessful()) {
+            phpCAS :: error('authentication was checked (by ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerMethod() . '() at ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerFile() . ':' . self::$_PHPCAS_CLIENT->getAuthenticationCallerLine() . ') but the method returned false');
+        }
+        return self::$_PHPCAS_CLIENT->getUser();
+    }
+
+    /**
+     * Answer attributes about the authenticated user.
+     *
+     * @warning should not be called only after phpCAS::forceAuthentication()
+     * or phpCAS::checkAuthentication().
+     *
+     * @return array
+     */
+    public static function getAttributes()
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCalled()) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::forceAuthentication() or ' . __CLASS__ . '::isAuthenticated()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCallSuccessful()) {
+            phpCAS :: error('authentication was checked (by ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerMethod() . '() at ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerFile() . ':' . self::$_PHPCAS_CLIENT->getAuthenticationCallerLine() . ') but the method returned false');
+        }
+        return self::$_PHPCAS_CLIENT->getAttributes();
+    }
+
+    /**
+     * Answer true if there are attributes for the authenticated user.
+     *
+     * @warning should not be called only after phpCAS::forceAuthentication()
+     * or phpCAS::checkAuthentication().
+     *
+     * @return bool
+     */
+    public static function hasAttributes()
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCalled()) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::forceAuthentication() or ' . __CLASS__ . '::isAuthenticated()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCallSuccessful()) {
+            phpCAS :: error('authentication was checked (by ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerMethod() . '() at ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerFile() . ':' . self::$_PHPCAS_CLIENT->getAuthenticationCallerLine() . ') but the method returned false');
+        }
+        return self::$_PHPCAS_CLIENT->hasAttributes();
+    }
+
+    /**
+     * Answer true if an attribute exists for the authenticated user.
+     *
+     * @param string $key attribute name
+     *
+     * @return bool
+     * @warning should not be called only after phpCAS::forceAuthentication()
+     * or phpCAS::checkAuthentication().
+     */
+    public static function hasAttribute($key)
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCalled()) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::forceAuthentication() or ' . __CLASS__ . '::isAuthenticated()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCallSuccessful()) {
+            phpCAS :: error('authentication was checked (by ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerMethod() . '() at ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerFile() . ':' . self::$_PHPCAS_CLIENT->getAuthenticationCallerLine() . ') but the method returned false');
+        }
+        return self::$_PHPCAS_CLIENT->hasAttribute($key);
+    }
+
+    /**
+     * Answer an attribute for the authenticated user.
+     *
+     * @param string $key attribute name
+     *
+     * @return mixed string for a single value or an array if multiple values exist.
+     * @warning should not be called only after phpCAS::forceAuthentication()
+     * or phpCAS::checkAuthentication().
+     */
+    public static function getAttribute($key)
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCalled()) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::forceAuthentication() or ' . __CLASS__ . '::isAuthenticated()');
+        }
+        if (!self::$_PHPCAS_CLIENT->wasAuthenticationCallSuccessful()) {
+            phpCAS :: error('authentication was checked (by ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerMethod() . '() at ' . self::$_PHPCAS_CLIENT->getAuthenticationCallerFile() . ':' . self::$_PHPCAS_CLIENT->getAuthenticationCallerLine() . ') but the method returned false');
+        }
+        return self::$_PHPCAS_CLIENT->getAttribute($key);
+    }
+
+    /**
+     * Handle logout requests.
+     *
+     * @param bool  $check_client    additional safety check
+     * @param array $allowed_clients array of allowed clients
+     *
+     * @return void
+     */
+    public static function handleLogoutRequests($check_client = true, $allowed_clients = false)
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+        return (self::$_PHPCAS_CLIENT->handleLogoutRequests($check_client, $allowed_clients));
+    }
+
+    /**
+     * This method returns the URL to be used to login.
+     * or phpCAS::isAuthenticated().
+     *
+     * @return the login name of the authenticated user
+     */
+    public static function getServerLoginURL()
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+        return self::$_PHPCAS_CLIENT->getServerLoginURL();
+    }
+
+    /**
+     * Set the login URL of the CAS server.
+     *
+     * @param string $url the login URL
+     *
+     * @return void
+     * @since 0.4.21 by Wyman Chan
+     */
+    public static function setServerLoginURL($url = '')
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after' . __CLASS__ . '::client()');
+        }
+        if (gettype($url) != 'string') {
+            phpCAS :: error('type mismatched for parameter $url (should be `string`)');
+        }
+        self::$_PHPCAS_CLIENT->setServerLoginURL($url);
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * Set the serviceValidate URL of the CAS server.
+     * Used only in CAS 1.0 validations
+     *
+     * @param string $url the serviceValidate URL
+     *
+     * @return void
+     */
+    public static function setServerServiceValidateURL($url = '')
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after' . __CLASS__ . '::client()');
+        }
+        if (gettype($url) != 'string') {
+            phpCAS :: error('type mismatched for parameter $url (should be `string`)');
+        }
+        self::$_PHPCAS_CLIENT->setServerServiceValidateURL($url);
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * Set the proxyValidate URL of the CAS server.
+     * Used for all CAS 2.0 validations
+     *
+     * @param string $url the proxyValidate URL
+     *
+     * @return void
+     */
+    public static function setServerProxyValidateURL($url = '')
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after' . __CLASS__ . '::client()');
+        }
+        if (gettype($url) != 'string') {
+            phpCAS :: error('type mismatched for parameter $url (should be `string`)');
+        }
+        self::$_PHPCAS_CLIENT->setServerProxyValidateURL($url);
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * Set the samlValidate URL of the CAS server.
+     *
+     * @param string $url the samlValidate URL
+     *
+     * @return void
+     */
+    public static function setServerSamlValidateURL($url = '')
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after' . __CLASS__ . '::client()');
+        }
+        if (gettype($url) != 'string') {
+            phpCAS :: error('type mismatched for parameter $url (should be`string\')');
+        }
+        self::$_PHPCAS_CLIENT->setServerSamlValidateURL($url);
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * This method returns the URL to be used to login.
+     * or phpCAS::isAuthenticated().
+     *
+     * @return the login name of the authenticated user
+     */
+    public static function getServerLogoutURL()
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+        return self::$_PHPCAS_CLIENT->getServerLogoutURL();
+    }
+
+    /**
+     * Set the logout URL of the CAS server.
+     *
+     * @param string $url the logout URL
+     *
+     * @return void
+     * @since 0.4.21 by Wyman Chan
+     */
+    public static function setServerLogoutURL($url = '')
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error(
+                'this method should only be called after' . __CLASS__ . '::client()'
+            );
+        }
+        if (gettype($url) != 'string') {
+            phpCAS :: error(
+                'type mismatched for parameter $url (should be `string`)'
+            );
+        }
+        self::$_PHPCAS_CLIENT->setServerLogoutURL($url);
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * This method is used to logout from CAS.
+     *
+     * @param string $params an array that contains the optional url and
+     * service parameters that will be passed to the CAS server
+     *
+     * @return void
+     */
+    public static function logout($params = "")
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::client() or' . __CLASS__ . '::proxy()');
+        }
+        $parsedParams = array ();
+        if ($params != "") {
+            if (is_string($params)) {
+                phpCAS :: error('method `phpCAS::logout($url)\' is now deprecated, use `phpCAS::logoutWithUrl($url)\' instead');
+            }
+            if (!is_array($params)) {
+                phpCAS :: error('type mismatched for parameter $params (should be `array\')');
+            }
+            foreach ($params as $key => $value) {
+                if ($key != "service" && $key != "url") {
+                    phpCAS :: error('only `url\' and `service\' parameters are allowed for method `phpCAS::logout($params)\'');
+                }
+                $parsedParams[$key] = $value;
+            }
+        }
+        self::$_PHPCAS_CLIENT->logout($parsedParams);
+        // never reached
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * This method is used to logout from CAS. Halts by redirecting to the CAS
+     * server.
+     *
+     * @param service $service a URL that will be transmitted to the CAS server
+     *
+     * @return void
+     */
+    public static function logoutWithRedirectService($service)
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::client() or' . __CLASS__ . '::proxy()');
+        }
+        if (!is_string($service)) {
+            phpCAS :: error('type mismatched for parameter $service (should be `string\')');
+        }
+        self::$_PHPCAS_CLIENT->logout(array ( "service" => $service ));
+        // never reached
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * This method is used to logout from CAS. Halts by redirecting to the CAS
+     * server.
+     *
+     * @param string $url a URL that will be transmitted to the CAS server
+     *
+     * @return void
+     * @deprecated The url parameter has been removed from the CAS server as of
+     * version 3.3.5.1
+     */
+    public static function logoutWithUrl($url)
+    {
+//----- Debut ajout CI (eviter un warning) -----
+//        trigger_error('Function deprecated for cas servers >= 3.3.5.1', E_USER_DEPRECATED);
+//----- Fin ajout CI -----
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::client() or' . __CLASS__ . '::proxy()');
+        }
+        if (!is_string($url)) {
+            phpCAS :: error('type mismatched for parameter $url (should be `string\')');
+        }
+        self::$_PHPCAS_CLIENT->logout(array ( "url" => $url ));
+        // never reached
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * This method is used to logout from CAS. Halts by redirecting to the CAS
+     * server.
+     *
+     * @param string $service a URL that will be transmitted to the CAS server
+     * @param string $url     a URL that will be transmitted to the CAS server
+     *
+     * @return void
+     *
+     * @deprecated The url parameter has been removed from the CAS server as of
+     * version 3.3.5.1
+     */
+    public static function logoutWithRedirectServiceAndUrl($service, $url)
+    {
+        trigger_error('Function deprecated for cas servers >= 3.3.5.1', E_USER_DEPRECATED);
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::client() or' . __CLASS__ . '::proxy()');
+        }
+        if (!is_string($service)) {
+            phpCAS :: error('type mismatched for parameter $service (should be `string\')');
+        }
+        if (!is_string($url)) {
+            phpCAS :: error('type mismatched for parameter $url (should be `string\')');
+        }
+        self::$_PHPCAS_CLIENT->logout(
+            array (
+                "service" => $service,
+                "url" => $url
+            )
+        );
+        // never reached
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * Set the fixed URL that will be used by the CAS server to transmit the
+     * PGT. When this method is not called, a phpCAS script uses its own URL
+     * for the callback.
+     *
+     * @param string $url the URL
+     *
+     * @return void
+     */
+    public static function setFixedCallbackURL($url = '')
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (!self::$_PHPCAS_CLIENT->isProxy()) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (gettype($url) != 'string') {
+            phpCAS :: error('type mismatched for parameter $url (should be `string\')');
+        }
+        self::$_PHPCAS_CLIENT->setCallbackURL($url);
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * Set the fixed URL that will be set as the CAS service parameter. When this
+     * method is not called, a phpCAS script uses its own URL.
+     *
+     * @param string $url the URL
+     *
+     * @return void
+     */
+    public static function setFixedServiceURL($url)
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (gettype($url) != 'string') {
+            phpCAS :: error('type mismatched for parameter $url (should be `string\')');
+        }
+        self::$_PHPCAS_CLIENT->setURL($url);
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * Get the URL that is set as the CAS service parameter.
+     *
+     * @return string Service Url
+     */
+    public static function getServiceURL()
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        return (self::$_PHPCAS_CLIENT->getURL());
+    }
+
+    /**
+     * Retrieve a Proxy Ticket from the CAS server.
+     *
+     * @param string $target_service Url string of service to proxy
+     * @param string &$err_code      error code
+     * @param string &$err_msg       error message
+     *
+     * @return string Proxy Ticket
+     */
+    public static function retrievePT($target_service, & $err_code, & $err_msg)
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::proxy()');
+        }
+        if (gettype($target_service) != 'string') {
+            phpCAS :: error('type mismatched for parameter $target_service(should be `string\')');
+        }
+        return (self::$_PHPCAS_CLIENT->retrievePT($target_service, $err_code, $err_msg));
+    }
+
+    /**
+     * Retrieve a Ticket from the CAS server request.
+     *
+     * @return string Ticket
+     */
+    public static function getTicket()
+    {
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should not be called before ' . __CLASS__ . '::client() or ' . __CLASS__ . '::proxy()');
+        }
+        return self::$_PHPCAS_CLIENT->getTicket();
+    }
+    /**
+     * Set the certificate of the CAS server CA.
+     *
+     * @param string $cert CA certificate file name
+     *
+     * @return void
+     */
+    public static function setCasServerCACert($cert)
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::client() or' . __CLASS__ . '::proxy()');
+        }
+        if (gettype($cert) != 'string') {
+            phpCAS :: error('type mismatched for parameter $cert (should be `string\')');
+        }
+        self::$_PHPCAS_CLIENT->setCasServerCACert($cert);
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * Set no SSL validation for the CAS server.
+     *
+     * @return void
+     */
+    public static function setNoCasServerValidation()
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::client() or' . __CLASS__ . '::proxy()');
+        }
+        phpCAS :: trace('You have configured no validation of the legitimacy of the cas server. This is not recommended for production use.');
+        self::$_PHPCAS_CLIENT->setNoCasServerValidation();
+        phpCAS :: traceEnd();
+    }
+
+
+    /**
+     * Disable the removal of a CAS-Ticket from the URL when authenticating
+     * DISABLING POSES A SECURITY RISK:
+     * We normally remove the ticket by an additional redirect as a security
+     * precaution to prevent a ticket in the HTTP_REFERRER or be carried over in
+     * the URL parameter
+     *
+     * @return void
+     */
+    public static function setNoClearTicketsFromUrl()
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::client() or' . __CLASS__ . '::proxy()');
+        }
+        self::$_PHPCAS_CLIENT->setNoClearTicketsFromUrl();
+        phpCAS :: traceEnd();
+    }
+
+    /** @} */
+
+    /**
+     * Change CURL options.
+     * CURL is used to connect through HTTPS to CAS server
+     *
+     * @param string $key   the option key
+     * @param string $value the value to set
+     *
+     * @return void
+     */
+    public static function setExtraCurlOption($key, $value)
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::client() or' . __CLASS__ . '::proxy()');
+        }
+        self::$_PHPCAS_CLIENT->setExtraCurlOption($key, $value);
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * If you want your service to be proxied you have to enable it (default
+     * disabled) and define an accepable list of proxies that are allowed to
+     * proxy your service.
+     *
+     * Add each allowed proxy definition object. For the normal CAS_ProxyChain
+     * class, the constructor takes an array of proxies to match. The list is in
+     * reverse just as seen from the service. Proxies have to be defined in reverse
+     * from the service to the user. If a user hits service A and gets proxied via
+     * B to service C the list of acceptable on C would be array(B,A). The definition
+     * of an individual proxy can be either a string or a regexp (preg_match is used)
+     * that will be matched against the proxy list supplied by the cas server
+     * when validating the proxy tickets. The strings are compared starting from
+     * the beginning and must fully match with the proxies in the list.
+     * Example:
+     * 		phpCAS::allowProxyChain(new CAS_ProxyChain(array(
+     *				'https://app.example.com/'
+     *			)));
+     * 		phpCAS::allowProxyChain(new CAS_ProxyChain(array(
+     *				'/^https:\/\/app[0-9]\.example\.com\/rest\//',
+     *				'http://client.example.com/'
+     *			)));
+     *
+     * For quick testing or in certain production screnarios you might want to
+     * allow allow any other valid service to proxy your service. To do so, add
+     * the "Any" chain:
+     *		phpcas::allowProxyChain(new CAS_ProxyChain_Any);
+     * THIS SETTING IS HOWEVER NOT RECOMMENDED FOR PRODUCTION AND HAS SECURITY
+     * IMPLICATIONS: YOU ARE ALLOWING ANY SERVICE TO ACT ON BEHALF OF A USER
+     * ON THIS SERVICE.
+     *
+     * @param CAS_ProxyChain_Interface $proxy_chain A proxy-chain that will be
+     * matched against the proxies requesting access
+     *
+     * @return void
+     */
+    public static function allowProxyChain(CAS_ProxyChain_Interface $proxy_chain)
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::client() or' . __CLASS__ . '::proxy()');
+        }
+        if (self::$_PHPCAS_CLIENT->getServerVersion() !== CAS_VERSION_2_0) {
+            phpCAS :: error('this method can only be used with the cas 2.0 protool');
+        }
+        self::$_PHPCAS_CLIENT->getAllowedProxyChains()->allowProxyChain($proxy_chain);
+        phpCAS :: traceEnd();
+    }
+
+    /**
+     * Answer an array of proxies that are sitting in front of this application.
+     * This method will only return a non-empty array if we have received and
+     * validated a Proxy Ticket.
+     *
+     * @return array
+     * @access public
+     * @since 6/25/09
+     */
+    public static function getProxies ()
+    {
+        if ( !is_object(self::$_PHPCAS_CLIENT) ) {
+            phpCAS::error('this method should only be called after '.__CLASS__.'::client()');
+        }
+
+        return(self::$_PHPCAS_CLIENT->getProxies());
+    }
+
+    // ########################################################################
+    // PGTIOU/PGTID and logoutRequest rebroadcasting
+    // ########################################################################
+
+    /**
+     * Add a pgtIou/pgtId and logoutRequest rebroadcast node.
+     *
+     * @param string $rebroadcastNodeUrl The rebroadcast node URL. Can be
+     * hostname or IP.
+     *
+     * @return void
+     */
+    public static function addRebroadcastNode($rebroadcastNodeUrl)
+    {
+        phpCAS::traceBegin();
+        phpCAS::log('rebroadcastNodeUrl:'.$rebroadcastNodeUrl);
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::client() or' . __CLASS__ . '::proxy()');
+        }
+        if ( !(bool)preg_match("/^(http|https):\/\/([A-Z0-9][A-Z0-9_-]*(?:\.[A-Z0-9][A-Z0-9_-]*)+):?(\d+)?\/?/i", $rebroadcastNodeUrl)) {
+            phpCAS::error('type mismatched for parameter $rebroadcastNodeUrl (should be `url\')');
+        }
+        self::$_PHPCAS_CLIENT->addRebroadcastNode($rebroadcastNodeUrl);
+        phpCAS::traceEnd();
+    }
+
+    /**
+     * This method is used to add header parameters when rebroadcasting
+     * pgtIou/pgtId or logoutRequest.
+     *
+     * @param String $header Header to send when rebroadcasting.
+     *
+     * @return void
+     */
+    public static function addRebroadcastHeader($header)
+    {
+        phpCAS :: traceBegin();
+        if (!is_object(self::$_PHPCAS_CLIENT)) {
+            phpCAS :: error('this method should only be called after ' . __CLASS__ . '::client() or' . __CLASS__ . '::proxy()');
+        }
+        self::$_PHPCAS_CLIENT->addRebroadcastHeader($header);
+        phpCAS :: traceEnd();
+    }
+}
+
+// ########################################################################
+// DOCUMENTATION
+// ########################################################################
+
+// ########################################################################
+//  MAIN PAGE
+
+/**
+ * @mainpage
+ *
+ * The following pages only show the source documentation.
+ *
+ */
+
+// ########################################################################
+//  MODULES DEFINITION
+
+/** @defgroup public User interface */
+
+/** @defgroup publicInit Initialization
+ *  @ingroup public */
+
+/** @defgroup publicAuth Authentication
+ *  @ingroup public */
+
+/** @defgroup publicServices Access to external services
+ *  @ingroup public */
+
+/** @defgroup publicConfig Configuration
+ *  @ingroup public */
+
+/** @defgroup publicLang Internationalization
+ *  @ingroup publicConfig */
+
+/** @defgroup publicOutput HTML output
+ *  @ingroup publicConfig */
+
+/** @defgroup publicPGTStorage PGT storage
+ *  @ingroup publicConfig */
+
+/** @defgroup publicDebug Debugging
+ *  @ingroup public */
+
+/** @defgroup internal Implementation */
+
+/** @defgroup internalAuthentication Authentication
+ *  @ingroup internal */
+
+/** @defgroup internalBasic CAS Basic client features (CAS 1.0, Service Tickets)
+ *  @ingroup internal */
+
+/** @defgroup internalProxy CAS Proxy features (CAS 2.0, Proxy Granting Tickets)
+ *  @ingroup internal */
+
+/** @defgroup internalSAML CAS SAML features (SAML 1.1)
+ *  @ingroup internal */
+
+/** @defgroup internalPGTStorage PGT storage
+ *  @ingroup internalProxy */
+
+/** @defgroup internalPGTStorageDb PGT storage in a database
+ *  @ingroup internalPGTStorage */
+
+/** @defgroup internalPGTStorageFile PGT storage on the filesystem
+ *  @ingroup internalPGTStorage */
+
+/** @defgroup internalCallback Callback from the CAS server
+ *  @ingroup internalProxy */
+
+/** @defgroup internalProxyServices Proxy other services
+ *  @ingroup internalProxy */
+
+/** @defgroup internalService CAS client features (CAS 2.0, Proxied service)
+ *  @ingroup internal */
+
+/** @defgroup internalConfig Configuration
+ *  @ingroup internal */
+
+/** @defgroup internalBehave Internal behaviour of phpCAS
+ *  @ingroup internalConfig */
+
+/** @defgroup internalOutput HTML output
+ *  @ingroup internalConfig */
+
+/** @defgroup internalLang Internationalization
+ *  @ingroup internalConfig
+ *
+ * To add a new language:
+ * - 1. define a new constant PHPCAS_LANG_XXXXXX in CAS/CAS.php
+ * - 2. copy any file from CAS/languages to CAS/languages/XXXXXX.php
+ * - 3. Make the translations
+ */
+
+/** @defgroup internalDebug Debugging
+ *  @ingroup internal */
+
+/** @defgroup internalMisc Miscellaneous
+ *  @ingroup internal */
+
+// ########################################################################
+//  EXAMPLES
+
+/**
+ * @example example_simple.php
+ */
+/**
+ * @example example_service.php
+ */
+/**
+ * @example example_service_that_proxies.php
+ */
+/**
+ * @example example_service_POST.php
+ */
+/**
+ * @example example_proxy_serviceWeb.php
+ */
+/**
+ * @example example_proxy_serviceWeb_chaining.php
+ */
+/**
+ * @example example_proxy_POST.php
+ */
+/**
+ * @example example_proxy_GET.php
+ */
+/**
+ * @example example_lang.php
+ */
+/**
+ * @example example_html.php
+ */
+/**
+ * @example example_pgt_storage_file.php
+ */
+/**
+ * @example example_pgt_storage_db.php
+ */
+/**
+ * @example example_gateway.php
+ */
+/**
+ * @example example_logout.php
+ */
+/**
+ * @example example_rebroadcast.php
+ */
+/**
+ * @example example_custom_urls.php
+ */
+/**
+ * @example example_advanced_saml11.php
+ */
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/cicas_erreur1.html spip/extensions/cicas/cicas_erreur1.html
--- spip-ori/extensions/cicas/cicas_erreur1.html	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/cicas_erreur1.html	2013-04-05 11:06:41.181923140 +0200
@@ -0,0 +1,18 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="#LANG" lang="#LANG" dir="#LANG_DIR">
+<head>
+<title><:pass_erreur:> [(#NOM_SITE_SPIP|textebrut)]</title>
+<meta name="robots" content="none" />
+<meta http-equiv="Content-Type" content="text/html; charset=#CHARSET" />
+[<link href="(#CHEMIN{minipres.css})" rel="stylesheet" type="text/css">]
+</head>
+<body class='minipres'>
+	<div id='minipres'>
+
+        <h1><:pass_erreur:></h1>
+        <div><:cicas:eq_texte_erreur1:></div>
+		<p class="retour">[<a href="#URL_SITE_SPIP"><:retour_accueil:></a>]</p>
+		
+	</div>
+</body>
+</html>
diff -rNU5 spip-ori/extensions/cicas/cicas_erreur2_fonctions.php spip/extensions/cicas/cicas_erreur2_fonctions.php
--- spip-ori/extensions/cicas/cicas_erreur2_fonctions.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/cicas_erreur2_fonctions.php	2013-04-05 11:06:41.181923140 +0200
@@ -0,0 +1,59 @@
+<?php
+/**
+ * Plugin Authentification CAS
+ * Copyright (c) Christophe IMBERTI
+ * Licence Creative commons by-nc-sa
+ */
+
+/*-----------------------------------------------------------------
+// Filtre pour le logout de CAS dans le cas de l'erreur 2
+------------------------------------------------------------------*/
+
+function cicas_logout_cas() {
+	
+	global $visiteur_session;
+
+	include_spip('inc/cicas_commun');
+	
+	// import phpCAS lib
+	include_spip('CAS');
+
+	// Pour la solution hybride utilisation d'un cookie
+	if(isset($_COOKIE['cicas_sso']))
+		spip_setcookie('cicas_sso', '', time() - 3600);
+	
+	// D�terminer l'origine de l'appel (intranet, internet, ...)
+	// .i2 ou .ader.gouv.fr ou .gouv.fr ou .agri
+	$ciurlcas=cicas_url_serveur_cas();	
+
+	// initialize phpCAS
+	$cirep='';
+	$ciport=intval($GLOBALS['ciconfig']['cicasport']);
+	if (isset($GLOBALS['ciconfig']['cicasrepertoire'])) $cirep=$GLOBALS['ciconfig']['cicasrepertoire'];
+	
+	phpCAS::client(CAS_VERSION_2_0,$ciurlcas,$ciport,$cirep);
+	
+	phpCAS::setLang(cicas_lang_phpcas($_GET['lang']));
+
+	// D�terminer l'url retour
+	$ci_url_retour = cicas_url_retour('');
+	
+
+	// deconnexion de CAS uniquement si on n'est pas connecte dans SPIP
+	if (!isset($visiteur_session['id_auteur'])) {
+		// deconnexion de CAS avec l'url retour
+/*		
+		if (method_exists('phpCAS','logoutWithUrl')) {
+			// Compatibilit� avec les versions r�centes de phpCAS
+			phpCAS::logoutWithUrl(urlencode($ci_url_retour));
+		} else {
+			phpCAS::logout(urlencode($ci_url_retour));
+		}
+*/
+		phpCAS::logoutWithUrl(urlencode($ci_url_retour));
+	}
+	
+	return '';
+      	
+}	            	
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/cicas_erreur2.html spip/extensions/cicas/cicas_erreur2.html
--- spip-ori/extensions/cicas/cicas_erreur2.html	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/cicas_erreur2.html	2013-04-05 11:06:41.181923140 +0200
@@ -0,0 +1,21 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="#LANG" lang="#LANG" dir="#LANG_DIR">
+<head>
+<title><:pass_erreur:> [(#NOM_SITE_SPIP|textebrut)]</title>
+<meta name="robots" content="none" />
+<meta http-equiv="Content-Type" content="text/html; charset=#CHARSET" />
+[<link href="(#CHEMIN{minipres.css})" rel="stylesheet" type="text/css">]
+</head>
+<body class='minipres'>
+	<div id='minipres'>
+
+        <h1><:pass_erreur:></h1>
+        <div><:cicas:eq_texte_erreur2:></div>
+		<p class="retour">[<a href="[(#SELF|parametre_url{logout_cas,oui})]"><:cicas:eq_logout_cas:></a>]</p>
+
+		[(#ENV{logout_cas}|=={oui}|oui)
+			[(#ENV{logout_cas}|cicas_logout_cas)]
+		]		
+	</div>
+</body>
+</html>
diff -rNU5 spip-ori/extensions/cicas/cicas_erreur3.html spip/extensions/cicas/cicas_erreur3.html
--- spip-ori/extensions/cicas/cicas_erreur3.html	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/cicas_erreur3.html	2013-04-05 11:06:41.181923140 +0200
@@ -0,0 +1,18 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="#LANG" lang="#LANG" dir="#LANG_DIR">
+<head>
+<title><:pass_erreur:> [(#NOM_SITE_SPIP|textebrut)]</title>
+<meta name="robots" content="none" />
+<meta http-equiv="Content-Type" content="text/html; charset=#CHARSET" />
+[<link href="(#CHEMIN{minipres.css})" rel="stylesheet" type="text/css">]
+</head>
+<body class='minipres'>
+	<div id='minipres'>
+
+        <h1><:avis_erreur_connexion:></h1>
+        <div><:avis_erreur_visiteur:></div>
+		<p class="retour">[<a href="#URL_SITE_SPIP"><:retour_accueil:></a>]</p>
+		
+	</div>
+</body>
+</html>
diff -rNU5 spip-ori/extensions/cicas/cicas_pipeline.php spip/extensions/cicas/cicas_pipeline.php
--- spip-ori/extensions/cicas/cicas_pipeline.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/cicas_pipeline.php	2013-04-05 11:06:41.181923140 +0200
@@ -0,0 +1,48 @@
+<?php
+/**
+ * Plugin Authentification CAS
+ * Copyright (c) Christophe IMBERTI
+ * Licence Creative commons by-nc-sa
+ */
+ 
+/**
+ * Pipeline d'aiguillage entre les modes d'authentification
+ *
+ * @param $flux, $contexte
+ * @return $flux
+ */
+function cicas_recuperer_fond($flux){
+	
+	if ($flux['args']['fond']=='formulaires/login'){
+		
+		include_spip('inc/cicas_commun');
+	
+		// lire la configuration du plugin
+		cicas_lire_meta();
+
+		// authentification CAS
+		if ($GLOBALS['ciconfig']['cicas']=='oui' AND $GLOBALS['ciconfig']['cicasurldefaut']) {
+			include_spip('inc/cicas_login');
+
+		// authentification hybride CAS et SPIP
+		} elseif ($GLOBALS['ciconfig']['cicas']=='hybride') {
+			
+			// authentification CAS demandee par un clic sur le lien
+			if (_request('cicas') AND _request('cicas')=='oui') {
+				include_spip('inc/cicas_login');
+
+			} else {
+				// ajout du lien vers l'authentification CAS
+				include_spip("inc/utils");
+				$lien = parametre_url(self(), 'cicas', 'oui');
+				$lien = '<a href="'.$lien.'"><img alt="'._T('cicas:eq_lien_auth_hybride').'" src="'.find_in_path('cicas.gif').'" /></a>'
+				.'&nbsp;<a href="'.$lien.'" style="vertical-align:top;">&#91;'._T('cicas:eq_lien_auth_hybride').'&#93;</a>';
+				$flux['data']['texte'] = str_replace('</form>','</form>'.$lien,$flux['data']['texte']);
+			}
+		}
+	}
+	
+	return $flux;
+}
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/configuration/cicas_configuration.php spip/extensions/cicas/configuration/cicas_configuration.php
--- spip-ori/extensions/cicas/configuration/cicas_configuration.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/configuration/cicas_configuration.php	2013-04-05 11:06:41.181923140 +0200
@@ -0,0 +1,128 @@
+<?php
+/**
+ * Plugin Authentification CAS
+ * Copyright (c) Christophe IMBERTI
+ * Licence Creative commons by-nc-sa
+ */
+
+if (!defined("_ECRIRE_INC_VERSION")) return;
+
+include_spip('inc/presentation');
+include_spip('inc/config');
+include_spip('inc/cicas_commun');
+
+function configuration_cicas_configuration()
+{
+	// lire la configuration du plugin
+	$ciedit = cicas_lire_meta();
+	
+	$cicas = $GLOBALS['ciconfig']['cicas'];
+	$cicasurldefaut = $GLOBALS['ciconfig']['cicasurldefaut'];
+	$cicasrepertoire = $GLOBALS['ciconfig']['cicasrepertoire'];
+	$cicasuid = $GLOBALS['ciconfig']['cicasuid'];
+	$cicasport = $GLOBALS['ciconfig']['cicasport'];
+	
+	$action = generer_url_ecrire('cicas_config');
+	
+	$res .= "<form action='$action' method='post'>".form_hidden($action)
+	. "<input type='hidden' name='changer_config' value='oui' />";
+	
+	$res .= "<br />"._T('cicas:eq_avertissement')."<br />";
+	
+	$res .= "<br />\n"
+	. debut_cadre_relief("", true, "", _T('cicas:eq_titre_mode_auth'))
+	. "<table border='0' cellspacing='1' cellpadding='3' width=\"100%\">";
+
+	
+    // cicas
+	$res .= "\n<tr><td class='verdana2'>"
+	. cicas_afficher_choix('cicas', $cicas,
+		array('oui' => _T('cicas:eq_texte_auth_cas'),
+			'hybride' => _T('cicas:eq_texte_auth_hybride'),
+			'non' => _T('cicas:eq_texte_auth_spip')), " &nbsp; ", !$ciedit)
+	. "</td></tr>\n";
+	
+	$res .= "\n</table>"
+	. fin_cadre_relief(true);
+
+	$res .= "<br />\n"
+	. debut_cadre_relief("", true, "", _T('cicas:eq_titre_serveur_cas'))
+	. "<table border='0' cellspacing='1' cellpadding='3' width=\"100%\">";
+	
+    // cicasurldefaut
+	$res .= "\n<tr><td class='verdana2'>"
+	. "<label for='cicasurldefaut'>"._T('cicas:eq_texte_url')."</label><br />"
+	. " <input type='text' name='cicasurldefaut' id='cicasurldefaut' value=\"$cicasurldefaut\" size='40' class='formo' ".($ciedit ? "" : "disabled='disabled'"). "/><br />"
+	. "</td></tr>";
+
+    // cicasrepertoire
+	$res .= "\n<tr><td class='verdana2'>"
+	. "<label for='cicasrepertoire'>"._T('cicas:eq_texte_repertoire')."</label><br />"
+	. " <input type='text' name='cicasrepertoire' id='cicasrepertoire' value=\"$cicasrepertoire\" size='40' class='formo' ".($ciedit ? "" : "disabled='disabled'"). " /><br />"
+	. "</td></tr>";
+	
+    // cicasport
+	$res .= "\n<tr><td class='verdana2'>"
+	. "<label for='cicasport'>"._T('cicas:eq_texte_port')."</label><br />"
+	. " <input type='text' name='cicasport' id='cicasport' value=\"$cicasport\" size='40' class='formo' ".($ciedit ? "" : "disabled='disabled'"). "/><br />"
+	. "</td></tr>";
+	
+    // cicasuid
+    $ci_tableau_uid = array("email" => "email", "login" => "login");
+    if (!$cicasuid)
+    	$cicasuid = "email";
+	
+	$res .= "\n<tr><td class='verdana2'>"
+	. "<label for='cicasuid'>"._T('cicas:eq_texte_uid')."</label><br />"
+    . "\n<select name='cicasuid' class='formo' ".($ciedit ? "" : "disabled='disabled'"). ">\n"
+    . "<option value='$cicasuid' selected='selected'>".$ci_tableau_uid[$cicasuid]."</option>\n";
+    
+	foreach ($ci_tableau_uid as $cle => $valeur) {
+	if ($cle <> $cicasuid)
+		$res .= "<option value='$cle'>".$valeur."</option>\n";
+	}
+	
+    $res .= "</select><br />\n";
+	$res .= "</td></tr>"
+	. "\n</table>";
+	
+	$res .= fin_cadre_relief(true);
+    
+    	
+	$res .= '<span><input type="submit" class="fondo" style="float: right;" value="Valider"/></span>'
+	. "</form>";
+	
+	$res = debut_cadre_trait_couleur("", true, "", _T('cicas:eq_titre'))
+	. $res
+	. fin_cadre_trait_couleur(true);
+
+	return $res;
+
+}
+
+function cicas_afficher_choix($nom, $valeur_actuelle, $valeurs, $sep = "<br />", $disabled = false) {
+	$choix = array();
+	while (list($valeur, $titre) = each($valeurs)) {
+		$choix[] = cicas_bouton_radio($nom, $valeur, $titre, $valeur == $valeur_actuelle, $disabled);
+	}
+	return "\n".join($sep, $choix);
+}
+
+function cicas_bouton_radio($nom, $valeur, $titre, $actif = false, $disabled = false) {
+	static $id_label = 0;
+	
+	if ($disabled) $option = " disabled='disabled'";
+	else $option = "";
+    
+	$texte = "<input type='radio' name='$nom' value='$valeur' id='label_${nom}_${id_label}'$option";
+	if ($actif) {
+		$texte .= ' checked="checked"';
+		$titre = '<b>'.$titre.'</b>';
+	}
+	$texte .= " /> <label for='label_${nom}_${id_label}'>$titre</label>\n";
+	$id_label++;
+	return $texte;
+}
+
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/exec/cicas_config.php spip/extensions/cicas/exec/cicas_config.php
--- spip-ori/extensions/cicas/exec/cicas_config.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/exec/cicas_config.php	2013-04-05 11:06:41.181923140 +0200
@@ -0,0 +1,69 @@
+<?php
+/**
+ * Plugin Authentification CAS
+ * Copyright (c) Christophe IMBERTI
+ * Licence Creative commons by-nc-sa
+ */
+
+if (!defined("_ECRIRE_INC_VERSION")) return;
+
+include_spip('inc/presentation');
+include_spip('inc/cicas_commun');
+
+function cicas_appliquer_modifs_config() {
+	
+	$tableau = array();
+
+	$tableau['cicas'] = _request('cicas');
+	$tableau['cicasuid'] = _request('cicasuid');
+	$tableau['cicasurldefaut'] = _request('cicasurldefaut');
+	if (!_request('cicasrepertoire') OR _request('cicasrepertoire')=="/")
+		$tableau['cicasrepertoire'] = "";
+	elseif (substr(_request('cicasrepertoire'),0,1)=="/")
+		$tableau['cicasrepertoire'] = _request('cicasrepertoire');
+	else
+		$tableau['cicasrepertoire'] = "/"._request('cicasrepertoire');
+
+	$tableau['cicasport'] = _request('cicasport');
+
+	$GLOBALS['ciconfig']['cicas'] = $tableau['cicas'];
+	$GLOBALS['ciconfig']['cicasuid'] = $tableau['cicasuid'];
+	$GLOBALS['ciconfig']['cicasurldefaut'] = $tableau['cicasurldefaut'];
+	$GLOBALS['ciconfig']['cicasrepertoire'] = $tableau['cicasrepertoire'];
+	$GLOBALS['ciconfig']['cicasport'] = $tableau['cicasport'];
+	
+	include_spip('inc/meta');
+	ecrire_meta('cicas', @serialize($tableau));
+
+}
+
+
+function exec_cicas_config(){
+
+	if (!autoriser('configurer', 'configuration')) {
+		include_spip('inc/minipres');
+		echo minipres();
+	} else {
+
+		// ne pas stocker en meta si configuration par fichier
+		if (_request('changer_config') == 'oui' AND cicas_lire_meta()) {
+			cicas_appliquer_modifs_config();
+		}
+		
+		$commencer_page = charger_fonction('commencer_page', 'inc');
+		echo $commencer_page(_T('cicas:titre_page_configuration'), "configuration", "configuration");
+		
+		echo "<br /><br /><br />\n";
+		echo gros_titre(_T('cicas:eq_titre'),'', false);
+		
+		echo debut_gauche('', true);	
+		echo creer_colonne_droite('', true);
+		echo debut_droite('', true);
+	
+		$cicas_configuration = charger_fonction('cicas_configuration', 'configuration');
+		echo  $cicas_configuration(), "<br />\n";
+
+		echo fin_gauche(), fin_page();
+	}
+}
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/inc/cicas_commun.php spip/extensions/cicas/inc/cicas_commun.php
--- spip-ori/extensions/cicas/inc/cicas_commun.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/inc/cicas_commun.php	2013-04-05 11:06:41.181923140 +0200
@@ -0,0 +1,359 @@
+<?php
+/**
+ * Plugin Authentification CAS
+ * Copyright (c) Christophe IMBERTI
+ * Licence Creative commons by-nc-sa
+ */
+
+include_spip('inc/cookie');
+ 
+
+/**
+ * D�termination du HOST
+ *
+ * @param : aucun
+ * @return : host
+ */
+function cicas_url_host() {
+
+	$ci_host = "";
+
+	// lire la configuration du plugin
+	cicas_lire_meta();
+	
+	// ordre de recherche par d�faut (celui de phpCAS)
+	$cicashostordre = array('HTTP_X_FORWARDED_SERVER','SERVER_NAME','HTTP_HOST');
+	
+	// ordre de recherche personnalise dans le fichier de parametrage config/_config_cas.php
+	if (isset($GLOBALS['ciconfig']['cicashostordre'])) {
+		if (is_array($GLOBALS['ciconfig']['cicashostordre'])) {
+			$cicashostordre = $GLOBALS['ciconfig']['cicashostordre'];
+		}
+	}
+	
+	foreach ($cicashostordre as $valeur) {
+		if (isset($_SERVER[$valeur])) {
+			if ($_SERVER[$valeur]) {
+				$ci_host = $_SERVER[$valeur];
+				break;
+			}
+		}
+	}
+
+	return $ci_host;
+}
+
+
+/**
+ * D�termination de l'url de retour
+ *
+ * @param : demande de redirection (url)
+ * @return : url de retour
+ */
+function cicas_url_retour($url) {
+	
+	$ci_url = "";
+	
+	// determination du HOST
+	$ci_url = cicas_url_host();
+
+	// cas d'un site en HTTPS
+    	if ( ( !empty( $_SERVER['HTTP_X_FORWARDED_PROTO'] ) ) && ( utf8_strtolower($_SERVER['HTTP_X_FORWARDED_PROTO']) == 'https') ) {
+		$ci_url = "https://".$ci_url;
+	} else if ( ( !empty( $_SERVER['HTTPS'] ) )  && ( utf8_strtolower($_SERVER['HTTPS']) == 'on') ) {
+		$ci_url = "https://".$ci_url;
+	} else {
+		$ci_url = "http://".$ci_url;
+	}
+	
+	// cas particulier d'une adresse du type www.monserveur.com/repertoire_du_site/article.php3...
+	if (isset($_SERVER['REQUEST_URI'])) {
+		// le cas echeant, ne pas tenir compte du repertoire "ecrire"
+		$ci_request_uri = str_replace("/ecrire/", "/", $_SERVER['REQUEST_URI']);
+			
+		$ci_pos = strrpos($ci_request_uri, "/");
+		// ne pas tenir compte du premier "/" dans la recherche
+		if ($ci_pos AND $ci_pos > 0) {
+			$ci_url .= substr($ci_request_uri, 0, $ci_pos);
+		}
+	}
+	
+	// demande de redirection
+	// (ne pas tenir compte du repertoire "ecrire" ni de "./")
+	if ($url AND substr($url,0,6)!="ecrire" AND substr($url,0,1)!=".")
+		$ci_url .= "/".$url;
+	
+	return $ci_url;
+}
+
+
+/**
+ * D�terminer l'URL du serveur CAS (intranet, internet, ...)
+ * correspondant � l'origine de l'appel (.i2 ou .ader.gouv.fr ou .gouv.fr ou .agri)
+ * Les correspondances figurent dans le fichier de parametrage
+ * sinon l'adresse par defaut est utilisee
+ *
+ * @param : aucun
+ * @return :  URL du serveur CAS correspondant � l'origine de l'appel
+ */
+function cicas_url_serveur_cas() {
+
+	$ciurlcas='';
+	
+	// lire la configuration du plugin
+	cicas_lire_meta();
+		
+	// Pour la solution hybride utilisation d'un cookie
+	if ($GLOBALS['ciconfig']['cicas']=='oui' OR $GLOBALS['ciconfig']['cicas']=='hybride') {
+
+		$ci_host = cicas_url_host();
+
+		// adresse par defaut du serveur CAS
+		$ciurlcas=$GLOBALS['ciconfig']['cicasurldefaut'];
+		
+		// autre adresse du serveur CAS	selon le type de terminaison de l'adresse d'appel du site SPIP
+		if (isset($GLOBALS['ciconfig']['cicasurls'])) {
+			if (is_array($GLOBALS['ciconfig']['cicasurls'])) {
+				while (list($terminaison, $valcasurl) = each($GLOBALS['ciconfig']['cicasurls'])) {
+					if (substr($ci_host,-strlen($terminaison))==$terminaison) {
+						$ciurlcas=$valcasurl;
+						break;
+					}
+				}
+			}
+		}
+	}
+
+	return $ciurlcas;
+}	
+
+
+/**
+ * D�termination du code de langue de phpCAS qui correspond au code de langue de SPIP
+ *
+ * @param : code de langue de SPIP
+ * @return : code de langue de phpCAS
+ */
+function cicas_lang_phpcas($lang="") {
+	
+	$return = PHPCAS_LANG_FRENCH;
+
+	if ($lang) {
+		switch ($lang) {
+			case 'en':
+				$return = PHPCAS_LANG_ENGLISH;
+				break;
+			case 'de':
+				$return = PHPCAS_LANG_GERMAN;
+				break;
+			case 'es':
+				$return = PHPCAS_LANG_SPANISH;
+				break;
+		}
+	}
+
+	return $return;
+}	
+
+
+/**
+ * Cible de l'operation de connexion
+ *
+ * @param : $prive
+ * @return : URL
+ */
+function cicas_url_cible($prive=null){
+
+	$cible = "";
+	
+	// La cible de notre operation de connexion
+	$url = _request('url');
+	$cible = isset($url) ? $url : _DIR_RESTREINT;
+	
+	// Si on se connecte dans l'espace prive, 
+	// ajouter "bonjour" (repere a peu pres les cookies desactives)
+	if (is_null($prive) ? cicas_is_url_prive($cible) : $prive) {
+		$cible = parametre_url($cible, 'bonjour', 'oui', '&');
+	}
+	if ($cible=='@page_auteur')
+		$cible = generer_url_entite($GLOBALS['auteur_session']['id_auteur'],'auteur');
+
+	if ($cible) {
+		$cible = parametre_url($cible, 'var_login', '', '&');
+	} 
+	
+	// transformer la cible absolue en cible relative
+	// pour pas echouer quand la meta adresse_site est foireuse
+	if (strncmp($cible,$u = url_de_base(),strlen($u))==0){
+		$cible = "./".substr($cible,strlen($u));
+	}
+
+	return $cible;	
+	
+}
+
+
+/**
+ * L'URL correspond-t-elle � l'espace priv� de SPIP ?
+ *
+ * @param : URL
+ * @return : true ou false
+ */
+function cicas_is_url_prive($cible){
+	$parse = parse_url($cible);
+	return strncmp(substr($parse['path'],-strlen(_DIR_RESTREINT_ABS)), _DIR_RESTREINT_ABS, strlen(_DIR_RESTREINT_ABS))==0;
+}
+
+
+/**
+ * Verification de l'existence de l'identifiant dans la table des auteurs
+ *
+ * @param : identifiant de l'utilisateur renvoye par CAS
+ * @return : tableau vide ou contenant la ligne de l'auteur dans spip_auteurs
+ */
+function cicas_verifier_identifiant($ci_cas_userid) {
+
+	$return = array();
+	
+	// lire la configuration du plugin
+	cicas_lire_meta();
+	
+	// Interdire un email vide
+	if ($ci_cas_userid == '') { 
+		$return = array();
+	} else {
+		// Eviter l'injection SQL
+		$ci_cas_userid=addslashes($ci_cas_userid);
+
+		$select = "*";
+		$from = "spip_auteurs";
+		$where = "(email='".$ci_cas_userid."' OR email='".addslashes(strtolower($ci_cas_userid))."') AND statut<>'5poubelle'";
+		$groupby = "";
+		$orderby = "nom";
+		
+		if ($GLOBALS['ciconfig']['cicasuid']=="login")
+			$where = "(login='".$ci_cas_userid."') AND statut<>'5poubelle'";
+			
+
+		$cinumrows = sql_countsel($from, $where);
+		
+		if ($cinumrows==0) {
+			$return = array();
+		} else if ($cinumrows==1) {
+			$result = sql_select($select, $from, $where,$groupby,$orderby);
+			if ($row = sql_fetch($result)) {
+				$return = $row;
+			}
+		} else if ($cinumrows>1) {
+			$ci_statut="";
+			$result = sql_select($select, $from, $where,$groupby,$orderby);
+			while ($row = sql_fetch($result)) {
+				$cistocker=true;
+				if ($ci_statut) {
+					switch ($row['statut']) {
+					case '0minirezo':
+						if ($ci_statut=='0minirezo') {
+							// garder le pr�c�dent si le suivant est un admin restreint
+							$cinewid=$row['id_auteur'];
+							if (spip_version()>=3)
+								$cirestreint = sql_countsel("spip_auteurs_liens", "objet='rubrique' AND id_auteur=".$cinewid);
+							else													
+								$cirestreint = sql_countsel("spip_auteurs_rubriques", "id_auteur=".$cinewid);
+
+							if ($cirestreint > 0) $cistocker=false;
+						}	
+						break;
+					case 'ciredval':
+						if ($ci_statut=='0minirezo') $cistocker=false;
+						break;
+					case '1comite':
+						if (preg_match("^(0minirezo|ciredval)$",$ci_statut)) $cistocker=false;
+						break;
+					case '6forum':
+						if (preg_match("^(0minirezo|ciredval|1comite)$",$ci_statut)) $cistocker=false;
+						break;
+					}
+				}
+				
+				if ($cistocker) {
+					$ci_statut = $row['statut'];
+					$return = $row;
+				}
+			}
+		}
+	}
+
+
+	if (isset($return['id_auteur'])){
+		// Pour la solution hybride
+		if (_request('cicas')){
+			if (_request('cicas')=="oui"){
+				if(!isset($_COOKIE['cicas_sso'])) {
+					$ci_id_random = mt_rand(1,999999);
+					if (!$ci_id_random) $ci_id_random = rand(1,999999);
+					spip_setcookie('cicas_sso', $ci_id_random);
+				}
+			}
+		}
+	}
+	
+	return $return;
+}
+
+/**
+ * Lecture des parametres de configuration du plugin
+ * et alimentation de variables globales
+ * S'il existe, le parametrage par fichier est prioritaire
+ *
+ * @param : aucun
+ * @return : false si parametrage par fichier, sinon true
+ */
+function cicas_lire_meta() {
+	
+	$return = true;
+	
+	if (!isset($GLOBALS['ciconfig']['cicas'])) {
+
+		$GLOBALS['ciconfig']['cicas'] = '';
+		$GLOBALS['ciconfig']['cicasuid'] = '';
+		$GLOBALS['ciconfig']['cicasurldefaut'] = '';
+		$GLOBALS['ciconfig']['cicasrepertoire'] = '';
+		$GLOBALS['ciconfig']['cicasport'] = '';
+		$GLOBALS['ciconfig']['cicasurls'] = array();
+		
+		$f = _DIR_RACINE . _NOM_PERMANENTS_INACCESSIBLES . '_config_cas.php';
+	
+		if (@file_exists($f)) {
+			// parametrage par fichier
+			include_once($f);
+			
+			// compatibilite ascendante
+			if ($GLOBALS['ciconfig']['cicasport']=='')
+				$GLOBALS['ciconfig']['cicasport'] = '443';
+			
+			$return = false;
+				
+		} else {
+			// configuration du plugin
+			$tableau = array();
+			$tableau = @unserialize($GLOBALS['meta']['cicas']);
+	
+			$GLOBALS['ciconfig']['cicas'] = $tableau['cicas'];
+			$GLOBALS['ciconfig']['cicasuid'] = $tableau['cicasuid'];
+			$GLOBALS['ciconfig']['cicasurldefaut'] = $tableau['cicasurldefaut'];
+			$GLOBALS['ciconfig']['cicasrepertoire'] = $tableau['cicasrepertoire'];
+			$GLOBALS['ciconfig']['cicasport'] = $tableau['cicasport'];
+		}
+	
+		// valeur par d�faut
+		if (!isset($GLOBALS['ciconfig']['cicas']))
+			$GLOBALS['ciconfig']['cicas'] = 'non';
+		elseif ($GLOBALS['ciconfig']['cicas']=='')
+			$GLOBALS['ciconfig']['cicas'] = 'non';
+	
+	}
+		
+    return $return;
+}
+
+?>
diff -rNU5 spip-ori/extensions/cicas/inc/cicas_login.php spip/extensions/cicas/inc/cicas_login.php
--- spip-ori/extensions/cicas/inc/cicas_login.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/inc/cicas_login.php	2013-04-05 11:06:41.181923140 +0200
@@ -0,0 +1,206 @@
+<?php
+/**
+ * Plugin Authentification CAS
+ * Copyright (c) Christophe IMBERTI
+ */
+
+if (!defined("_ECRIRE_INC_VERSION")) return;    #securite
+
+/**
+ * Declenchement de l'authentification CAS puis redirection
+ */
+
+include_spip('inc/headers');
+include_spip('inc/session');
+include_spip('inc/cookie');
+include_spip('inc/texte');
+include_spip('base/abstract_sql');
+include_spip('inc/headers');
+
+include_spip('inc/cicas_commun');
+
+// import phpCAS lib
+include_spip('CAS');
+
+
+// redirection par defaut
+$ciredirect = generer_url_public('');
+
+
+// lire la configuration du plugin
+cicas_lire_meta();
+
+
+// phpCAS::setDebug();
+
+// D�terminer l'origine de l'appel (intranet, internet, ...)
+// .i2 ou .ader.gouv.fr ou .gouv.fr ou .agri
+$ciurlcas=cicas_url_serveur_cas();	
+
+// initialise phpCAS
+$cirep='';
+$ciport=intval($GLOBALS['ciconfig']['cicasport']);
+if (isset($GLOBALS['ciconfig']['cicasrepertoire'])) $cirep=$GLOBALS['ciconfig']['cicasrepertoire'];
+phpCAS::client(CAS_VERSION_2_0,$ciurlcas,$ciport,$cirep);
+
+phpCAS::setNoClearTicketsFromUrl();
+phpCAS::setSingleSignoutCallback('handlelogoutRequest');
+phpCAS::handleLogoutRequests(false);
+phpCAS::setLang(cicas_lang_phpcas($_GET['lang']));
+
+// enlever le pied de page de CAS 
+phpCAS::SetHTMLFooter('<hr>');
+
+// Pour les versions r�centes de phpCAS
+
+if (method_exists('phpCAS','setNoCasServerValidation')) {
+	phpCAS::setNoCasServerValidation();
+}
+
+//phpCAS::setNoCasServerValidation();
+
+// forcer l'authentication CAS
+phpCAS::forceAuthentication();
+
+// A ce stade, l'utilisateur a ete authentifie par le serveur CAS
+// et l'identifiant de l'utilisateur renvoye par CAS peut etre lu avec phpCAS::getUser().
+
+$ci_cas_userid = '';
+if ($ci_cas_userid=phpCAS::getUser()) {
+	
+	$auteur = array();
+	$auteur = cicas_verifier_identifiant($ci_cas_userid);
+
+	if (!isset($auteur['id_auteur'])) {
+		
+		// compatibilit� avec les anciennes adresses email	
+		if (!isset($GLOBALS['ciconfig']['cicasuid']) 
+			OR $GLOBALS['ciconfig']['cicasuid']==""  
+			OR $GLOBALS['ciconfig']['cicasuid']=="email") {
+
+			$ci_pos = strpos($ci_cas_userid, '@');
+			if ($ci_pos AND $ci_pos > 0) {
+				$ci_tableau_email = explode('@',$ci_cas_userid);
+				$ci_nom_mail = strtolower($ci_tableau_email[0]);
+				$ci_domaine_mail = strtolower($ci_tableau_email[1]);
+
+				// compatibilite par defaut
+				$cicasmailcompatible = array('equipement.gouv.fr' => 'developpement-durable.gouv.fr');
+				
+				// compatibilite figurant dans le fichier de parametrage config/_config_cas.php
+				if (isset($GLOBALS['ciconfig']['cicasmailcompatible'])) {
+					if (is_array($GLOBALS['ciconfig']['cicasmailcompatible'])) {
+						$cicasmailcompatible = $GLOBALS['ciconfig']['cicasmailcompatible'];
+					}
+				}
+				
+				foreach ($cicasmailcompatible as $cle=>$valeur) {
+					if ($ci_domaine_mail==$valeur) {
+						$auteur = cicas_verifier_identifiant($ci_nom_mail.'@'.$cle);
+						if (isset($auteur['id_auteur']))
+							break;
+					}
+				}
+			}
+		}
+		
+	}
+
+	if (!isset($auteur['id_auteur'])) {
+		// Envoyer au pipeline
+		$auteur = pipeline('cicas',
+			array(
+				'args' => $ci_cas_userid,
+				'data' => array()
+			)
+		);
+	}	
+	
+	if (isset($auteur['id_auteur'])) {
+
+		// URL cible de l'operation de connexion
+		$cible = cicas_url_cible();
+
+		//  bloquer ici le visiteur qui tente d'abuser de ses droits
+		if (isset($auteur['statut'])) {
+			if (cicas_is_url_prive($cible)) {
+				if ($auteur['statut']=='6forum'){
+					$ciredirect = generer_url_public("cicas_erreur3");
+					// redirection immediate
+					redirige_par_entete($ciredirect);
+				}
+			}
+		}
+		
+		// on a ete authentifie, construire la session
+		// en gerant la duree demandee pour son cookie 
+		if ($session_remember !== NULL)
+			$auteur['cookie'] = $session_remember;
+		$session = charger_fonction('session', 'inc');
+		$session($auteur);
+		$session();
+		session_set('ticket',phpCAS::getTicket());
+/*		
+		$p = ($auteur['prefs']) ? unserialize($auteur['prefs']) : array();
+		$p['cnx'] = ($session_remember == 'oui') ? 'perma' : '';
+		$p = array('prefs' => serialize($p));
+		sql_updateq('spip_auteurs', $p, "id_auteur=" . $auteur['id_auteur']);
+*/
+	
+		// Si on est admin, poser le cookie de correspondance
+		if (isset($auteur['statut'])) {
+			if ($auteur['statut'] == '0minirezo') {
+				include_spip('inc/cookie');
+				spip_setcookie('spip_admin', '@'.$auteur['login'],time() + 7 * 24 * 3600);
+			}
+		}
+	
+		// Si on est connecte, envoyer vers la destination
+		if ($cible)
+			$ciredirect = $cible;
+
+	} else {
+		// Si l'auteur a un compte CAS qui n'existe pas dans la base SPIP
+		$ciredirect = generer_url_public("cicas_erreur2");
+	}
+		
+} else {
+	$ciredirect = generer_url_public("cicas_erreur1");
+}
+
+if (!headers_sent($filename, $linenum)){
+    redirige_par_entete($ciredirect);
+}else{
+	// si les entetes ont deja ete envoyee, redirection par une page  
+	echo '<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">',"\n",
+	  html_lang_attributes(),'
+<head><title>Error</title>
+</head>
+<body>
+<h1>Error : headers already sent by file '.$filename. ', line '.$linenum.'</h1>
+<a href="',
+	  quote_amp(htmlentities($ciredirect)),
+	  '">',
+	  _T('navigateur_pas_redirige'),
+	  '</a></body></html>';
+
+	exit;
+
+}
+
+function handlelogoutRequest($ticket) {
+	$dir = opendir(_DIR_SESSIONS);
+	$t = time()  - (4*_RENOUVELLE_ALEA);
+	while(($f = readdir($dir)) !== false) {
+		if (preg_match(",^\D*(\d+)_\w{32}\.php[3]?$,", $f, $regs)){
+			$f = _DIR_SESSIONS . $f;
+			if (@file_exists($f)) {
+				include_once($f);
+				if (($GLOBALS['visiteur_session']['ticket'] == $ticket) OR ($t > filemtime($f)))
+					spip_unlink($f);
+
+			}
+		}
+	}
+}
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/lang/cicas_en.php spip/extensions/cicas/lang/cicas_en.php
--- spip-ori/extensions/cicas/lang/cicas_en.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/lang/cicas_en.php	2013-04-05 11:06:41.181923140 +0200
@@ -0,0 +1,25 @@
+<?php
+
+// Fichier local de surcharge du fichier de langue
+
+$GLOBALS[$GLOBALS['idx_lang']] = array(
+'eq_avertissement' => '<b>CAUTION</b> : it is imperative to select (below) the authentification mode call "CAS or SPIP" to verify, without risk, the smooth running of the CAS authentification. Once this check made, we can then select (below) the authentification mode call "CAS".', 
+'eq_titre' => 'CICAS plugin management',
+'eq_titre_mode_auth' => 'Authentification mode',
+'eq_lien_auth_hybride' => 'Use CAS authentification',
+'eq_titre_serveur_cas' => 'CAS server management',
+'eq_texte_auth_cas' => 'CAS',
+'eq_texte_auth_hybride' => 'CAS or SPIP',
+'eq_texte_auth_spip' => 'SPIP',
+'eq_texte_host' => 'CAS host',
+'eq_texte_url' => 'CAS url',
+'eq_texte_repertoire' => 'CAS directory',
+'eq_texte_port' => 'CAS port',
+'eq_texte_uid' => 'Userid provide by the CAS server',
+'eq_logout_cas' => 'CAS logout and back to home page',
+'eq_texte_erreur1' => 'You have not been authenticated by the CAS server. Please contact the webmaster of the site.',
+'eq_texte_erreur2' => 'You have been authenticated by the CAS server, but your e-mail address (or your login) has not been found in SPIP. Please contact the webmaster of the site.',
+'titre' => "CAS management (SSO)"
+);
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/lang/cicas_fr.php spip/extensions/cicas/lang/cicas_fr.php
--- spip-ori/extensions/cicas/lang/cicas_fr.php	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/lang/cicas_fr.php	2013-04-05 11:06:41.181923140 +0200
@@ -0,0 +1,25 @@
+<?php
+
+// Fichier local de surcharge du fichier de langue
+
+$GLOBALS[$GLOBALS['idx_lang']] = array(
+'eq_avertissement' => '<b>ATTENTION</b> : Il est imp&eacute;ratif s&eacute;lectionner en premier (ci-dessous) le mode d\'authentification intitul&eacute; <b>"CAS ou SPIP"</b> afin de v&eacute;rifier, sans risque, le bon fonctionnement de l\'authentification CAS. Une fois cette v&eacute;rification effectu&eacute;e on pourra alors s&eacute;lectionner (ci-dessous) le mode d\'authentification intitul&eacute; "CAS".',
+'eq_titre' => 'Configuration du plugin cicas',
+'eq_titre_mode_auth' => 'Mode d\'authentification',
+'eq_lien_auth_hybride' => 'Utiliser l\'authentification centralis&eacute;e',
+'eq_titre_serveur_cas' => 'Configuration du serveur CAS',
+'eq_texte_auth_cas' => 'CAS',
+'eq_texte_auth_hybride' => 'CAS ou SPIP',
+'eq_texte_auth_spip' => 'SPIP',
+'eq_texte_host' => 'Serveur CAS',
+'eq_texte_url' => 'URL du serveur CAS',
+'eq_texte_repertoire' => 'Repertoire du serveur CAS',
+'eq_texte_port' => 'Port du serveur CAS',
+'eq_texte_uid' => 'Identifiant utilisateur fournit par le serveur CAS',
+'eq_logout_cas' => 'Se d&eacute;connecter de CAS et retour &agrave; l\'accueil',
+'eq_texte_erreur1' => 'Vous n\'avez pas &eacute;t&eacute; authentifi&eacute; par le serveur CAS. Veuillez contacter le webmestre du site.',
+'eq_texte_erreur2' => 'Vous avez bien &eacute;t&eacute; authentifi&eacute; par le serveur CAS, mais votre adresse &eacute;lectronique (ou votre login) est introuvable dans SPIP. Veuillez contacter le webmestre du site.',
+'titre' => "Configuration CAS (SSO)"
+);
+
+?>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/extensions/cicas/plugin.xml spip/extensions/cicas/plugin.xml
--- spip-ori/extensions/cicas/plugin.xml	1970-01-01 01:00:00.000000000 +0100
+++ spip/extensions/cicas/plugin.xml	2013-04-05 11:06:41.181923140 +0200
@@ -0,0 +1,37 @@
+<plugin>
+	<nom>cicas : Authentification CAS (SSO)</nom>
+	<auteur>&#169; C. Imberti</auteur>
+	<icon>pyramides-32.png</icon>
+	<licence>[Creative commons by-nc-sa->http://creativecommons.org/licenses/by-nc-sa/2.0/fr/]</licence>
+	<lien></lien>
+	<version>1.42</version>
+	<etat>stable</etat>
+    <slogan>Auteur : &#169; C. Imberti. Licence : Creative commons by-nc-sa.</slogan>
+    <description>
+    Auteur : &#169; C. Imberti. Licence : Creative commons by-nc-sa.<br />
+    Il convient de configurer le plugin avant utilisation.
+    Pour PHP version 5 et plus.
+    </description>
+	<prefix>cicas</prefix>
+	
+	<pipeline>
+		<nom>recuperer_fond</nom>
+		<inclure>cicas_pipeline.php</inclure>
+	</pipeline>
+	
+    <bouton id='cicas_config' parent='configuration'>
+	<icone>cicas.gif</icone>
+		<titre>Configurer CAS (SSO)</titre>
+		<url>cicas_config</url>
+	</bouton>
+
+	<bouton id='cicas_config3' parent='bando_configuration'>
+		<titre>cicas:titre</titre>
+		<icone>images/cicas.png</icone>
+		<url>cicas_config</url>
+	</bouton>
+
+	
+	<necessite id="SPIP" version='[2.0.9;]' />
+
+</plugin>
\ Pas de fin de ligne à la fin du fichier
diff -rNU5 spip-ori/.htaccess spip/.htaccess
--- spip-ori/.htaccess	1970-01-01 01:00:00.000000000 +0100
+++ spip/.htaccess	2013-04-05 11:06:41.181923140 +0200
@@ -0,0 +1,142 @@
+##############################################################
+# Fichier .htaccess                               SPIP v 2.0 #
+#                                                            #
+# Permet de controler les URLs et la version de php utilisee #
+# Compatible avec les URLs 'html', 'propres' et 'propres2'   #
+# Permet aussi d'effectuer la transition de .PHP 3 vers .PHP #
+#                                                            #
+# Pour utiliser ce fichier renommez-le '.htaccess' dans le   #
+# repertoire racine du site, en veillant a ne pas ecraser un #
+# .htaccess personnalise qui s'y trouverait deja             #
+#                                                            #
+# Attention certains hebergeurs desactivent tout ou partie   #
+# des fonctions du fichier .htaccess ; celui-ci est donc     #
+# indicatif - en cas de difficulte voir sur les forums SPIP  #
+##############################################################
+
+RewriteEngine On
+
+#Mutualisation avec domaine/site
+RewriteBase /spip/
+
+RewriteCond %{REQUEST_URI} !^/spip/(config|squelettes-dist|ecrire|IMG|oo|plugins|sites|squelettes|tmp|local|prive)/(.*)
+RewriteRule ^[^/]+/(.*) /spip/$1 [QSA,L]
+
+################ CONFIGURATION ######################
+
+### Configuration sous-repertoire
+# Chez la plupart des hebergeurs il faut indiquer "RewriteBase /"
+# sinon modifiez cette ligne
+
+#RewriteBase /
+
+
+# SPIP version 'php' - si vous avez d'anciennes adresses en '.php[3]',
+# supprimez le '#' sur les lignes qui suivent pour rediriger les acces
+# errones vers le .php correspondant
+
+#RewriteCond %{REQUEST_FILENAME} -f
+#RewriteRule ^(.+)\.php[3]$ $1.php [QSA,L]
+
+# Fin version
+###
+
+
+################ REGLAGES PERSONNALISES ######################
+# Inscrivez ci-dessous vos reglages supplementaires
+
+
+
+
+################ GESTIONS DES URLS SPIP #######################
+
+# Deux pseudo-actions a present evacuees
+# N'y at-il pas moyen de REMPLACER un nom dans la QueryString ?
+RewriteCond %{QUERY_STRING} action=rss
+RewriteRule spip.php	spip.php?page=rss [QSA,L]
+RewriteCond %{QUERY_STRING} action=ical
+RewriteRule spip.php	spip.php?page=ical_prive [QSA,L]
+
+###
+# Si le fichier ou repertoire demande existe
+# ignorer toutes les regles qui suivent
+RewriteCond %{REQUEST_FILENAME} -f
+RewriteRule "." - [skip=100]
+RewriteCond %{REQUEST_FILENAME} -d
+RewriteRule "." - [skip=100]
+#
+###
+
+
+###
+# Compatibilite avec les URLS "html" (pour transition sympa)
+# voir fichier ecrire/urls/html.php
+RewriteRule ^rubrique([0-9]+)(\.html)?$	spip.php?page=rubrique&id_rubrique=$1 [QSA,L]
+RewriteRule ^article([0-9]+)(\.html)?$	spip.php?page=article&id_article=$1 [QSA,L]
+RewriteRule ^breve([0-9]+)(\.html)?$	spip.php?page=breve&id_breve=$1 [QSA,L]
+RewriteRule ^mot([0-9]+)(\.html)?$		spip.php?page=mot&id_mot=$1 [QSA,L]
+RewriteRule ^auteur([0-9]+)(\.html)?$	spip.php?page=auteur&id_auteur=$1 [QSA,L]
+RewriteRule ^site([0-9]+)(\.html)?$	spip.php?page=site&id_syndic=$1 [QSA,L]
+# Compatibilite avec les anciennes URLS appelant directement des fichiers php
+RewriteRule ^(rubrique|article|breve|mot|auteur|site|agenda|backend|backend-breves|distrib|forum|ical|plan|recherche|sommaire|sommaire_texte)\.php3?$	spip.php?page=$1 [QSA,L]
+RewriteRule ^resume.php[3]?	spip.php?page=sommaire [QSA,L]
+RewriteRule ^page.php[3]?	spip.php [QSA,L]
+RewriteRule ^spip_cal\.php3?$	spip.php?page=ical_prive [QSA,L]
+RewriteRule ^spip_rss\.php3?$	spip.php?page=rss [QSA,L]
+
+
+# Fin compatibilite
+###
+
+###
+# ping http://site/1234 => article1234
+
+RewriteRule ^([1-9][0-9]*)$     spip.php?action=redirect&type=article&status=301&id=$1 [QSA,L]
+
+#
+###
+
+
+###
+# URLs "propres", "propres2", "libres", "arbo"
+
+RewriteRule ^[^\.]+(\.html)?$		spip.php [QSA,E=url_propre:$0,L]
+
+# Fin URLs "propres" et "propres2"
+###
+
+###
+# Divers
+
+# bloquer les acces aux repertoires .svn/ (SPIP, plugins, squelettes...)
+RewriteRule ^(.*/)?\.svn/ - [F]
+
+###
+# Fichiers "standards" (si absents de la racine)
+#
+RewriteRule ^robots[.]txt$      spip.php?page=robots.txt [QSA,L]
+RewriteRule ^favicon[.]ico$      spip.php?page=favicon.ico [QSA,L]
+RewriteRule ^sitemap[.]xml$      spip.php?page=sitemap.xml [QSA,L]
+##
+
+# expirer les images (pour contourner gros bug MSIE sur le cache)
+# note : a decommenter si vous voulez tester
+#<IfModule mod_expires.c>
+# ExpiresActive on
+# ExpiresByType image/gif A3600
+# ExpiresByType image/jpeg A3600
+# ExpiresByType image/png A3600
+#</IfModule>
+
+#################################
+# gestion des erreurs 404
+# voir http://www.spip.net/fr_article3226.html
+# Pour que le serveur http renvoie les erreurs 404 vers SPIP, supprimer le '#'
+
+# ErrorDocument 404 /spip.php?page=404
+
+#
+###
+
+
+
diff -rNU5 spip-ori/htaccess.txt spip/htaccess.txt
--- spip-ori/htaccess.txt	2011-04-06 22:30:57.000000000 +0200
+++ spip/htaccess.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,133 +0,0 @@
-##############################################################
-# Fichier .htaccess                               SPIP v 2.0 #
-#                                                            #
-# Permet de controler les URLs et la version de php utilisee #
-# Compatible avec les URLs 'html', 'propres' et 'propres2'   #
-# Permet aussi d'effectuer la transition de .PHP 3 vers .PHP #
-#                                                            #
-# Pour utiliser ce fichier renommez-le '.htaccess' dans le   #
-# repertoire racine du site, en veillant a ne pas ecraser un #
-# .htaccess personnalise qui s'y trouverait deja             #
-#                                                            #
-# Attention certains hebergeurs desactivent tout ou partie   #
-# des fonctions du fichier .htaccess ; celui-ci est donc     #
-# indicatif - en cas de difficulte voir sur les forums SPIP  #
-##############################################################
-
-RewriteEngine On
-
-################ CONFIGURATION ######################
-
-### Configuration sous-repertoire
-# Chez la plupart des hebergeurs il faut indiquer "RewriteBase /"
-# sinon modifiez cette ligne
-
-RewriteBase /
-
-
-# SPIP version 'php' - si vous avez d'anciennes adresses en '.php[3]',
-# supprimez le '#' sur les lignes qui suivent pour rediriger les acces
-# errones vers le .php correspondant
-
-#RewriteCond %{REQUEST_FILENAME} -f
-#RewriteRule ^(.+)\.php[3]$ $1.php [QSA,L]
-
-# Fin version
-###
-
-
-################ REGLAGES PERSONNALISES ######################
-# Inscrivez ci-dessous vos reglages supplementaires
-
-
-
-
-################ GESTIONS DES URLS SPIP #######################
-
-# Deux pseudo-actions a present evacuees
-# N'y at-il pas moyen de REMPLACER un nom dans la QueryString ?
-RewriteCond %{QUERY_STRING} action=rss
-RewriteRule spip.php	spip.php?page=rss [QSA,L]
-RewriteCond %{QUERY_STRING} action=ical
-RewriteRule spip.php	spip.php?page=ical_prive [QSA,L]
-
-###
-# Si le fichier ou repertoire demande existe
-# ignorer toutes les regles qui suivent
-RewriteCond %{REQUEST_FILENAME} -f
-RewriteRule "." - [skip=100]
-RewriteCond %{REQUEST_FILENAME} -d
-RewriteRule "." - [skip=100]
-#
-###
-
-
-###
-# Compatibilite avec les URLS "html" (pour transition sympa)
-# voir fichier ecrire/urls/html.php
-RewriteRule ^rubrique([0-9]+)(\.html)?$	spip.php?page=rubrique&id_rubrique=$1 [QSA,L]
-RewriteRule ^article([0-9]+)(\.html)?$	spip.php?page=article&id_article=$1 [QSA,L]
-RewriteRule ^breve([0-9]+)(\.html)?$	spip.php?page=breve&id_breve=$1 [QSA,L]
-RewriteRule ^mot([0-9]+)(\.html)?$		spip.php?page=mot&id_mot=$1 [QSA,L]
-RewriteRule ^auteur([0-9]+)(\.html)?$	spip.php?page=auteur&id_auteur=$1 [QSA,L]
-RewriteRule ^site([0-9]+)(\.html)?$	spip.php?page=site&id_syndic=$1 [QSA,L]
-# Compatibilite avec les anciennes URLS appelant directement des fichiers php
-RewriteRule ^(rubrique|article|breve|mot|auteur|site|agenda|backend|backend-breves|distrib|forum|ical|plan|recherche|sommaire|sommaire_texte)\.php3?$	spip.php?page=$1 [QSA,L]
-RewriteRule ^resume.php[3]?	spip.php?page=sommaire [QSA,L]
-RewriteRule ^page.php[3]?	spip.php [QSA,L]
-RewriteRule ^spip_cal\.php3?$	spip.php?page=ical_prive [QSA,L]
-RewriteRule ^spip_rss\.php3?$	spip.php?page=rss [QSA,L]
-
-
-# Fin compatibilite
-###
-
-###
-# ping http://site/1234 => article1234
-
-RewriteRule ^([1-9][0-9]*)$     spip.php?action=redirect&type=article&status=301&id=$1 [QSA,L]
-
-#
-###
-
-
-###
-# URLs "propres", "propres2", "libres", "arbo"
-
-RewriteRule ^[^\.]+(\.html)?$		spip.php [QSA,E=url_propre:$0,L]
-
-# Fin URLs "propres" et "propres2"
-###
-
-###
-# Divers
-
-# bloquer les acces aux repertoires .svn/ (SPIP, plugins, squelettes...)
-RewriteRule ^(.*/)?\.svn/ - [F]
-
-###
-# Fichiers "standards" (si absents de la racine)
-#
-RewriteRule ^robots[.]txt$      spip.php?page=robots.txt [QSA,L]
-RewriteRule ^favicon[.]ico$      spip.php?page=favicon.ico [QSA,L]
-RewriteRule ^sitemap[.]xml$      spip.php?page=sitemap.xml [QSA,L]
-##
-
-# expirer les images (pour contourner gros bug MSIE sur le cache)
-# note : a decommenter si vous voulez tester
-#<IfModule mod_expires.c>
-# ExpiresActive on
-# ExpiresByType image/gif A3600
-# ExpiresByType image/jpeg A3600
-# ExpiresByType image/png A3600
-#</IfModule>
-
-#################################
-# gestion des erreurs 404
-# voir http://www.spip.net/fr_article3226.html
-# Pour que le serveur http renvoie les erreurs 404 vers SPIP, supprimer le '#'
-
-# ErrorDocument 404 /spip.php?page=404
-
-#
-###
diff -rNU5 spip-ori/INSTALL.txt spip/INSTALL.txt
--- spip-ori/INSTALL.txt	2011-04-06 22:30:57.000000000 +0200
+++ spip/INSTALL.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,15 +0,0 @@
-
-###### Installation de SPIP #####
-
-Rendez-vous avec votre navigateur sur la page ecrire/
-pour commencer l'installation de votre site SPIP.
-
-Votre serveur Web doit offrir php (version > 4.0.8) et MySQL.
-
-Pour permettre a SPIP de gerer de belles adresses (URL),
-vous devrez probablement renommer le fichier htaccess.txt
-en .htaccess a la racine du site (apres avoir, si necessaire,
-edite la ligne RewriteBase ; voir les commentaires).
-
-################################# http://www.spip.net/
-
diff -rNU5 spip-ori/tmp/remove.txt spip/tmp/remove.txt
--- spip-ori/tmp/remove.txt	2011-04-06 22:30:28.000000000 +0200
+++ spip/tmp/remove.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-Vous pouvez effacer ce fichier sans dommages.
-
-You can safely remove this file.
